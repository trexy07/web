====_ajax.js(file) start====
// ajax
__BRYTHON__.imported._ajax = (function($B){
var $N = $B.builtins.None,
    _b_ = $B.builtins

var add_to_res = function(res, key, val) {
    if($B.$isinstance(val, _b_.list)){
        for (j = 0; j < val.length; j++) {
            add_to_res(res, key, val[j])
        }
    }else if (val instanceof File || val instanceof Blob){
        res.append(key, val)
    }else{res.append(key, _b_.str.$factory(val))}
}

function set_timeout(self, timeout){
    if(timeout.seconds !== undefined){
        self.js.$requestTimer = setTimeout(
            function() {
                self.js.abort()
                if(timeout.func){
                    timeout.func()
                }
            },
            timeout.seconds * 1000)
    }
}

function _read(req){
    var xhr = req.js
    if(xhr.responseType == "json"){
        return $B.structuredclone2pyobj(xhr.response)
    }
    if(req.charset_user_defined){
        // on blocking mode, xhr.response is a string
        var bytes = []
        for(var i = 0, len = xhr.response.length; i < len; i++){
            var cp = xhr.response.codePointAt(i)
            if(cp > 0xf700){
                bytes.push(cp - 0xf700)
            }else{
                bytes.push(cp)
            }
        }
    }else if(typeof xhr.response == "string"){
        if(req.mode == 'binary'){
            return _b_.str.encode(xhr.response, req.encoding || 'utf-8')
        }
        return xhr.response
    }else{
        // else it's an ArrayBuffer
        var buf = new Uint8Array(xhr.response),
            bytes = Array.from(buf.values())
    }
    var b = _b_.bytes.$factory(bytes)
    if(req.mode == "binary"){
        return b
    }else if(req.mode == "document"){
        return $B.jsobj2pyobj(xhr.response)
    }else{
        var encoding = req.encoding || "utf-8"
        return _b_.bytes.decode(b, encoding)
    }
}

function stringify(d){
    var items = []
    for(var entry of _b_.dict.$iter_items(d)){
        items.push(encodeURIComponent(entry.key) + "=" +
                   encodeURIComponent(entry.value))
    }
    return items.join("&")
}

function handle_kwargs(self, kw, method){
    // kw was created with $B.obj_dict(), its keys/values are in kw.$jsobj
    var data,
        encoding,
        headers={},
        cache,
        mode = "text",
        timeout = {},
        rawdata

    for(var item of _b_.dict.$iter_items(kw)){
        var key = item.key
        if(key == "data"){
            var rawdata = item.value
            if(typeof rawdata == "string" || rawdata instanceof FormData){
                data = rawdata
            }else if(rawdata.__class__ === _b_.dict){
                data = stringify(rawdata)
            }else{
                throw _b_.TypeError.$factory("wrong type for data: " +
                    $B.class_name(rawdata))
            }
        }else if(key == "encoding"){
            encoding = item.value
        }else if(key == "headers"){
            var value = item.value
            if(! $B.$isinstance(value, _b_.dict)){
                throw _b_.ValueError.$factory(
                    "headers must be a dict, not " + $B.class_name(value))
            }
            for(var subitem of _b_.dict.$iter_items(value)){
                headers[subitem.key.toLowerCase()] = subitem.value
            }
        }else if(key.startsWith("on")){
            var event = key.substr(2)
            if(event == "timeout"){
                timeout.func = item.value
            }else{
                var f = item.value
                ajax.bind(self, event, f)
            }
        }else if(key == "mode"){
            var mode = item.value
        }else if(key == "timeout"){
            timeout.seconds = item.value
        }else if(key == "cache"){
            cache = item.value
        }
    }
    if(encoding && mode != "text"){
        throw _b_.ValueError.$factory("encoding not supported for mode " +
            mode)
    }
    if((method == "post" || method == "put") && ! headers){
        // For POST requests, set default header
        self.js.setRequestHeader("Content-type",
                                 "application/x-www-form-urlencoded")
    }

    return {cache, data, rawdata, encoding, headers, mode, timeout}
}

var ajax = $B.make_class('ajax')

ajax.__repr__ = function(self){
    return '<object Ajax>'
}

ajax.__getattribute__ = function(self, attr){
    if(ajax[attr] !== undefined){
        return function(){
            return ajax[attr].call(null, self, ...arguments)
        }
    }else if(attr == "text"){
        return _read(self)
    }else if(attr == "json"){
        if(self.js.responseType == "json"){
            return _read(self)
        }else{
            var resp = _read(self)
            try{
                return $B.structuredclone2pyobj(JSON.parse(resp))
            }catch(err){
                console.log('attr json, invalid resp', resp)
                throw err
            }
        }
    }else if(self.js[attr] !== undefined){
        if(typeof self.js[attr] == "function"){
            return function(){
                if(attr == "setRequestHeader"){
                    ajax.set_header.call(null, self, ...arguments)
                }else{
                    if(attr == 'overrideMimeType'){
                        console.log('override mime type')
                        self.hasMimeType = true
                    }
                    return self.js[attr](...arguments)
                }
            }
        }else{
            return self.js[attr]
        }
    }else if(attr == "xml"){
        return $B.jsobj2pyobj(self.js.responseXML)
    }
}

ajax.bind = function(self, evt, func){
    // req.bind(evt,func) is the same as req.onevt = func
    self.js['on' + evt] = function(){
        try{
            return func.apply(null, arguments)
        }catch(err){
            $B.handle_error(err)
        }
    }
    return _b_.None
}

ajax.open = function(){
    var $ = $B.args('open', 4,
            {self: null, method: null, url: null, async: null},
            ['self', 'method', 'url', 'async'], arguments,
            {async: true}, null, null),
        self = $.self,
        method = $.method,
        url = $.url,
        async = $.async
    if(typeof method !== "string"){
        throw _b_.TypeError.$factory(
            'open() argument method should be string, got ' +
            $B.class_name(method))
    }
    if(typeof url !== "string"){
        throw _b_.TypeError.$factory(
            'open() argument url should be string, got ' +
            $B.class_name(url))
    }
    self.$method = method
    self.blocking = ! self.async
    self.js.open(method, url, async)
}

ajax.read = function(self){
    return _read(self)
}

ajax.send = function(self, params){
    // params can be Python dictionary or string
    var content_type
    for(var key in self.headers){
        var value = self.headers[key]
        self.js.setRequestHeader(key, value)
        if(key == 'content-type'){
            content_type = value
        }
    }
    if((self.encoding || self.blocking) && ! self.hasMimeType){
        // On blocking mode, or if an encoding has been specified,
        // override Mime type so that bytes are not processed
        // (unless the Mime type has been explicitely set)
        self.js.overrideMimeType('text/plain;charset=x-user-defined')
        self.charset_user_defined = true
    }
    var res = ''
    if(! params){
        self.js.send()
        return _b_.None
    }
    if($B.$isinstance(params, _b_.str)){
        res = params
    }else if($B.$isinstance(params, _b_.dict)){
        if(content_type == 'multipart/form-data'){
            // The FormData object serializes the data in the 'multipart/form-data'
            // content-type so we may as well override that header if it was set
            // by the user.
            res = new FormData()
            var items = _b_.list.$factory(_b_.dict.items(params))
            for(var i = 0, len = items.length; i < len; i++){
                add_to_res(res, _b_.str.$factory(items[i][0]), items[i][1])
            }
        }else{
            if(self.$method && self.$method.toUpperCase() == "POST" &&
                    ! content_type){
                // Set default Content-Type for POST requests
                self.js.setRequestHeader("Content-Type",
                    "application/x-www-form-urlencoded")
            }
            var items = _b_.list.$factory(_b_.dict.items(params))
            for(var i = 0, len = items.length; i < len; i++){
                var key = encodeURIComponent(_b_.str.$factory(items[i][0]));
                if($B.$isinstance(items[i][1], _b_.list)){
                    for (j = 0; j < items[i][1].length; j++) {
                        res += key +'=' +
                            encodeURIComponent(_b_.str.$factory(items[i][1][j])) + '&'
                    }
                }else{
                    res += key + '=' +
                        encodeURIComponent(_b_.str.$factory(items[i][1])) + '&'
                }
            }
            res = res.substr(0, res.length - 1)
        }
    }else if(params instanceof FormData){
        res = params
    }else{
        throw _b_.TypeError.$factory(
            "send() argument must be string or dictionary, not '" +
            _b_.str.$factory(params.__class__) + "'")
    }
    self.js.send(res)
    return _b_.None
}

ajax.responseType = _b_.property.$factory(
    function(_self){
        return _self.responseType
    },
    function(_self, value){
        console.log('set response type', value)
        _self.js.responseType = value
    }
)

ajax.set_header = function(self, key, value){
    self.headers[key.toLowerCase()] = value
}

ajax.set_timeout = function(self, seconds, func){
    self.js.$requestTimer = setTimeout(
        function() {
            self.js.abort()
            func()
        },
        seconds * 1000)
}

ajax.$factory = function(){

    var xmlhttp = new XMLHttpRequest()

    xmlhttp.onreadystatechange = function(){
        // here, "this" refers to xmlhttp
        var state = this.readyState
        if(this.responseType == "" || this.responseType == "text"){
            res.js.text = this.responseText
        }
        var timer = this.$requestTimer
        if(state == 0 && this.onuninitialized){
            this.onuninitialized(res)
        }else if(state == 1 && this.onloading){
            this.onloading(res)
        }else if(state == 2 && this.onloaded){
            this.onloaded(res)
        }else if(state == 3 && this.oninteractive){
            this.oninteractive(res)
        }else if(state == 4 && this.oncomplete){
            if(timer !== null){
                globalThis.clearTimeout(timer)
            }
            this.oncomplete(res)
        }
    }
    var res = {
        __class__: ajax,
        js: xmlhttp,
        headers: {}
    }
    return res
}
function _request_without_body(method){
    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},
        ["method", "url", "blocking"], arguments, {blocking: false},
        null, "kw"),
    method = $.method,
    url = $.url,
    async = !$.blocking,
    kw = $.kw

    var self = ajax.$factory()
    self.blocking = $.blocking
    var items = handle_kwargs(self, kw, method),
        mode = self.mode = items.mode,
        encoding = self.encoding = items.encoding,
        qs = items.data
    if(qs){
        url += "?" + qs
    }
    if(! (items.cache === true)){
        url += (qs ? "&" : "?") + (new Date()).getTime()
    }
    self.js.open(method.toUpperCase(), url, async)

    if(async){
        if(mode == "json" || mode == "document"){
            self.js.responseType = mode
        }else{
            self.js.responseType = "arraybuffer"
            if(mode != "text" && mode != "binary"){
                throw _b_.ValueError.$factory("invalid mode: " + mode)
            }
        }
    }else{
        self.js.overrideMimeType('text/plain;charset=x-user-defined')
        self.charset_user_defined = true
    }
    for(var key in items.headers){
        self.js.setRequestHeader(key, items.headers[key])
    }
    var timeout = items.timeout
    if(timeout.seconds){
        ajax.set_timeout(self, timeout.seconds, timeout.func)
    }
    // Add function read() to return str or bytes according to mode
    self.js.send()
}

function _request_with_body(method){
    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},
        ["method", "url", "blocking"], arguments, {blocking: false},
        null, "kw"),
        method = $.method,
        url = $.url,
        async = !$.blocking,
        kw = $.kw,
        content_type
    var self = ajax.$factory()
    self.js.open(method.toUpperCase(), url, async)
    var items = handle_kwargs(self, kw, method), // common with browser.aio
        data = items.data

    if($B.$isinstance(data, _b_.dict)){
        data = stringify(data)
    }
    for(var key in items.headers){
        var value = items.headers[key]
        self.js.setRequestHeader(key, value)
        if(key == 'content-type'){
            content_type = value
        }
    }
    if(method.toUpperCase() == 'POST' && !content_type){
        // set default Content-Type for POST requests
        self.js.setRequestHeader('Content-Type',
            'application/x-www-form-urlencoded')
    }

    // Add function read() to return str or bytes according to mode
    self.js.read = function(){
        return _read(self)
    }
    self.js.send(data)
}

function form_data(form){
    var missing = {},
        $ = $B.args('form_data', 1, {form: null}, ['form'], arguments,
            {form: missing}, null, null)
    if($.form === missing){
        return new FormData()
    }else{
        return new FormData($.form)
    }
}

function connect(){
    _request_without_body.call(null, "connect", ...arguments)
}

function _delete(){
    _request_without_body.call(null, "delete", ...arguments)
}

function get(){
    _request_without_body.call(null, "get", ...arguments)
}

function head(){
    _request_without_body.call(null, "head", ...arguments)
}

function options(){
    _request_without_body.call(null, "options", ...arguments)
}

function patch(){
    _request_with_body.call(null, "put", ...arguments)
}

function post(){
    _request_with_body.call(null, "post", ...arguments)
}

function put(){
    _request_with_body.call(null, "put", ...arguments)
}

function trace(){
    _request_without_body.call(null, "trace", ...arguments)
}

function file_upload(){
    // ajax.file_upload(url, file, method="POST", **callbacks)
    var $ = $B.args("file_upload", 2, {url: null, "file": file},
            ["url", "file"], arguments, {}, null, "kw"),
        url = $.url,
        file = $.file,
        kw = $.kw

    var self = ajax.$factory()

    var items = handle_kwargs(self, kw, method),
        rawdata = items.rawdata,
        headers = items.headers

    for(var key in headers){
        var value = headers[key]
        self.js.setRequestHeader(key, value)
        if(key == 'content-type'){
            content_type = value
        }
    }

    var timeout = items.timeout
    if(timeout.seconds){
        ajax.set_timeout(self, timeout.seconds, timeout.func)
    }

    var method = _b_.dict.$get_string(kw, 'method', 'POST'),
        field_name = _b_.dict.$get_string(kw, 'field_name', 'filetosave')

    var formdata = new FormData()
    formdata.append(field_name, file, file.name)

    if(rawdata){
        if(rawdata instanceof FormData){
            // append additional data
            for(var d of rawdata){
                formdata.append(d[0], d[1])
            }
        }else if($B.$isinstance(rawdata, _b_.dict)){
            for(var item of _b_.dict.$iter_items(rawdata)){
                formdata.append(item.key, item.value)
            }
        }else{
            throw _b_.ValueError.$factory(
                'data value must be a dict of form_data')
        }
    }

    self.js.open(method, url, _b_.True)
    self.js.send(formdata)

}

$B.set_func_names(ajax)

return {
    ajax: ajax,
    Ajax: ajax,
    delete: _delete,
    file_upload: file_upload,
    connect,
    form_data,
    get,
    head,
    options,
    patch,
    post,
    put,
    trace
}

})(__BRYTHON__)
====_ajax.js(file) end====

====_codecs.py(module) start====

def ascii_decode(*args,**kw):
 pass
def ascii_encode(*args,**kw):
 pass
def charbuffer_encode(*args,**kw):
 pass
def charmap_build(decoding_table):
 return{car:i for(i,car)in enumerate(decoding_table)}
def charmap_decode(input,errors,decoding_table):
 res=''
 for car in input:
  code=decoding_table[car]
  if code is None:
   raise UnicodeDecodeError(input)
  res +=code
 return res,len(input)
def charmap_encode(input,errors,encoding_table):
 t=[]
 for car in input:
  code=encoding_table.get(car)
  if code is None:
   raise UnicodeEncodeError(input)
  t.append(code)
 return bytes(t),len(input)
def decode(obj,encoding="utf-8",errors="strict"):
 ''
 return __BRYTHON__.decode(obj,encoding,errors)
def encode(obj,encoding="utf-8",errors="strict"):
 ''
 return __BRYTHON__.encode(obj,encoding,errors)
def escape_decode(*args,**kw):
 pass
def escape_encode(*args,**kw):
 pass
def latin_1_decode(*args,**kw):
 pass
def latin_1_encode(*args,**kw):
 pass
def lookup(encoding):
 ''
 if encoding in('utf-8','utf_8'):
  from browser import console
  import encodings.utf_8
  return encodings.utf_8.getregentry()
 LookupError(encoding)
def lookup_error(*args,**kw):
 ''
 pass
def mbcs_decode(*args,**kw):
 pass
def mbcs_encode(*args,**kw):
 pass
def raw_unicode_escape_decode(*args,**kw):
 pass
def raw_unicode_escape_encode(*args,**kw):
 pass
def readbuffer_encode(*args,**kw):
 pass
def register(*args,**kw):
 ''
 pass
def register_error(*args,**kw):
 ''
 pass
def unicode_escape_decode(*args,**kw):
 pass
def unicode_escape_encode(*args,**kw):
 pass
def unicode_internal_decode(*args,**kw):
 pass
def unicode_internal_encode(*args,**kw):
 pass
def utf_16_be_decode(*args,**kw):
 pass
def utf_16_be_encode(*args,**kw):
 pass
def utf_16_decode(*args,**kw):
 pass
def utf_16_encode(*args,**kw):
 pass
def utf_16_ex_decode(*args,**kw):
 pass
def utf_16_le_decode(*args,**kw):
 pass
def utf_16_le_encode(*args,**kw):
 pass
def utf_32_be_decode(*args,**kw):
 pass
def utf_32_be_encode(*args,**kw):
 pass
def utf_32_decode(*args,**kw):
 pass
def utf_32_encode(*args,**kw):
 pass
def utf_32_ex_decode(*args,**kw):
 pass
def utf_32_le_decode(*args,**kw):
 pass
def utf_32_le_encode(*args,**kw):
 pass
def utf_7_decode(*args,**kw):
 pass
def utf_7_encode(*args,**kw):
 pass
def utf_8_decode(decoder,bytes_obj,errors,*args):
 return(bytes_obj.decode("utf-8"),len(bytes_obj))
def utf_8_encode(*args,**kw):
 input=args[0]
 if len(args)==2:
  errors=args[1]
 else:
  errors=kw.get('errors','strict')
 return(bytes(input,'utf-8'),len(input))
====_codecs.py(module) end====

====_dummy_thread.py(module) start====
''
__all__=['error','start_new_thread','exit','get_ident','allocate_lock',
'interrupt_main','LockType','RLock']
TIMEOUT_MAX=2 **31
error=RuntimeError

def start_new_thread(function,args,kwargs={}):
 ''
 if type(args)!=type(tuple()):
  raise TypeError("2nd arg must be a tuple")
 if type(kwargs)!=type(dict()):
  raise TypeError("3rd arg must be a dict")
 global _main
 _main=False
 try:
  function(*args,**kwargs)
 except SystemExit:
  pass
 except:
  import traceback
  traceback.print_exc()
 _main=True
 global _interrupt
 if _interrupt:
  _interrupt=False
  raise KeyboardInterrupt
def exit():
 ''
 raise SystemExit
def get_ident():
 ''
 return 1
def allocate_lock():
 ''
 return LockType()
def stack_size(size=None):
 ''
 if size is not None:
  raise error("setting thread stack size not supported")
 return 0
def _set_sentinel():
 ''
 return LockType()
class LockType(object):
 ''
 def __init__(self):
  self.locked_status=False
 def acquire(self,waitflag=None,timeout=-1):
  ''
  if waitflag is None or waitflag:
   self.locked_status=True
   return True
  else:
   if not self.locked_status:
    self.locked_status=True
    return True
   else:
    if timeout >0:
     import time
     time.sleep(timeout)
    return False
 __enter__=acquire
 def __exit__(self,typ,val,tb):
  self.release()
 def release(self):
  ''
  if not self.locked_status:
   raise error
  self.locked_status=False
  return True
 def locked(self):
  return self.locked_status
 def __repr__(self):
  return "<%s %s.%s object at %s>"%(
  "locked"if self.locked_status else "unlocked",
  self.__class__.__module__,
  self.__class__.__qualname__,
  hex(id(self))
  )
class RLock(LockType):
 ''
 def __init__(self):
  super().__init__()
  self._levels=0
 def acquire(self,waitflag=None,timeout=-1):
  ''
  locked=super().acquire(waitflag,timeout)
  if locked:
   self._levels +=1
  return locked
 def release(self):
  ''
  if self._levels ==0:
   raise error
  if self._levels ==1:
   super().release()
  self._levels -=1
_interrupt=False

_main=True

def interrupt_main():
 ''
 if _main:
  raise KeyboardInterrupt
 else:
  global _interrupt
  _interrupt=True
====_dummy_thread.py(module) end====

====_json.js(file) start====
(function($B){

var _b_ = $B.builtins

function simple(obj){
    switch(typeof obj){
        case 'string':
        case 'number':
        case 'boolean':
            return true
    }
    if(obj instanceof Number ||
            Array.isArray(obj) ||
            $B.$isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){
        return true
    }
    return false
}

function to_json(obj, level){
    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,
            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,
            indent:_b_.None, separators:_b_.None, "default":_b_.None,
            sort_keys:_b_.False},
        $ = $B.args("to_json", 2, {obj: null, level: null}, ['obj', 'level'],
                    arguments, {level: 1}, null, "kw")

    var kw = _b_.dict.$to_obj($.kw)
    for(var key in $defaults){
        if(! kw.hasOwnProperty(key)){
            kw[key] = $defaults[key]
        }
    }

    var indent = kw.indent,
        ensure_ascii = kw.ensure_ascii,
        separators = kw.separators === _b_.None ?
             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :
            kw.separators,
        skipkeys = kw.skipkeys,
        _default = kw.default,
        sort_keys = kw.sort_keys,
        allow_nan = kw.allow_nan,
        check_circular = kw.check_circular

    var item_separator = separators[0],
        key_separator = separators[1]
    if(indent !== _b_.None){
        var indent_str
        if(typeof indent == "string"){
            indent_str = indent
        }else if(typeof indent == "number" && indent >= 1){
            indent_str = " ".repeat(indent)
        }else{
            throw _b_.ValueError.$factory("invalid indent: " +
                _b_.str.$factory(indent))
        }
    }
    var kwarg = {$kw: [{}]}
    for(var key in kw){
        kwarg.$kw[0][key] = kw[key]
    }

    switch(typeof obj){
        case 'string':
            var res = JSON.stringify(obj)
            if(ensure_ascii){
                var escaped = ''
                for(var i = 0, len = res.length; i < len; i++){
                    var u = res.codePointAt(i)
                    if(u > 127){
                        u = u.toString(16)
                        while(u.length < 4){
                            u = "0" + u
                        }
                        escaped += '\\u' + u
                    }else{
                        escaped += res.charAt(i)
                    }
                }
                return escaped
            }
            return res
        case 'boolean':
            return obj.toString()
        case 'number':
            if([Infinity, -Infinity].indexOf(obj) > -1 ||
                    isNaN(obj)){
                if(! allow_nan){
                    throw _b_.ValueError.$factory(
                        'Out of range float values are not JSON compliant')
                }
            }
            return obj.toString()
    }
    if(obj instanceof String){
        if(! ensure_ascii){
            return $B.String(obj)
        }
        // string with surrogate pairs. cf. issue #1903.
        var res = ''
        if(obj.surrogates){
            var s_ix = 0,
                s_pos = obj.surrogates[s_ix]
            for(var i = 0, len = obj.length; i < len; i++){
                if(i == s_pos){
                    var code = obj.codePointAt(i) - 0x10000
                    res += '\\u' + (0xD800 | (code >> 10)).toString(16) +
                           '\\u' + (0xDC00 | (code & 0x3FF)).toString(16)
                    i++
                    s_ix++
                    s_pos = obj.surrogates[s_ix]
                }else{
                    var code = obj.charCodeAt(i)
                    if(code < 127){
                        var x = _b_.repr(obj[i])
                        res += x.substr(1, x.length - 2)
                    }else{
                        var x = code.toString(16)
                        while(x.length < 4){
                            x = '0' + x
                        }
                        res += '\\u' + x
                    }
                }
            }
        }
        return '"' + res.replace(new RegExp('"', "g"), '\\"') + '"'
    }

    if($B.$isinstance(obj, _b_.list)){
        var res = []
        var sep = item_separator,
            first = '[',
            last = ']'
        if(indent !== _b_.None){
            sep += "\n" + indent_str.repeat(level)
            first = '[' + '\n' + indent_str.repeat(level)
            last = '\n' + indent_str.repeat(level - 1) + ']'
            level++
        }
        for(var i = 0, len = obj.length; i < len; i++){
            res.push(to_json(obj[i], level, kwarg))
        }
        return first + res.join(sep) + last
    }else if($B.$isinstance(obj, _b_.float)){
        return obj.value
    }else if(obj.__class__ === $B.long_int){
        return obj.value.toString()
    }else if(obj === _b_.None){
        return "null"
    }else if($B.$isinstance(obj, _b_.dict)){
        var res = [],
            items = Array.from($B.make_js_iterator(_b_.dict.items(obj)))
        if(sort_keys){
            // Sort keys by alphabetical order
            items.sort()
        }
        var sep = item_separator,
            first = '{',
            last = '}'
        if(indent !== _b_.None){
            sep += "\n" + indent_str.repeat(level)
            first = '{' + '\n' + indent_str.repeat(level)
            last = '\n' + indent_str.repeat(level - 1) + '}'
            level++
        }
        for(var i = 0, len = items.length; i < len; i++){
            var item = items[i]
            if(! simple(item[0])){
                if(! skipkeys){
                    throw _b_.TypeError.$factory("keys must be str, int, " +
                        "float, bool or None, not " + $B.class_name(obj))
                }
            }else{
                // In the result, key must be a string
                var key = _b_.str.$factory(item[0])
                // Check circular reference
                if(check_circular && $B.repr.enter(item[1])){
                    throw _b_.ValueError.$factory("Circular reference detected")
                }
                res.push(
                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].
                    join(key_separator))
                if(check_circular){
                    $B.repr.leave(item[1])
                }
            }
        }
        return first + res.join(sep) + last
    }
    // For other types, use function default if provided
    if(_default == _b_.None){
        throw _b_.TypeError.$factory("Object of type " + $B.class_name(obj) +
            " is not JSON serializable")
    }else{
        return to_json($B.$call(_default)(obj), level, kwarg)
    }
}

function loads(s){
    var args = []
    for(var i = 1, len = arguments.length; i < len; i++){
        args.push(arguments[i])
    }
    var decoder = JSONDecoder.$factory.apply(null, args)
    return JSONDecoder.decode(decoder, s)
}

function to_py(obj, kw){
    // Conversion to Python objects
    // kw are the keyword arguments to loads()
    var res
    if(obj instanceof List){
        return obj.items.map(x => to_py(x, kw))
    }else if(obj instanceof Dict){
        if(kw.object_pairs_hook !== _b_.None){
            var pairs = []
            for(var i = 0, len = obj.keys.length; i < len; i++){
                pairs.push($B.fast_tuple([obj.keys[i],
                    to_py(obj.values[i], kw)]))
            }
            return $B.$call(kw.object_pairs_hook)(pairs)
        }else{
            var dict = $B.empty_dict()
            for(var i = 0, len = obj.keys.length; i < len; i++){
                _b_.dict.$setitem(dict, obj.keys[i], to_py(obj.values[i], kw))
            }
            return kw.object_hook === _b_.None ? dict :
                $B.$call(kw.object_hook)(dict)
        }
    }else if(obj.type == 'str'){
        return obj.value
    }else if(obj.type == 'num'){
        if(obj.value.search(/[.eE]/) > -1){
            // float
            if(kw.parse_float !== _b_.None){
                return $B.$call(kw.parse_float)(obj.value)
            }
            return $B.fast_float(parseFloat(obj.value))
        }else{
            // integer
            if(kw.parse_int !== _b_.None){
                return $B.$call(kw.parse_int)(obj.value)
            }
            var int = parseInt(obj.value)
            if(Math.abs(int) < $B.max_int){
                return int
            }else{
                return $B.fast_long_int(BigInt(obj.value))
            }
        }
    }else{
        if(obj instanceof Number && kw.parse_float !== _b_.None){
            return $B.$call(kw.parse_float)(obj)
        }else if(kw.parse_int !== _b_.None &&
                (typeof obj == 'number' || obj.__class__ === $B.long_int)){
            return $B.$call(kw.parse_int)(obj)
        }else if(kw.parse_constant !== _b_.None && ! isFinite(obj)){
            return kw.parse_constant(obj)
        }
        return obj
    }
}

var escapes = {'n': '\n',
               't': '\t',
               'b': '\b',
               'r': '\r',
               'f': '\f',
               '\\': '\\',
               '"': '\"',
               "'": "\\'",
               '/': '/'
               }

function string_at(s, i){
    var error = $B.$call($B.imported["json"].JSONDecodeError)

    var j = i + 1,
        escaped = false,
        len = s.length,
        value = ''
    while(j < len){
        if(s[j] == '"' && ! escaped){
            return [{type: 'str', value}, j + 1]
        }else if(! escaped && s[j] == '\\'){
            escaped = ! escaped
            j++
        }else if(escaped){
            var esc = escapes[s[j]]
            if(esc){
                value += esc
                j++
                escaped = false
            }else if(s[j] == 'u' &&
                    s.substr(j + 1, 4).match(/[0-9a-fA-f]{4}/)){
                // unicode escape
                value += String.fromCharCode(parseInt(s.substr(j + 1, 4), 16))
                j += 5
                escaped = ! escaped
            }else{
                throw error('invalid escape "' + s[j] + '"', s, j)
            }
        }else{
            value += s[j]
            j++
        }
    }
}

function to_num(num_string, nb_dots, exp){
    // convert to correct Brython type
    if(exp || nb_dots){
        return new Number(num_string)
    }else{
        var int = parseInt(num_string)
        if(Math.abs(int) < $B.max_int){
            return int
        }else{
            if(num_string.startsWith('-')){
                return $B.fast_long_int(num_string.substr(1), false)
            }else{
                return $B.fast_long_int(num_string, true)
            }
        }
    }
}

function num_at(s, i){
  var res = s[i],
      j = i + 1,
      nb_dots = 0,
      exp = false,
      len = s.length
  while(j < len){
      if(s[j].match(/\d/)){
        j++
      }else if(s[j] == '.' && nb_dots == 0){
        nb_dots++
        j++
      }else if('eE'.indexOf(s[j]) > -1 && ! exp){
        exp = ! exp
        j++
      }else if(s[j] == '-' && 'eE'.includes(s[j-1])){
        j++
      }else{
        return [{type: 'num', value: s.substring(i, j)}, j]
      }
  }
  return [{type: 'num', value: s.substring(i, j)}, j]
}

var JSONError = $B.make_class('json.decoder.JSONError')
JSONError.__bases__ = [_b_.Exception]
JSONError.__mro__ = _b_.type.mro(JSONError)
function* tokenize(s){
  var i = 0,
      len = s.length,
      line_num = 1,
      column_start = 0,
      value,
      end
  while(i < len){
    if(s[i] == " " || s[i] == '\r' || s[i] == '\n' || s[i] == '\t'){
      i++
      line_num++
      column_start = i
    }else if('[]{}:,'.indexOf(s[i]) > -1){
      yield [s[i], i]
      i++
    }else if(s.substr(i, 4) == 'null'){
      yield [_b_.None , i]
      i += 4
    }else if(s.substr(i, 4) == 'true'){
      yield [true, i]
      i += 4
    }else if(s.substr(i, 5) == 'false'){
      yield [false, i]
      i += 5
    }else if(s.substr(i, 8) == 'Infinity'){
      yield [{type: 'num', value: 'Infinity'}, i]
      i += 8
    }else if(s.substr(i, 9) == '-Infinity'){
      yield [{type: 'num', value: '-Infinity'}, i]
      i += 9
    }else if(s.substr(i, 3) == 'NaN'){
      yield [{type: 'num', value: 'NaN'}, i]
      i += 3
    }else if(s[i] == '"'){
      value = string_at(s, i)
      yield value
      i = value[1]
    }else if(s[i].match(/\d/) || s[i] == '-'){
      value = num_at(s, i)
      yield value
      i = value[1]
    }else{
      throw $B.$call(JSONError)('Extra data: ' +
          `line ${line_num} column ${1 + i - column_start}`)
    }
  }
}

function Node(parent){
    this.parent = parent
    if(parent instanceof List){
        this.list = parent.items
    }else if(parent instanceof Dict){
        this.list = parent.values
    }else if(parent === undefined){
        this.list = []
    }
}

Node.prototype.transition = function(token){
    if([true, false, _b_.None].includes(token) ||
            ['str', 'num'].includes(token.type)){
        if(this.parent === undefined &&
                (this.list.length > 0 || this.content)){
            throw Error('Extra data')
        }
        this.list.push(token)
        return this.parent ? this.parent : this
    }else if(token == '{'){
        if(this.parent === undefined){
          this.content = new Dict(this)
          return this.content
        }
        return new Dict(this.parent)
    }else if(token == '['){
        if(this.parent === undefined){
            this.content = new List(this)
            return this.content
        }
        return new List(this.parent)
    }else{
        throw Error('unexpected item:' + token)
    }
}

function Dict(parent){
    this.parent = parent
    this.keys = []
    this.values = []
    this.expect = 'key'
    if(parent instanceof List){
        parent.items.push(this)
    }else if(parent instanceof Dict){
        parent.values.push(this)
    }
}

Dict.prototype.transition = function(token){
    if(this.expect == 'key'){
        if(token.type == 'str'){
            this.keys.push(token.value)
            this.expect = ':'
            return this
        }else if(token == '}' && this.keys.length == 0){
            return this.parent
        }else{
            throw Error('expected str')
        }
    }else if(this.expect == ':'){
        if(token == ':'){
          this.expect = '}'
          return new Node(this)
        }else{
          throw Error('expected :')
        }
    }else if(this.expect == '}'){
        if(token == '}'){
            return this.parent
        }else if(token == ','){
            this.expect = 'key'
            return this
        }
        throw Error('expected }')
    }
}

function List(parent){
    if(parent instanceof List){
        parent.items.push(this)
    }
    this.parent = parent
    this.items = []
    this.expect = 'item'
}

List.prototype.transition = function(token){
    if(this.expect == 'item'){
        this.expect = ','
        if([true, false, _b_.None].indexOf(token) > -1){
            this.items.push(token)
            return this
        }else if(token.type == 'num' || token.type == 'str'){
            this.items.push(token)
            return this
        }else if(token == '{'){
            return new Dict(this)
        }else if(token == '['){
            return new List(this)
        }else if(token == ']'){
            if(this.items.length == 0){
                if(this.parent instanceof Dict){
                    this.parent.values.push(this)
                }
                return this.parent
            }
            throw Error('unexpected ]')
        }else{
            console.log('token', token)
            throw Error('unexpected item:' + token)
        }

    }else if(this.expect == ','){
        this.expect = 'item'
        if(token == ','){
          return this
        }else if(token == ']'){
          if(this.parent instanceof Dict){
              this.parent.values.push(this)
          }
          return this.parent
        }else{
          throw Error('expected :')
        }
    }
}

function parse(s){
  var res,
      state,
      node = new Node(),
      root = node,
      token
  for(var item of tokenize(s)){
      token = item[0]
      try{
          node = node.transition(token)
      }catch(err){
          console.log('error, item', item)
          console.log(err, err.message)
          console.log('node', node)
          if(err.__class__){
              throw err
          }else{
              var error = $B.$call($B.imported["json"].JSONDecodeError)
              throw error(err.message, s, item[1])
          }
      }
  }
  return root.content ? root.content : root.list[0]
}

var JSONDecoder = $B.make_class("JSONDecoder",
    function(){
        var $defaults = {cls: _b_.None, object_hook: _b_.None,
                parse_float: _b_.None, parse_int: _b_.None,
                parse_constant: _b_.None, object_pairs_hook: _b_.None},
            $ = $B.args("decode", 0, {}, [], arguments, {}, null, "kw")
        var kw = _b_.dict.$to_obj($.kw)
        for(var key in $defaults){
            if(kw[key] === undefined){
                kw[key] = $defaults[key]
            }
        }
        return {
            __class__: JSONDecoder,
            object_hook: kw.object_hook,
            parse_float: kw.parse_float,
            parse_int: kw.parse_int,
            parse_constant: kw.parse_constant,
            object_pairs_hook: kw.object_pairs_hook,
            memo: $B.empty_dict()
        }
    }
)

JSONDecoder.decode = function(self, s){
    return to_py(parse(s), self)
}

$B.imported._json = {
    dumps: function(){
        return _b_.str.$factory(to_json.apply(null, arguments))
    },
    loads,
    JSONDecoder
}

})(__BRYTHON__)====_json.js(file) end====

====_py_abc.py(module) start====
from _weakrefset import WeakSet
def get_cache_token():
 ''
 return ABCMeta._abc_invalidation_counter
class ABCMeta(type):
 ''
 _abc_invalidation_counter=0
 def __new__(mcls,name,bases,namespace,/,**kwargs):
  cls=super().__new__(mcls,name,bases,namespace,**kwargs)
  abstracts={name
  for name,value in namespace.items()
  if getattr(value,"__isabstractmethod__",False)}
  for base in bases:
   for name in getattr(base,"__abstractmethods__",set()):
    value=getattr(cls,name,None)
    if getattr(value,"__isabstractmethod__",False):
     abstracts.add(name)
  cls.__abstractmethods__=frozenset(abstracts)
  cls._abc_registry=WeakSet()
  cls._abc_cache=WeakSet()
  cls._abc_negative_cache=WeakSet()
  cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter
  return cls
 def register(cls,subclass):
  ''
  if not isinstance(subclass,type):
   raise TypeError("Can only register classes")
  if issubclass(subclass,cls):
   return subclass
  if issubclass(cls,subclass):
   raise RuntimeError("Refusing to create an inheritance cycle")
  cls._abc_registry.add(subclass)
  ABCMeta._abc_invalidation_counter +=1
  return subclass
 def _dump_registry(cls,file=None):
  ''
  print(f"Class: {cls.__module__}.{cls.__qualname__}",file=file)
  print(f"Inv. counter: {get_cache_token()}",file=file)
  for name in cls.__dict__:
   if name.startswith("_abc_"):
    value=getattr(cls,name)
    if isinstance(value,WeakSet):
     value=set(value)
    print(f"{name}: {value !r}",file=file)
 def _abc_registry_clear(cls):
  ''
  cls._abc_registry.clear()
 def _abc_caches_clear(cls):
  ''
  cls._abc_cache.clear()
  cls._abc_negative_cache.clear()
 def __instancecheck__(cls,instance):
  ''
  subclass=instance.__class__
  if subclass in cls._abc_cache:
   return True
  subtype=type(instance)
  if subtype is subclass:
   if(cls._abc_negative_cache_version ==
   ABCMeta._abc_invalidation_counter and
   subclass in cls._abc_negative_cache):
    return False
   return cls.__subclasscheck__(subclass)
  return any(cls.__subclasscheck__(c)for c in(subclass,subtype))
 def __subclasscheck__(cls,subclass):
  ''
  if not isinstance(subclass,type):
   raise TypeError('issubclass() arg 1 must be a class')
  if subclass in cls._abc_cache:
   return True
  if cls._abc_negative_cache_version <ABCMeta._abc_invalidation_counter:
   cls._abc_negative_cache=WeakSet()
   cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter
  elif subclass in cls._abc_negative_cache:
   return False
  ok=cls.__subclasshook__(subclass)
  if ok is not NotImplemented:
   assert isinstance(ok,bool)
   if ok:
    cls._abc_cache.add(subclass)
   else:
    cls._abc_negative_cache.add(subclass)
   return ok
  if cls in getattr(subclass,'__mro__',()):
   cls._abc_cache.add(subclass)
   return True
  for rcls in cls._abc_registry:
   if issubclass(subclass,rcls):
    cls._abc_cache.add(subclass)
    return True
  for scls in cls.__subclasses__():
   if issubclass(subclass,scls):
    cls._abc_cache.add(subclass)
    return True
  cls._abc_negative_cache.add(subclass)
  return False
====_py_abc.py(module) end====

====_thread.py(module) start====
''
__all__=['error','start_new_thread','exit','get_ident','allocate_lock',
'interrupt_main','LockType']
TIMEOUT_MAX=2 **31
error=RuntimeError

def daemon_threads_allowed():
 return False
def _set_sentinel(*args,**kw):
 return LockType()
def start_new_thread(function,args,kwargs={}):
 ''
 if type(args)!=type(tuple()):
  raise TypeError("2nd arg must be a tuple")
 if type(kwargs)!=type(dict()):
  raise TypeError("3rd arg must be a dict")
 global _main
 _main=False
 try:
  function(*args,**kwargs)
 except SystemExit:
  pass
 except:
  import traceback
  traceback.print_exc()
 _main=True
 global _interrupt
 if _interrupt:
  _interrupt=False
  raise KeyboardInterrupt
def exit():
 ''
 raise SystemExit
def get_ident():
 ''
 return -1
def allocate_lock():
 ''
 return LockType()
def stack_size(size=None):
 ''
 if size is not None:
  raise error("setting thread stack size not supported")
 return 0
class LockType(object):
 ''
 def __init__(self):
  self.locked_status=False
 def acquire(self,waitflag=None,timeout=-1):
  ''
  if waitflag is None or waitflag:
   self.locked_status=True
   return True
  else:
   if not self.locked_status:
    self.locked_status=True
    return True
   else:
    if timeout >0:
     import time
     time.sleep(timeout)
    return False
 __enter__=acquire
 def __exit__(self,typ,val,tb):
  self.release()
 def release(self):
  ''
  self.locked_status=False
  return True
 def locked(self):
  return self.locked_status
_interrupt=False

_main=True

def interrupt_main():
 ''
 if _main:
  raise KeyboardInterrupt
 else:
  global _interrupt
  _interrupt=True
class _local:
 pass
RLock=LockType
====_thread.py(module) end====

====_weakref.py(module) start====


class ProxyType:

 def __init__(self,obj):
  object.__setattr__(self,"obj",obj)
 def __setattr__(self,attr,value):
  setattr(object.__getattribute__(self,"obj"),attr,value)
 def __getattr__(self,attr):
  return getattr(object.__getattribute__(self,"obj"),attr)
CallableProxyType=ProxyType
ProxyTypes=[ProxyType,CallableProxyType]

class ReferenceType:

 def __init__(self,obj,callback):
  self.obj=obj
  self.callback=callback
class ref:

 def __new__(cls,*args,**kw):
  return object.__new__(cls)
 def __init__(self,obj,callback=None):
  self.obj=ReferenceType(obj,callback)
  self.callback=callback
 def __call__(self):
  return self.obj.obj
 def __hash__(self):
  return hash(self.obj.obj)
 def __eq__(self,other):
  return self.obj.obj ==other.obj.obj
def getweakrefcount(obj):
 return 1
def getweakrefs(obj):
 return obj
def _remove_dead_weakref(*args):
 pass
def proxy(obj,callback=None):
 return ProxyType(obj)
====_weakref.py(module) end====

====_weakrefset.py(module) start====

from _weakref import ref
from types import GenericAlias

__all__=['WeakSet']
class _IterationGuard:
 def __init__(self,weakcontainer):
  self.weakcontainer=ref(weakcontainer)
 def __enter__(self):
  w=self.weakcontainer()
  if w is not None:
   w._iterating.add(self)
  return self
 def __exit__(self,e,t,b):
  w=self.weakcontainer()
  if w is not None:
   s=w._iterating
   s.remove(self)
   if not s:
    w._commit_removals()
class WeakSet:
 def __init__(self,data=None):
  self.data=set()
  def _remove(item,selfref=ref(self)):
   self=selfref()
   if self is not None:
    if self._iterating:
     self._pending_removals.append(item)
    else:
     self.data.discard(item)
  self._remove=_remove
  self._pending_removals=[]
  self._iterating=set()
  if data is not None:
   self.update(data)
 def _commit_removals(self):
  pop=self._pending_removals.pop
  discard=self.data.discard
  while True:
   try:
    item=pop()
   except IndexError:
    return
   discard(item)
 def __iter__(self):
  with _IterationGuard(self):
   for itemref in self.data:
    item=itemref()
    if item is not None:
     yield item
 def __len__(self):
  return len(self.data)-len(self._pending_removals)
 def __contains__(self,item):
  try:
   wr=ref(item)
  except TypeError:
   return False
  return wr in self.data
 def __reduce__(self):
  return self.__class__,(list(self),),self.__getstate__()
 def add(self,item):
  if self._pending_removals:
   self._commit_removals()
  self.data.add(ref(item,self._remove))
 def clear(self):
  if self._pending_removals:
   self._commit_removals()
  self.data.clear()
 def copy(self):
  return self.__class__(self)
 def pop(self):
  if self._pending_removals:
   self._commit_removals()
  while True:
   try:
    itemref=self.data.pop()
   except KeyError:
    raise KeyError('pop from empty WeakSet')from None
   item=itemref()
   if item is not None:
    return item
 def remove(self,item):
  if self._pending_removals:
   self._commit_removals()
  self.data.remove(ref(item))
 def discard(self,item):
  if self._pending_removals:
   self._commit_removals()
  self.data.discard(ref(item))
 def update(self,other):
  if self._pending_removals:
   self._commit_removals()
  for element in other:
   self.add(element)
 def __ior__(self,other):
  self.update(other)
  return self
 def difference(self,other):
  newset=self.copy()
  newset.difference_update(other)
  return newset
 __sub__=difference
 def difference_update(self,other):
  self.__isub__(other)
 def __isub__(self,other):
  if self._pending_removals:
   self._commit_removals()
  if self is other:
   self.data.clear()
  else:
   self.data.difference_update(ref(item)for item in other)
  return self
 def intersection(self,other):
  return self.__class__(item for item in other if item in self)
 __and__=intersection
 def intersection_update(self,other):
  self.__iand__(other)
 def __iand__(self,other):
  if self._pending_removals:
   self._commit_removals()
  self.data.intersection_update(ref(item)for item in other)
  return self
 def issubset(self,other):
  return self.data.issubset(ref(item)for item in other)
 __le__=issubset
 def __lt__(self,other):
  return self.data <set(map(ref,other))
 def issuperset(self,other):
  return self.data.issuperset(ref(item)for item in other)
 __ge__=issuperset
 def __gt__(self,other):
  return self.data >set(map(ref,other))
 def __eq__(self,other):
  if not isinstance(other,self.__class__):
   return NotImplemented
  return self.data ==set(map(ref,other))
 def symmetric_difference(self,other):
  newset=self.copy()
  newset.symmetric_difference_update(other)
  return newset
 __xor__=symmetric_difference
 def symmetric_difference_update(self,other):
  self.__ixor__(other)
 def __ixor__(self,other):
  if self._pending_removals:
   self._commit_removals()
  if self is other:
   self.data.clear()
  else:
   self.data.symmetric_difference_update(ref(item,self._remove)for item in other)
  return self
 def union(self,other):
  return self.__class__(e for s in(self,other)for e in s)
 __or__=union
 def isdisjoint(self,other):
  return len(self.intersection(other))==0
 def __repr__(self):
  return repr(self.data)
 __class_getitem__=classmethod(GenericAlias)
====_weakrefset.py(module) end====

====abc.py(module) start====

def abstractmethod(funcobj):
 ''
 funcobj.__isabstractmethod__=True
 return funcobj
class abstractclassmethod(classmethod):
 ''
 __isabstractmethod__=True
 def __init__(self,callable):
  callable.__isabstractmethod__=True
  super().__init__(callable)
class abstractstaticmethod(staticmethod):
 ''
 __isabstractmethod__=True
 def __init__(self,callable):
  callable.__isabstractmethod__=True
  super().__init__(callable)
class abstractproperty(property):
 ''
 __isabstractmethod__=True
try:
 from _abc import(get_cache_token,_abc_init,_abc_register,
 _abc_instancecheck,_abc_subclasscheck,_get_dump,
 _reset_registry,_reset_caches)
except ImportError:
 from _py_abc import ABCMeta,get_cache_token
 ABCMeta.__module__='abc'
else:
 class ABCMeta(type):
  ''
  def __new__(mcls,name,bases,namespace,/,**kwargs):
   cls=super().__new__(mcls,name,bases,namespace,**kwargs)
   _abc_init(cls)
   return cls
  def register(cls,subclass):
   ''
   return _abc_register(cls,subclass)
  def __instancecheck__(cls,instance):
   ''
   return _abc_instancecheck(cls,instance)
  def __subclasscheck__(cls,subclass):
   ''
   return _abc_subclasscheck(cls,subclass)
  def _dump_registry(cls,file=None):
   ''
   print(f"Class: {cls.__module__}.{cls.__qualname__}",file=file)
   print(f"Inv. counter: {get_cache_token()}",file=file)
   (_abc_registry,_abc_cache,_abc_negative_cache,
   _abc_negative_cache_version)=_get_dump(cls)
   print(f"_abc_registry: {_abc_registry !r}",file=file)
   print(f"_abc_cache: {_abc_cache !r}",file=file)
   print(f"_abc_negative_cache: {_abc_negative_cache !r}",file=file)
   print(f"_abc_negative_cache_version: {_abc_negative_cache_version !r}",
   file=file)
  def _abc_registry_clear(cls):
   ''
   _reset_registry(cls)
  def _abc_caches_clear(cls):
   ''
   _reset_caches(cls)
def update_abstractmethods(cls):
 ''
 if not hasattr(cls,'__abstractmethods__'):
  return cls
 abstracts=set()
 for scls in cls.__bases__:
  for name in getattr(scls,'__abstractmethods__',()):
   value=getattr(cls,name,None)
   if getattr(value,"__isabstractmethod__",False):
    abstracts.add(name)
 for name,value in cls.__dict__.items():
  if getattr(value,"__isabstractmethod__",False):
   abstracts.add(name)
 cls.__abstractmethods__=frozenset(abstracts)
 return cls
class ABC(metaclass=ABCMeta):
 ''
 __slots__=()
====abc.py(module) end====

====browser.ajax.py(module) start====
from _ajax import *
====browser.ajax.py(module) end====

====builtins.js(file) start====
(function(){
    var obj = {},
        builtin_names = ['ArithmeticError', 'AssertionError',
            'AttributeError', 'BaseException', 'BaseExceptionGroup',
            'BlockingIOError', 'BrokenPipeError', 'BufferError',
            'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',
            'ConnectionError', 'ConnectionRefusedError',
            'ConnectionResetError', 'DeprecationWarning', 'EOFError',
            'Ellipsis', 'EncodingWarning', 'EnvironmentError', 'Exception',
            'ExceptionGroup', 'False', 'FileExistsError', 'FileNotFoundError',
            'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',
            'ImportError', 'ImportWarning', 'IndentationError', 'IndexError',
            'InterruptedError', 'IsADirectoryError', 'KeyError',
            'KeyboardInterrupt', 'LookupError', 'MemoryError',
            'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError',
            'NotImplemented', 'NotImplementedError', 'OSError',
            'OverflowError', 'PendingDeprecationWarning', 'PermissionError',
            'ProcessLookupError', 'RecursionError', 'ReferenceError',
            'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
            'StopAsyncIteration', 'StopIteration', 'SyntaxError',
            'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
            'TimeoutError', 'True', 'TypeError', 'UnboundLocalError',
            'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',
            'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
            'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError',
            '_', '__build_class__', '__debug__', '__import__',
            'abs', 'aiter', 'all', 'anext', 'any', 'ascii', 'bin', 'bool',
            'breakpoint', 'bytearray', 'bytes', 'callable', 'chr',
            'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir',
            'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float',
            'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash',
            'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
            'iter', 'len', 'list', 'locals', 'map', 'max', 'memoryview',
            'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print',
            'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set',
            'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum',
            'super', 'tuple', 'type', 'vars', 'zip']
    for(var key of builtin_names){
        if(__BRYTHON__.builtins[key] !== undefined){
            obj[key] = __BRYTHON__.builtins[key]
        }
    }
    obj.__doc__ = 'builtins module'
    obj.copyright = 'CPython copyright'
    obj.credits = 'CPython builtins credits'
    obj.license = 'CPython license'
    $B.addToImported('builtins', obj)
})()
====builtins.js(file) end====

====codecs.py(module) start====
''
import builtins
import sys
try:
 from _codecs import *
except ImportError as why:
 raise SystemError('Failed to load the builtin codecs: %s'%why)
__all__=["register","lookup","open","EncodedFile","BOM","BOM_BE",
"BOM_LE","BOM32_BE","BOM32_LE","BOM64_BE","BOM64_LE",
"BOM_UTF8","BOM_UTF16","BOM_UTF16_LE","BOM_UTF16_BE",
"BOM_UTF32","BOM_UTF32_LE","BOM_UTF32_BE",
"CodecInfo","Codec","IncrementalEncoder","IncrementalDecoder",
"StreamReader","StreamWriter",
"StreamReaderWriter","StreamRecoder",
"getencoder","getdecoder","getincrementalencoder",
"getincrementaldecoder","getreader","getwriter",
"encode","decode","iterencode","iterdecode",
"strict_errors","ignore_errors","replace_errors",
"xmlcharrefreplace_errors",
"backslashreplace_errors","namereplace_errors",
"register_error","lookup_error"]
BOM_UTF8=b'\xef\xbb\xbf'
BOM_LE=BOM_UTF16_LE=b'\xff\xfe'
BOM_BE=BOM_UTF16_BE=b'\xfe\xff'
BOM_UTF32_LE=b'\xff\xfe\x00\x00'
BOM_UTF32_BE=b'\x00\x00\xfe\xff'

if sys.byteorder =='little':
 BOM=BOM_UTF16=BOM_UTF16_LE
 BOM_UTF32=BOM_UTF32_LE
else:
 BOM=BOM_UTF16=BOM_UTF16_BE
 BOM_UTF32=BOM_UTF32_BE
BOM32_LE=BOM_UTF16_LE
BOM32_BE=BOM_UTF16_BE
BOM64_LE=BOM_UTF32_LE
BOM64_BE=BOM_UTF32_BE
class CodecInfo(tuple):
 ''
 _is_text_encoding=True
 def __new__(cls,encode,decode,streamreader=None,streamwriter=None,
 incrementalencoder=None,incrementaldecoder=None,name=None,
 *,_is_text_encoding=None):
  self=tuple.__new__(cls,(encode,decode,streamreader,streamwriter))
  self.name=name
  self.encode=encode
  self.decode=decode
  self.incrementalencoder=incrementalencoder
  self.incrementaldecoder=incrementaldecoder
  self.streamwriter=streamwriter
  self.streamreader=streamreader
  if _is_text_encoding is not None:
   self._is_text_encoding=_is_text_encoding
  return self
 def __repr__(self):
  return "<%s.%s object for encoding %s at %#x>"%\
  (self.__class__.__module__,self.__class__.__qualname__,
  self.name,id(self))
class Codec:

 ''
 def encode(self,input,errors='strict'):
  ''
  raise NotImplementedError
 def decode(self,input,errors='strict'):
  ''
  raise NotImplementedError
class IncrementalEncoder(object):
 ''
 def __init__(self,errors='strict'):
  ''
  self.errors=errors
  self.buffer=""
 def encode(self,input,final=False):
  ''
  raise NotImplementedError
 def reset(self):
  ''
 def getstate(self):
  ''
  return 0
 def setstate(self,state):
  ''
class BufferedIncrementalEncoder(IncrementalEncoder):
 ''
 def __init__(self,errors='strict'):
  IncrementalEncoder.__init__(self,errors)
  self.buffer=""
 def _buffer_encode(self,input,errors,final):
  raise NotImplementedError
 def encode(self,input,final=False):
  data=self.buffer+input
  (result,consumed)=self._buffer_encode(data,self.errors,final)
  self.buffer=data[consumed:]
  return result
 def reset(self):
  IncrementalEncoder.reset(self)
  self.buffer=""
 def getstate(self):
  return self.buffer or 0
 def setstate(self,state):
  self.buffer=state or ""
class IncrementalDecoder(object):
 ''
 def __init__(self,errors='strict'):
  ''
  self.errors=errors
 def decode(self,input,final=False):
  ''
  raise NotImplementedError
 def reset(self):
  ''
 def getstate(self):
  ''
  return(b"",0)
 def setstate(self,state):
  ''
class BufferedIncrementalDecoder(IncrementalDecoder):
 ''
 def __init__(self,errors='strict'):
  IncrementalDecoder.__init__(self,errors)
  self.buffer=b""
 def _buffer_decode(self,input,errors,final):
  raise NotImplementedError
 def decode(self,input,final=False):
  data=self.buffer+input
  (result,consumed)=self._buffer_decode(data,self.errors,final)
  self.buffer=data[consumed:]
  return result
 def reset(self):
  IncrementalDecoder.reset(self)
  self.buffer=b""
 def getstate(self):
  return(self.buffer,0)
 def setstate(self,state):
  self.buffer=state[0]
class StreamWriter(Codec):

 def __init__(self,stream,errors='strict'):
  ''
  self.stream=stream
  self.errors=errors
 def write(self,object):
  ''
  data,consumed=self.encode(object,self.errors)
  self.stream.write(data)
 def writelines(self,list):
  ''
  self.write(''.join(list))
 def reset(self):
  ''
  pass
 def seek(self,offset,whence=0):
  self.stream.seek(offset,whence)
  if whence ==0 and offset ==0:
   self.reset()
 def __getattr__(self,name,
 getattr=getattr):
  ''
  return getattr(self.stream,name)
 def __enter__(self):
  return self
 def __exit__(self,type,value,tb):
  self.stream.close()
class StreamReader(Codec):

 charbuffertype=str
 def __init__(self,stream,errors='strict'):
  ''
  self.stream=stream
  self.errors=errors
  self.bytebuffer=b""
  self._empty_charbuffer=self.charbuffertype()
  self.charbuffer=self._empty_charbuffer
  self.linebuffer=None
 def decode(self,input,errors='strict'):
  raise NotImplementedError
 def read(self,size=-1,chars=-1,firstline=False):
  ''
  if self.linebuffer:
   self.charbuffer=self._empty_charbuffer.join(self.linebuffer)
   self.linebuffer=None
  if chars <0:
   chars=size
  while True:
   if chars >=0:
    if len(self.charbuffer)>=chars:
     break
   if size <0:
    newdata=self.stream.read()
   else:
    newdata=self.stream.read(size)
   data=self.bytebuffer+newdata
   if not data:
    break
   try:
    newchars,decodedbytes=self.decode(data,self.errors)
   except UnicodeDecodeError as exc:
    if firstline:
     newchars,decodedbytes=\
     self.decode(data[:exc.start],self.errors)
     lines=newchars.splitlines(keepends=True)
     if len(lines)<=1:
      raise
    else:
     raise
   self.bytebuffer=data[decodedbytes:]
   self.charbuffer +=newchars
   if not newdata:
    break
  if chars <0:
   result=self.charbuffer
   self.charbuffer=self._empty_charbuffer
  else:
   result=self.charbuffer[:chars]
   self.charbuffer=self.charbuffer[chars:]
  return result
 def readline(self,size=None,keepends=True):
  ''
  if self.linebuffer:
   line=self.linebuffer[0]
   del self.linebuffer[0]
   if len(self.linebuffer)==1:
    self.charbuffer=self.linebuffer[0]
    self.linebuffer=None
   if not keepends:
    line=line.splitlines(keepends=False)[0]
   return line
  readsize=size or 72
  line=self._empty_charbuffer
  while True:
   data=self.read(readsize,firstline=True)
   if data:
    if(isinstance(data,str)and data.endswith("\r"))or\
    (isinstance(data,bytes)and data.endswith(b"\r")):
     data +=self.read(size=1,chars=1)
   line +=data
   lines=line.splitlines(keepends=True)
   if lines:
    if len(lines)>1:
     line=lines[0]
     del lines[0]
     if len(lines)>1:
      lines[-1]+=self.charbuffer
      self.linebuffer=lines
      self.charbuffer=None
     else:
      self.charbuffer=lines[0]+self.charbuffer
     if not keepends:
      line=line.splitlines(keepends=False)[0]
     break
    line0withend=lines[0]
    line0withoutend=lines[0].splitlines(keepends=False)[0]
    if line0withend !=line0withoutend:
     self.charbuffer=self._empty_charbuffer.join(lines[1:])+\
     self.charbuffer
     if keepends:
      line=line0withend
     else:
      line=line0withoutend
     break
   if not data or size is not None:
    if line and not keepends:
     line=line.splitlines(keepends=False)[0]
    break
   if readsize <8000:
    readsize *=2
  return line
 def readlines(self,sizehint=None,keepends=True):
  ''
  data=self.read()
  return data.splitlines(keepends)
 def reset(self):
  ''
  self.bytebuffer=b""
  self.charbuffer=self._empty_charbuffer
  self.linebuffer=None
 def seek(self,offset,whence=0):
  ''
  self.stream.seek(offset,whence)
  self.reset()
 def __next__(self):
  ''
  line=self.readline()
  if line:
   return line
  raise StopIteration
 def __iter__(self):
  return self
 def __getattr__(self,name,
 getattr=getattr):
  ''
  return getattr(self.stream,name)
 def __enter__(self):
  return self
 def __exit__(self,type,value,tb):
  self.stream.close()
class StreamReaderWriter:

 ''
 encoding='unknown'
 def __init__(self,stream,Reader,Writer,errors='strict'):
  ''
  self.stream=stream
  self.reader=Reader(stream,errors)
  self.writer=Writer(stream,errors)
  self.errors=errors
 def read(self,size=-1):
  return self.reader.read(size)
 def readline(self,size=None):
  return self.reader.readline(size)
 def readlines(self,sizehint=None):
  return self.reader.readlines(sizehint)
 def __next__(self):
  ''
  return next(self.reader)
 def __iter__(self):
  return self
 def write(self,data):
  return self.writer.write(data)
 def writelines(self,list):
  return self.writer.writelines(list)
 def reset(self):
  self.reader.reset()
  self.writer.reset()
 def seek(self,offset,whence=0):
  self.stream.seek(offset,whence)
  self.reader.reset()
  if whence ==0 and offset ==0:
   self.writer.reset()
 def __getattr__(self,name,
 getattr=getattr):
  ''
  return getattr(self.stream,name)
 def __enter__(self):
  return self
 def __exit__(self,type,value,tb):
  self.stream.close()
class StreamRecoder:

 ''
 data_encoding='unknown'
 file_encoding='unknown'
 def __init__(self,stream,encode,decode,Reader,Writer,
 errors='strict'):
  ''
  self.stream=stream
  self.encode=encode
  self.decode=decode
  self.reader=Reader(stream,errors)
  self.writer=Writer(stream,errors)
  self.errors=errors
 def read(self,size=-1):
  data=self.reader.read(size)
  data,bytesencoded=self.encode(data,self.errors)
  return data
 def readline(self,size=None):
  if size is None:
   data=self.reader.readline()
  else:
   data=self.reader.readline(size)
  data,bytesencoded=self.encode(data,self.errors)
  return data
 def readlines(self,sizehint=None):
  data=self.reader.read()
  data,bytesencoded=self.encode(data,self.errors)
  return data.splitlines(keepends=True)
 def __next__(self):
  ''
  data=next(self.reader)
  data,bytesencoded=self.encode(data,self.errors)
  return data
 def __iter__(self):
  return self
 def write(self,data):
  data,bytesdecoded=self.decode(data,self.errors)
  return self.writer.write(data)
 def writelines(self,list):
  data=b''.join(list)
  data,bytesdecoded=self.decode(data,self.errors)
  return self.writer.write(data)
 def reset(self):
  self.reader.reset()
  self.writer.reset()
 def seek(self,offset,whence=0):
  self.reader.seek(offset,whence)
  self.writer.seek(offset,whence)
 def __getattr__(self,name,
 getattr=getattr):
  ''
  return getattr(self.stream,name)
 def __enter__(self):
  return self
 def __exit__(self,type,value,tb):
  self.stream.close()
def open(filename,mode='r',encoding=None,errors='strict',buffering=-1):

 ''
 if encoding is not None and\
 'b'not in mode:
  mode=mode+'b'
 file=builtins.open(filename,mode,buffering)
 if encoding is None:
  return file
 try:
  info=lookup(encoding)
  srw=StreamReaderWriter(file,info.streamreader,info.streamwriter,errors)
  srw.encoding=encoding
  return srw
 except:
  file.close()
  raise
def EncodedFile(file,data_encoding,file_encoding=None,errors='strict'):

 ''
 if file_encoding is None:
  file_encoding=data_encoding
 data_info=lookup(data_encoding)
 file_info=lookup(file_encoding)
 sr=StreamRecoder(file,data_info.encode,data_info.decode,
 file_info.streamreader,file_info.streamwriter,errors)
 sr.data_encoding=data_encoding
 sr.file_encoding=file_encoding
 return sr
def getencoder(encoding):

 ''
 return lookup(encoding).encode
def getdecoder(encoding):

 ''
 return lookup(encoding).decode
def getincrementalencoder(encoding):

 ''
 encoder=lookup(encoding).incrementalencoder
 if encoder is None:
  raise LookupError(encoding)
 return encoder
def getincrementaldecoder(encoding):

 ''
 decoder=lookup(encoding).incrementaldecoder
 if decoder is None:
  raise LookupError(encoding)
 return decoder
def getreader(encoding):

 ''
 return lookup(encoding).streamreader
def getwriter(encoding):

 ''
 return lookup(encoding).streamwriter
def iterencode(iterator,encoding,errors='strict',**kwargs):
 ''
 encoder=getincrementalencoder(encoding)(errors,**kwargs)
 for input in iterator:
  output=encoder.encode(input)
  if output:
   yield output
 output=encoder.encode("",True)
 if output:
  yield output
def iterdecode(iterator,encoding,errors='strict',**kwargs):
 ''
 decoder=getincrementaldecoder(encoding)(errors,**kwargs)
 for input in iterator:
  output=decoder.decode(input)
  if output:
   yield output
 output=decoder.decode(b"",True)
 if output:
  yield output
def make_identity_dict(rng):

 ''
 return{i:i for i in rng}
def make_encoding_map(decoding_map):

 ''
 m={}
 for k,v in decoding_map.items():
  if not v in m:
   m[v]=k
  else:
   m[v]=None
 return m
try:
 strict_errors=lookup_error("strict")
 ignore_errors=lookup_error("ignore")
 replace_errors=lookup_error("replace")
 xmlcharrefreplace_errors=lookup_error("xmlcharrefreplace")
 backslashreplace_errors=lookup_error("backslashreplace")
 namereplace_errors=lookup_error("namereplace")
except LookupError:

 strict_errors=None
 ignore_errors=None
 replace_errors=None
 xmlcharrefreplace_errors=None
 backslashreplace_errors=None
 namereplace_errors=None
_false=0
if _false:
 import encodings
====codecs.py(module) end====

====editor.py(file) start====
====editor.py(file) end====

====errno.py(module) start====
''
E2BIG=7

EACCES=13

EADDRINUSE=10048

EADDRNOTAVAIL=10049

EAFNOSUPPORT=10047

EAGAIN=11

EALREADY=10037

EBADF=9

EBADMSG=104

EBUSY=16

ECANCELED=105

ECHILD=10

ECONNABORTED=10053

ECONNREFUSED=10061

ECONNRESET=10054

EDEADLK=36

EDEADLOCK=36

EDESTADDRREQ=10039

EDOM=33

EDQUOT=10069

EEXIST=17

EFAULT=14

EFBIG=27

EHOSTDOWN=10064

EHOSTUNREACH=10065

EIDRM=111

EILSEQ=42

EINPROGRESS=10036

EINTR=4

EINVAL=22

EIO=5

EISCONN=10056

EISDIR=21

ELOOP=10062

EMFILE=24

EMLINK=31

EMSGSIZE=10040

ENAMETOOLONG=38

ENETDOWN=10050

ENETRESET=10052

ENETUNREACH=10051

ENFILE=23

ENOBUFS=10055

ENODATA=120

ENODEV=19

ENOENT=2

ENOEXEC=8

ENOLCK=39

ENOLINK=121

ENOMEM=12

ENOMSG=122

ENOPROTOOPT=10042

ENOSPC=28

ENOSR=124

ENOSTR=125

ENOSYS=40

ENOTCONN=10057

ENOTDIR=20

ENOTEMPTY=41

ENOTRECOVERABLE=127

ENOTSOCK=10038

ENOTSUP=129

ENOTTY=25

ENXIO=6

EOPNOTSUPP=10045

EOVERFLOW=132

EOWNERDEAD=133

EPERM=1

EPFNOSUPPORT=10046

EPIPE=32

EPROTO=134

EPROTONOSUPPORT=10043

EPROTOTYPE=10041

ERANGE=34

EREMOTE=10071

EROFS=30

ESHUTDOWN=10058

ESOCKTNOSUPPORT=10044

ESPIPE=29

ESRCH=3

ESTALE=10070

ETIME=137

ETIMEDOUT=10060

ETOOMANYREFS=10059

ETXTBSY=139

EUSERS=10068

EWOULDBLOCK=10035

EXDEV=18

WSABASEERR=10000

WSAEACCES=10013

WSAEADDRINUSE=10048

WSAEADDRNOTAVAIL=10049

WSAEAFNOSUPPORT=10047

WSAEALREADY=10037

WSAEBADF=10009

WSAECONNABORTED=10053

WSAECONNREFUSED=10061

WSAECONNRESET=10054

WSAEDESTADDRREQ=10039

WSAEDISCON=10101

WSAEDQUOT=10069

WSAEFAULT=10014

WSAEHOSTDOWN=10064

WSAEHOSTUNREACH=10065

WSAEINPROGRESS=10036

WSAEINTR=10004

WSAEINVAL=10022

WSAEISCONN=10056

WSAELOOP=10062

WSAEMFILE=10024

WSAEMSGSIZE=10040

WSAENAMETOOLONG=10063

WSAENETDOWN=10050

WSAENETRESET=10052

WSAENETUNREACH=10051

WSAENOBUFS=10055

WSAENOPROTOOPT=10042

WSAENOTCONN=10057

WSAENOTEMPTY=10066

WSAENOTSOCK=10038

WSAEOPNOTSUPP=10045

WSAEPFNOSUPPORT=10046

WSAEPROCLIM=10067

WSAEPROTONOSUPPORT=10043

WSAEPROTOTYPE=10041

WSAEREMOTE=10071

WSAESHUTDOWN=10058

WSAESOCKTNOSUPPORT=10044

WSAESTALE=10070

WSAETIMEDOUT=10060

WSAETOOMANYREFS=10059

WSAEUSERS=10068

WSAEWOULDBLOCK=10035

WSANOTINITIALISED=10093

WSASYSNOTREADY=10091

WSAVERNOTSUPPORTED=10092

errorcode={v:k for(k,v)in globals().items()if k ==k.upper()}
====errno.py(module) end====

====genericpath.py(module) start====
''
import os
import stat

__all__=['commonprefix','exists','getatime','getctime','getmtime',
'getsize','isdir','isfile','islink','samefile','sameopenfile',
'samestat']
def exists(path):
 ''
 try:
  os.stat(path)
 except(OSError,ValueError):
  return False
 return True
def isfile(path):
 ''
 try:
  st=os.stat(path)
 except(OSError,ValueError):
  return False
 return stat.S_ISREG(st.st_mode)
def isdir(s):
 ''
 try:
  st=os.stat(s)
 except(OSError,ValueError):
  return False
 return stat.S_ISDIR(st.st_mode)
def islink(path):
 ''
 try:
  st=os.lstat(path)
 except(OSError,ValueError,AttributeError):
  return False
 return stat.S_ISLNK(st.st_mode)
def getsize(filename):
 ''
 return os.stat(filename).st_size
def getmtime(filename):
 ''
 return os.stat(filename).st_mtime
def getatime(filename):
 ''
 return os.stat(filename).st_atime
def getctime(filename):
 ''
 return os.stat(filename).st_ctime
def commonprefix(m):
 ''
 if not m:return ''
 if not isinstance(m[0],(list,tuple)):
  m=tuple(map(os.fspath,m))
 s1=min(m)
 s2=max(m)
 for i,c in enumerate(s1):
  if c !=s2[i]:
   return s1[:i]
 return s1
def samestat(s1,s2):
 ''
 return(s1.st_ino ==s2.st_ino and
 s1.st_dev ==s2.st_dev)
def samefile(f1,f2):
 ''
 s1=os.stat(f1)
 s2=os.stat(f2)
 return samestat(s1,s2)
def sameopenfile(fp1,fp2):
 ''
 s1=os.fstat(fp1)
 s2=os.fstat(fp2)
 return samestat(s1,s2)
def _splitext(p,sep,altsep,extsep):
 ''
 sepIndex=p.rfind(sep)
 if altsep:
  altsepIndex=p.rfind(altsep)
  sepIndex=max(sepIndex,altsepIndex)
 dotIndex=p.rfind(extsep)
 if dotIndex >sepIndex:
  filenameIndex=sepIndex+1
  while filenameIndex <dotIndex:
   if p[filenameIndex:filenameIndex+1]!=extsep:
    return p[:dotIndex],p[dotIndex:]
   filenameIndex +=1
 return p,p[:0]
def _check_arg_types(funcname,*args):
 hasstr=hasbytes=False
 for s in args:
  if isinstance(s,str):
   hasstr=True
  elif isinstance(s,bytes):
   hasbytes=True
  else:
   raise TypeError(f'{funcname}() argument must be str, bytes, or '
   f'os.PathLike object, not {s.__class__.__name__ !r}')from None
 if hasstr and hasbytes:
  raise TypeError("Can't mix strings and bytes in path components")from None
====genericpath.py(module) end====

====json.py(file) start====
''
__version__='2.0.9'
__all__=[
'dump','dumps','load','loads',
'JSONDecoder','JSONDecodeError','JSONEncoder',
]

__author__='Bob Ippolito <bob@redivi.com>'
class codecs:

 BOM_UTF8=b'\xef\xbb\xbf'
 BOM_LE=BOM_UTF16_LE=b'\xff\xfe'
 BOM_BE=BOM_UTF16_BE=b'\xfe\xff'
 BOM_UTF32_LE=b'\xff\xfe\x00\x00'
 BOM_UTF32_BE=b'\x00\x00\xfe\xff'
import _json
from.encoder import JSONEncoder

JSONDecoder=_json.JSONDecoder

class decoder:
 JSONDecoder=_json.JSONDecoder
class JSONDecodeError(ValueError):
 ''
 def __init__(self,msg,doc,pos):
  lineno=doc.count('\n',0,pos)+1
  colno=pos -doc.rfind('\n',0,pos)
  errmsg='%s: line %d column %d (char %d)'%(msg,lineno,colno,pos)
  ValueError.__init__(self,errmsg)
  self.msg=msg
  self.doc=doc
  self.pos=pos
  self.lineno=lineno
  self.colno=colno
 def __reduce__(self):
  return self.__class__,(self.msg,self.doc,self.pos)
def dump(obj,fp,**kw):
 fp.write(dumps(obj,**kw))
def dumps(obj,*,skipkeys=False,ensure_ascii=True,check_circular=True,
allow_nan=True,cls=None,indent=None,separators=None,
default=None,sort_keys=False,**kw):
 ''
 if cls is None:
  return _json.dumps(obj,1,
  skipkeys=skipkeys,ensure_ascii=ensure_ascii,
  check_circular=check_circular,allow_nan=allow_nan,indent=indent,
  separators=separators,default=default,sort_keys=sort_keys,
  **kw)
 return cls(
 skipkeys=skipkeys,ensure_ascii=ensure_ascii,
 check_circular=check_circular,allow_nan=allow_nan,indent=indent,
 separators=separators,default=default,sort_keys=sort_keys,
 **kw).encode(obj)
def detect_encoding(b):
 bstartswith=b.startswith
 if bstartswith((codecs.BOM_UTF32_BE,codecs.BOM_UTF32_LE)):
  return 'utf-32'
 if bstartswith((codecs.BOM_UTF16_BE,codecs.BOM_UTF16_LE)):
  return 'utf-16'
 if bstartswith(codecs.BOM_UTF8):
  return 'utf-8-sig'
 if len(b)>=4:
  if not b[0]:
   return 'utf-16-be'if b[1]else 'utf-32-be'
  if not b[1]:
   return 'utf-16-le'if b[2]or b[3]else 'utf-32-le'
 elif len(b)==2:
  if not b[0]:
   return 'utf-16-be'
  if not b[1]:
   return 'utf-16-le'
 return 'utf-8'
def load(fp,*,cls=None,object_hook=None,parse_float=None,
parse_int=None,parse_constant=None,object_pairs_hook=None,**kw):
 ''
 return loads(fp.read(),
 cls=cls,object_hook=object_hook,
 parse_float=parse_float,parse_int=parse_int,
 parse_constant=parse_constant,object_pairs_hook=object_pairs_hook,**kw)
def loads(s,*,cls=None,**kw):
 ''
 if isinstance(s,str):
  if s.startswith('\ufeff'):
   raise JSONDecodeError("Unexpected UTF-8 BOM (decode using utf-8-sig)",
   s,0)
 else:
  if not isinstance(s,(bytes,bytearray)):
   raise TypeError(f'the JSON object must be str, bytes or bytearray, '
   f'not {s.__class__.__name__}')
  s=s.decode(detect_encoding(s),'surrogatepass')
 if "encoding"in kw:
  import warnings
  warnings.warn(
  "'encoding' is ignored and deprecated. It will be removed in Python 3.9",
  DeprecationWarning,
  stacklevel=2
  )
  del kw['encoding']
 if cls is None:
  return _json.loads(s,**kw)
 if object_hook is not None:
  kw['object_hook']=object_hook
 if object_pairs_hook is not None:
  kw['object_pairs_hook']=object_pairs_hook
 if parse_float is not None:
  kw['parse_float']=parse_float
 if parse_int is not None:
  kw['parse_int']=parse_int
 if parse_constant is not None:
  kw['parse_constant']=parse_constant
 return cls(**kw).decode(s)
====json.py(file) end====

====json.encoder.py(module) start====
''

import re

try:
 from _json import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
 c_encode_basestring_ascii=None
try:
 from _json import encode_basestring as c_encode_basestring
except ImportError:
 c_encode_basestring=None
try:
 from _json import make_encoder as c_make_encoder
except ImportError:
 c_make_encoder=None
ESCAPE=re.compile(r'[\x00-\x1f\\"\b\f\n\r\t]')
ESCAPE_ASCII=re.compile(r'([\\"]|[^\ -~])')
HAS_UTF8=re.compile(b'[\x80-\xff]')
ESCAPE_DCT={
'\\':'\\\\',
'"':'\\"',
'\b':'\\b',
'\f':'\\f',
'\n':'\\n',
'\r':'\\r',
'\t':'\\t',
}
for i in range(0x20):
 ESCAPE_DCT.setdefault(chr(i),'\\u{0:04x}'.format(i))
del i

INFINITY=float('inf')

def py_encode_basestring(s):
 ''
 def replace(match):
  return ESCAPE_DCT[match.group(0)]
 return '"'+ESCAPE.sub(replace,s)+'"'
encode_basestring=(c_encode_basestring or py_encode_basestring)
def py_encode_basestring_ascii(s):
 ''
 def replace(match):
  s=match.group(0)
  try:
   return ESCAPE_DCT[s]
  except KeyError:
   n=ord(s)
   if n <0x10000:
    return '\\u{0:04x}'.format(n)
   else:
    n -=0x10000
    s1=0xd800 |((n >>10)&0x3ff)
    s2=0xdc00 |(n&0x3ff)
    return '\\u{0:04x}\\u{1:04x}'.format(s1,s2)
 return '"'+ESCAPE_ASCII.sub(replace,s)+'"'
encode_basestring_ascii=(
c_encode_basestring_ascii or py_encode_basestring_ascii)

class JSONEncoder(object):
 ''
 item_separator=', '
 key_separator=': '
 def __init__(self,*,skipkeys=False,ensure_ascii=True,
 check_circular=True,allow_nan=True,sort_keys=False,
 indent=None,separators=None,default=None):
  ''
  self.skipkeys=skipkeys
  self.ensure_ascii=ensure_ascii
  self.check_circular=check_circular
  self.allow_nan=allow_nan
  self.sort_keys=sort_keys
  self.indent=indent
  if separators is not None:
   self.item_separator,self.key_separator=separators
  elif indent is not None:
   self.item_separator=','
  if default is not None:
   self.default=default
 def default(self,o):
  ''
  raise TypeError(f'Object of type {o.__class__.__name__} '
  f'is not JSON serializable')
 def encode(self,o):
  ''
  if isinstance(o,str):
   if self.ensure_ascii:
    return encode_basestring_ascii(o)
   else:
    return encode_basestring(o)
  chunks=self.iterencode(o,_one_shot=True)
  if not isinstance(chunks,(list,tuple)):
   chunks=list(chunks)
  return ''.join(chunks)
 def iterencode(self,o,_one_shot=False):
  ''
  if self.check_circular:
   markers={}
  else:
   markers=None
  if self.ensure_ascii:
   _encoder=encode_basestring_ascii
  else:
   _encoder=encode_basestring
  def floatstr(o,allow_nan=self.allow_nan,
  _repr=float.__repr__,_inf=INFINITY,_neginf=-INFINITY):
   if o !=o:
    text='NaN'
   elif o ==_inf:
    text='Infinity'
   elif o ==_neginf:
    text='-Infinity'
   else:
    return _repr(o)
   if not allow_nan:
    raise ValueError(
    "Out of range float values are not JSON compliant: "+
    repr(o))
   return text
  if(_one_shot and c_make_encoder is not None
  and self.indent is None):
   _iterencode=c_make_encoder(
   markers,self.default,_encoder,self.indent,
   self.key_separator,self.item_separator,self.sort_keys,
   self.skipkeys,self.allow_nan)
  else:
   _iterencode=_make_iterencode(
   markers,self.default,_encoder,self.indent,floatstr,
   self.key_separator,self.item_separator,self.sort_keys,
   self.skipkeys,_one_shot)
  return _iterencode(o,0)
def _make_iterencode(markers,_default,_encoder,_indent,_floatstr,
_key_separator,_item_separator,_sort_keys,_skipkeys,_one_shot,

ValueError=ValueError,
dict=dict,
float=float,
id=id,
int=int,
isinstance=isinstance,
list=list,
str=str,
tuple=tuple,
_intstr=int.__repr__,
):

 if _indent is not None and not isinstance(_indent,str):
  _indent=' '*_indent
 def _iterencode_list(lst,_current_indent_level):
  if not lst:
   yield '[]'
   return
  if markers is not None:
   markerid=id(lst)
   if markerid in markers:
    raise ValueError("Circular reference detected")
   markers[markerid]=lst
  buf='['
  if _indent is not None:
   _current_indent_level +=1
   newline_indent='\n'+_indent *_current_indent_level
   separator=_item_separator+newline_indent
   buf +=newline_indent
  else:
   newline_indent=None
   separator=_item_separator
  first=True
  for value in lst:
   if first:
    first=False
   else:
    buf=separator
   if isinstance(value,str):
    yield buf+_encoder(value)
   elif value is None:
    yield buf+'null'
   elif value is True:
    yield buf+'true'
   elif value is False:
    yield buf+'false'
   elif isinstance(value,int):
    yield buf+_intstr(value)
   elif isinstance(value,float):
    yield buf+_floatstr(value)
   else:
    yield buf
    if isinstance(value,(list,tuple)):
     chunks=_iterencode_list(value,_current_indent_level)
    elif isinstance(value,dict):
     chunks=_iterencode_dict(value,_current_indent_level)
    else:
     chunks=_iterencode(value,_current_indent_level)
    yield from chunks
  if newline_indent is not None:
   _current_indent_level -=1
   yield '\n'+_indent *_current_indent_level
  yield ']'
  if markers is not None:
   del markers[markerid]
 def _iterencode_dict(dct,_current_indent_level):
  if not dct:
   yield '{}'
   return
  if markers is not None:
   markerid=id(dct)
   if markerid in markers:
    raise ValueError("Circular reference detected")
   markers[markerid]=dct
  yield '{'
  if _indent is not None:
   _current_indent_level +=1
   newline_indent='\n'+_indent *_current_indent_level
   item_separator=_item_separator+newline_indent
   yield newline_indent
  else:
   newline_indent=None
   item_separator=_item_separator
  first=True
  if _sort_keys:
   items=sorted(dct.items())
  else:
   items=dct.items()
  for key,value in items:
   if isinstance(key,str):
    pass
   elif isinstance(key,float):
    key=_floatstr(key)
   elif key is True:
    key='true'
   elif key is False:
    key='false'
   elif key is None:
    key='null'
   elif isinstance(key,int):
    key=_intstr(key)
   elif _skipkeys:
    continue
   else:
    raise TypeError(f'keys must be str, int, float, bool or None, '
    f'not {key.__class__.__name__}')
   if first:
    first=False
   else:
    yield item_separator
   yield _encoder(key)
   yield _key_separator
   if isinstance(value,str):
    yield _encoder(value)
   elif value is None:
    yield 'null'
   elif value is True:
    yield 'true'
   elif value is False:
    yield 'false'
   elif isinstance(value,int):
    yield _intstr(value)
   elif isinstance(value,float):
    yield _floatstr(value)
   else:
    if isinstance(value,(list,tuple)):
     chunks=_iterencode_list(value,_current_indent_level)
    elif isinstance(value,dict):
     chunks=_iterencode_dict(value,_current_indent_level)
    else:
     chunks=_iterencode(value,_current_indent_level)
    yield from chunks
  if newline_indent is not None:
   _current_indent_level -=1
   yield '\n'+_indent *_current_indent_level
  yield '}'
  if markers is not None:
   del markers[markerid]
 def _iterencode(o,_current_indent_level):
  if isinstance(o,str):
   yield _encoder(o)
  elif o is None:
   yield 'null'
  elif o is True:
   yield 'true'
  elif o is False:
   yield 'false'
  elif isinstance(o,int):
   yield _intstr(o)
  elif isinstance(o,float):
   yield _floatstr(o)
  elif isinstance(o,(list,tuple)):
   yield from _iterencode_list(o,_current_indent_level)
  elif isinstance(o,dict):
   yield from _iterencode_dict(o,_current_indent_level)
  else:
   if markers is not None:
    markerid=id(o)
    if markerid in markers:
     raise ValueError("Circular reference detected")
    markers[markerid]=o
   o=_default(o)
   yield from _iterencode(o,_current_indent_level)
   if markers is not None:
    del markers[markerid]
 return _iterencode
====json.encoder.py(module) end====

====math.js(file) start====
(function($B){

var _b_ = $B.builtins

const INF = $B.fast_float(Number.POSITIVE_INFINITY),
      NINF = $B.fast_float(Number.NEGATIVE_INFINITY),
      ZERO = $B.fast_float(0),
      NAN = $B.fast_float(Number.NaN)

var float_check = function(x) {
    // Returns a Javascript number
    if(x.__class__ === $B.long_int){
        var res = parseInt(x.value)
        if(! isFinite(res)){
            throw _b_.OverflowError.$factory('int too big for float')
        }
        return res
    }else if(x.__class__ === _b_.float){
        return x.value
    }
    try{
        return _b_.float.$factory(x).value
    }catch(err){
        throw _b_.TypeError.$factory('must be real number, not ' +
            $B.class_name(x))
    }
}

function check_int(x){
    if(! $B.$isinstance(x, _b_.int)){
        throw _b_.TypeError.$factory("'" + $B.class_name(x) +
            "' object cannot be interpreted as an integer")
    }
}

function check_int_or_round_float(x){
    return ($B.$isinstance(x, _b_.float) && Number.isInteger(x.value)) ||
            $B.$isinstance(x, _b_.int)
}

var isWholeNumber = function(x){return (x * 10) % 10 == 0}

var isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}

var isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}

function overflow(){
    throw _b_.OverflowError.$factory("math range error")
}

function value_error(){
    throw _b_.ValueError.$factory("math range error")
}

var EPSILON = Math.pow(2, -52),
    MAX_VALUE = (2 - EPSILON) * Math.pow(2, 1023),
    MIN_VALUE = Math.pow(2, -1022),
    Py_HUGE_VAL = Number.POSITIVE_INFINITY,
    logpi = 1.144729885849400174143427351353058711647,
    sqrtpi = 1.772453850905516027298167483341145182798

function nextUp(x){
    if(x !== x){ // NaN
        return x
    }
    if(_b_.float.$funcs.isinf(x)){
        if(_b_.float.$funcs.isninf(x)){
            return -MAX_VALUE
        }
        return _mod.inf
    }
    if($B.$isinstance(x, $B.long_int)){
        x = Number(x.value)
    }else if($B.$isinstance(x, _b_.float)){
        x = x.value
    }

    if(x == +MAX_VALUE){
        return +1 / 0
    }
    if(typeof x == "number"){
        var y = x * (x < 0 ? 1 - EPSILON / 2 : 1 + EPSILON)
        if(y == x){
            y = MIN_VALUE * EPSILON > 0 ? x + MIN_VALUE * EPSILON : x + MIN_VALUE
        }
        if(y === +1 / 0){
            y = +MAX_VALUE
        }
        var b = x + (y - x) / 2
        if(x < b && b < y){
            y = b;
        }
        var c = (y + x) / 2
        if(x < c && c < y){
            y = c;
        }
        return y === 0 ? -0 : y
    }else{
        var factor = $B.rich_comp('__lt__', x, 0) ? 1 - EPSILON / 2 :
                                                   1 + EPSILON
        var y = $B.rich_op("__mul__", x , factor)
        if(y == x){
            y = MIN_VALUE * EPSILON > 0 ?
                    $B.rich_op('__add__', x, MIN_VALUE * EPSILON) :
                    $B.rich_op('__add__', x, MIN_VALUE)
        }
        if(y === +1 / 0){
            y = +MAX_VALUE
        }
        var y_minus_x = $B.rich_op('__sub__', y, x)
        var z = $B.rich_op('__truediv__', y_minus_x, 2) // (y - x) / 2

        var b = $B.rich_op('__add__', x, z)
        if($B.rich_comp('__lt__', x, b) && $B.rich_comp('__lt__', b, y)){
            y = b;
        }
        var c = $B.rich_op('__truediv__', $B.rich_op('__add__', y, x), 2)
        if($B.rich_comp('__lt__', x, c) && $B.rich_comp('__lt__', c, y)){
            y = c;
        }
        return y === 0 ? -0 : y
    }
}

function gcd2(a, b){
    // GCD of 2 factors
    if($B.rich_comp("__gt__", b, a)){
        var temp = a
        a = b
        b = temp
    }
    while(true){
        if(b == 0){
            return a
        }
        a = $B.rich_op("__mod__", a, b)
        if(a == 0){
            return b
        }
        b = $B.rich_op("__mod__", b, a)
    }
}

const LANCZOS_N = 13,
      lanczos_g = 6.024680040776729583740234375,
      lanczos_g_minus_half = 5.524680040776729583740234375,
      lanczos_num_coeffs = [
    23531376880.410759688572007674451636754734846804940,
    42919803642.649098768957899047001988850926355848959,
    35711959237.355668049440185451547166705960488635843,
    17921034426.037209699919755754458931112671403265390,
    6039542586.3520280050642916443072979210699388420708,
    1439720407.3117216736632230727949123939715485786772,
    248874557.86205415651146038641322942321632125127801,
    31426415.585400194380614231628318205362874684987640,
    2876370.6289353724412254090516208496135991145378768,
    186056.26539522349504029498971604569928220784236328,
    8071.6720023658162106380029022722506138218516325024,
    210.82427775157934587250973392071336271166969580291,
    2.5066282746310002701649081771338373386264310793408
    ],
    /* denominator is x*(x+1)*...*(x+LANCZOS_N-2) */
    lanczos_den_coeffs = [
    0.0, 39916800.0, 120543840.0, 150917976.0, 105258076.0, 45995730.0,
    13339535.0, 2637558.0, 357423.0, 32670.0, 1925.0, 66.0, 1.0],
    /* gamma values for small positive integers, 1 though NGAMMA_INTEGRAL */
    NGAMMA_INTEGRAL = 23,
    gamma_integral = [
    1.0, 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0, 40320.0, 362880.0,
    3628800.0, 39916800.0, 479001600.0, 6227020800.0, 87178291200.0,
    1307674368000.0, 20922789888000.0, 355687428096000.0,
    6402373705728000.0, 121645100408832000.0, 2432902008176640000.0,
    51090942171709440000.0, 1124000727777607680000.0]

/* Lanczos' sum L_g(x), for positive x */
function lanczos_sum(x){
    var num = 0.0,
        den = 0.0,
        i
    /* evaluate the rational function lanczos_sum(x).  For large
       x, the obvious algorithm risks overflow, so we instead
       rescale the denominator and numerator of the rational
       function by x**(1-LANCZOS_N) and treat this as a
       rational function in 1/x.  This also reduces the error for
       larger x values.  The choice of cutoff point (5.0 below) is
       somewhat arbitrary; in tests, smaller cutoff values than
       this resulted in lower accuracy. */
    if (x < 5.0) {
        for (i = LANCZOS_N; --i >= 0; ) {
            num = num * x + lanczos_num_coeffs[i];
            den = den * x + lanczos_den_coeffs[i];
        }
    }else{
        for (i = 0; i < LANCZOS_N; i++) {
            num = num / x + lanczos_num_coeffs[i];
            den = den / x + lanczos_den_coeffs[i];
        }
    }
    return num/den;
}

function m_sinpi(x){
    // x is float
    // returns a float
    var r,
        y = fmod(fabs(x), 2.0), // float
        n = _b_.round($B.fast_float(2.0 * y.value)) // int
    switch(n){
        case 0:
            r = sin(pi.value * y.value);
            break;
        case 1:
            r = cos(pi.value * (y.value - 0.5));
            break;
        case 2:
            /* N.B. -sin(pi*(y-1.0)) is *not* equivalent: it would give
               -0.0 instead of 0.0 when y == 1.0. */
            r = sin(pi.value * (1.0 - y.value));
            break;
        case 3:
            r = _b_.float.__neg__(cos(pi.value *(y.value - 1.5)))
            break;
        case 4:
            r = sin(pi.value * (y.value - 2.0));
            break;
        }
    return $B.fast_float(copysign(1.0, x).value * r.value);
}

/*
   lgamma:  natural log of the absolute value of the Gamma function.
   For large arguments, Lanczos' formula works extremely well here.
*/
function m_lgamma(x){
    var r,
        absx

    /* special cases */
    if(! isfinite(x)){
        if(isnan(x)){
            return x;  /* lgamma(nan) = nan */
        }else{
            return $B.fast_float(Number.POSITIVE_INFINITY); /* lgamma(+-inf) = +inf */
        }
    }

    /* integer arguments */
    var x1 = float_check(x)
    if(Number.isInteger(x1) && x1 <= 2.0){
        if(x1 <= 0.0){
            value_error()
        }else{
            return $B.fast_float(0.0); /* lgamma(1) = lgamma(2) = 0.0 */
        }
    }

    absx = fabs(x)
    /* tiny arguments: lgamma(x) ~ -log(fabs(x)) for small x */
    if (absx.value < 1e-20){
        return  $B.fast_float(-log(absx).value);
    }
    /* Lanczos' formula.  We could save a fraction of a ulp in accuracy by
       having a second set of numerator coefficients for lanczos_sum that
       absorbed the exp(-lanczos_g) term, and throwing out the lanczos_g
       subtraction below; it's probably not worth it. */
    var lsum = $B.fast_float(lanczos_sum(absx.value))
    r = log(lsum).value - lanczos_g;
    r += (absx.value - 0.5) *
        (log($B.fast_float(absx.value + lanczos_g - 0.5)).value - 1)
    if (x1 < 0.0){
        /* Use reflection formula to get value for negative x. */
        r = logpi - log(fabs(m_sinpi(absx))).value - log(absx).value - r
    }
    r = $B.fast_float(r)
    if(isinf(r)){
        overflow()
    }
    return r;
}

function acos(x){
    $B.check_nb_args('acos', 1, arguments)
    $B.check_no_kw('acos', x)
    if(_mod.isinf(x)){
        throw _b_.ValueError.$factory("math domain error")
    }else if(_mod.isnan(x)){
        return _mod.nan
    }else{
        x = float_check(x)
        if(x > 1 || x < -1){
            throw _b_.ValueError.$factory("math domain error")
        }
        return _b_.float.$factory(Math.acos(x))
    }
}

function acosh(x){
    $B.check_nb_args('acosh', 1, arguments)
    $B.check_no_kw('acosh', x)

    if(_b_.float.$funcs.isinf(x)){
        if(_b_.float.$funcs.isninf(x)){
            throw _b_.ValueError.$factory("math domain error")
        }
        return _mod.inf
    }else if(_mod.isnan(x)){
        return _mod.nan
    }
    var y = float_check(x)
    if(y <= 0){
        throw _b_.ValueError.$factory("math domain error")
    }
    if(y > Math.pow(2, 28)){ // issue 1590
        return _b_.float.$factory(_mod.log(y).value + _mod.log(2).value)
    }
    return _b_.float.$factory(Math.log(y + Math.sqrt(y * y - 1)))
}

function asin(x){
    $B.check_nb_args('asin', 1, arguments)
    $B.check_no_kw('asin', x)
    if(_mod.isinf(x)){
        throw _b_.ValueError.$factory("math domain error")
    }else if(_mod.isnan(x)){
        return _mod.nan
    }else{
        x = float_check(x)
        if(x > 1 || x < -1){
            throw _b_.ValueError.$factory("math domain error")
        }
        return _b_.float.$factory(Math.asin(x))
    }
}

function asinh(x){
    $B.check_nb_args('asinh', 1, arguments)
    $B.check_no_kw('asinh', x)

    var y = float_check(x)
    if(_b_.float.$funcs.isninf(x)){
        return NINF
    }else if(_b_.float.$funcs.isinf(x)){
        return INF
    }
    if(y == 0 && 1 / y === -Infinity){
        return $B.fast_float(-0.0)
    }
    return _b_.float.$factory(Math.asinh(y))
}

function atan(x){
    $B.check_nb_args('atan', 1, arguments)
    $B.check_no_kw('atan', x)

    if(_b_.float.$funcs.isninf(x)){return _b_.float.$factory(-Math.PI / 2)}
    if(_b_.float.$funcs.isinf(x)){return _b_.float.$factory(Math.PI / 2)}
    return _b_.float.$factory(Math.atan(float_check(x)))
}

function atan2(x, y){
    $B.check_nb_args('atan2', 2, arguments)
    $B.check_no_kw('atan2', x, y)

    return _b_.float.$factory(Math.atan2(float_check(x), float_check(y)))
}

function atanh(x){
    $B.check_nb_args('atanh', 1, arguments)
    $B.check_no_kw('atanh', x)
    if(_b_.float.$funcs.isinf(x)){
        throw _b_.ValueError.$factory("math domain error")
    }
    var y = float_check(x)
    if(y == 0){
        return 0
    }else if(y <= -1 || y >= 1){
        throw _b_.ValueError.$factory("math domain error")
    }
    return _b_.float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));
}

function cbrt(x){
    // Cubic root
    $B.check_nb_args('cbrt ', 1, arguments)
    $B.check_no_kw('cbrt ', x)

    var y = float_check(x)
    if(_b_.float.$funcs.isninf(x)){
        return NINF
    }else if(_b_.float.$funcs.isinf(x)){
        return INF
    }
    var _r = $B.fast_float(Math.cbrt(y))
    if(_b_.float.$funcs.isinf(_r)){
        throw _b_.OverflowError.$factory("math range error")
    }
    return _r
}

function ceil(x){
    $B.check_nb_args('ceil', 1, arguments)
    $B.check_no_kw('ceil', x)

    var res

    if($B.$isinstance(x, _b_.float)){
        if(_b_.float.$funcs.isinf(x)){
            throw _b_.OverflowError.$factory(
                "cannot convert float infinity to integer")
        }else if(_mod.isnan(x)){
            throw _b_.OverflowError.$factory(
                "cannot convert float NaN to integer")
        }
    }

    var klass = x.__class__ || $B.get_class(x)

    try{
        // Use attribute of the object's class, not of the object
        // itself (special method)
        return $B.$call($B.$getattr(klass, '__ceil__'))(x)
    }catch(err){
        if(! $B.is_exc(err, [_b_.AttributeError])){
            throw err
        }
    }

    try{
        x = $B.$call($B.$getattr(klass, '__float__'))(x)
    }catch(err){
        if(! $B.is_exc(err, [_b_.AttributeError])){
            throw err
        }else{
            throw _b_.TypeError.$factory("must be real number, not " +
               $B.class_name(x))
        }
    }
    return _mod.ceil(x)
}

const ULLONG_MAX = 2n ** 64n - 1n,
      LONG_MAX = 2147483647,
      LONG_MIN = -2147483647,
      LLONG_MAX = 9223372036854775807n,
      LLONG_MIN = -9223372036854775807n,
      p2_64 = 2n ** 64n

const reduced_factorial_odd_part = [
    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0x0000000000000003n,
    0x0000000000000003n, 0x000000000000000fn, 0x000000000000002dn, 0x000000000000013bn,
    0x000000000000013bn, 0x0000000000000b13n, 0x000000000000375fn, 0x0000000000026115n,
    0x000000000007233fn, 0x00000000005cca33n, 0x0000000002898765n, 0x00000000260eeeebn,
    0x00000000260eeeebn, 0x0000000286fddd9bn, 0x00000016beecca73n, 0x000001b02b930689n,
    0x00000870d9df20adn, 0x0000b141df4dae31n, 0x00079dd498567c1bn, 0x00af2e19afc5266dn,
    0x020d8a4d0f4f7347n, 0x335281867ec241efn, 0x9b3093d46fdd5923n, 0x5e1f9767cc5866b1n,
    0x92dd23d6966aced7n, 0xa30d0f4f0a196e5bn, 0x8dc3e5a1977d7755n, 0x2ab8ce915831734bn,
    0x2ab8ce915831734bn, 0x81d2a0bc5e5fdcabn, 0x9efcac82445da75bn, 0xbc8b95cf58cde171n,
    0xa0e8444a1f3cecf9n, 0x4191deb683ce3ffdn, 0xddd3878bc84ebfc7n, 0xcb39a64b83ff3751n,
    0xf8203f7993fc1495n, 0xbd2a2a78b35f4bddn, 0x84757be6b6d13921n, 0x3fbbcfc0b524988bn,
    0xbd11ed47c8928df9n, 0x3c26b59e41c2f4c5n, 0x677a5137e883fdb3n, 0xff74e943b03b93ddn,
    0xfe5ebbcb10b2bb97n, 0xb021f1de3235e7e7n, 0x33509eb2e743a58fn, 0x390f9da41279fb7dn,
    0xe5cb0154f031c559n, 0x93074695ba4ddb6dn, 0x81c471caa636247fn, 0xe1347289b5a1d749n,
    0x286f21c3f76ce2ffn, 0x00be84a2173e8ac7n, 0x1595065ca215b88bn, 0xf95877595b018809n,
    0x9c2efe3c5516f887n, 0x373294604679382bn, 0xaf1ff7a888adcd35n, 0x18ddf279a2c5800bn,
    0x18ddf279a2c5800bn, 0x505a90e2542582cbn, 0x5bacad2cd8d5dc2bn, 0xfe3152bcbff89f41n,
    0xe1467e88bf829351n, 0xb8001adb9e31b4d5n, 0x2803ac06a0cbb91fn, 0x1904b5d698805799n,
    0xe12a648b5c831461n, 0x3516abbd6160cfa9n, 0xac46d25f12fe036dn, 0x78bfa1da906b00efn,
    0xf6390338b7f111bdn, 0x0f25f80f538255d9n, 0x4ec8ca55b8db140fn, 0x4ff670740b9b30a1n,
    0x8fd032443a07f325n, 0x80dfe7965c83eeb5n, 0xa3dc1714d1213afdn, 0x205b7bbfcdc62007n,
    0xa78126bbe140a093n, 0x9de1dc61ca7550cfn, 0x84f0046d01b492c5n, 0x2d91810b945de0f3n,
    0xf5408b7f6008aa71n, 0x43707f4863034149n, 0xdac65fb9679279d5n, 0xc48406e7d1114eb7n,
    0xa7dc9ed3c88e1271n, 0xfb25b2efdb9cb30dn, 0x1bebda0951c4df63n, 0x5c85e975580ee5bdn,
    0x1591bc60082cb137n, 0x2c38606318ef25d7n, 0x76ca72f7c5c63e27n, 0xf04a75d17baa0915n,
    0x77458175139ae30dn, 0x0e6c1330bc1b9421n, 0xdf87d2b5797e8293n, 0xefa5c703e1e68925n,
    0x2b6b1b3278b4f6e1n, 0xceee27b382394249n, 0xd74e3829f5dab91dn, 0xfdb17989c26b5f1fn,
    0xc1b7d18781530845n, 0x7b4436b2105a8561n, 0x7ba7c0418372a7d7n, 0x9dbc5c67feb6c639n,
    0x502686d7f6ff6b8fn, 0x6101855406be7a1fn, 0x9956afb5806930e7n, 0xe1f0ee88af40f7c5n,
    0x984b057bda5c1151n, 0x9a49819acc13ea05n, 0x8ef0dead0896ef27n, 0x71f7826efe292b21n,
    0xad80a480e46986efn, 0x01cdc0ebf5e0c6f7n, 0x6e06f839968f68dbn, 0xdd5943ab56e76139n,
    0xcdcf31bf8604c5e7n, 0x7e2b4a847054a1cbn, 0x0ca75697a4d3d0f5n, 0x4703f53ac514a98bn,
];

const inverted_factorial_odd_part = [
    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0xaaaaaaaaaaaaaaabn,
    0xaaaaaaaaaaaaaaabn, 0xeeeeeeeeeeeeeeefn, 0x4fa4fa4fa4fa4fa5n, 0x2ff2ff2ff2ff2ff3n,
    0x2ff2ff2ff2ff2ff3n, 0x938cc70553e3771bn, 0xb71c27cddd93e49fn, 0xb38e3229fcdee63dn,
    0xe684bb63544a4cbfn, 0xc2f684917ca340fbn, 0xf747c9cba417526dn, 0xbb26eb51d7bd49c3n,
    0xbb26eb51d7bd49c3n, 0xb0a7efb985294093n, 0xbe4b8c69f259eabbn, 0x6854d17ed6dc4fb9n,
    0xe1aa904c915f4325n, 0x3b8206df131cead1n, 0x79c6009fea76fe13n, 0xd8c5d381633cd365n,
    0x4841f12b21144677n, 0x4a91ff68200b0d0fn, 0x8f9513a58c4f9e8bn, 0x2b3e690621a42251n,
    0x4f520f00e03c04e7n, 0x2edf84ee600211d3n, 0xadcaa2764aaacdfdn, 0x161f4f9033f4fe63n,
    0x161f4f9033f4fe63n, 0xbada2932ea4d3e03n, 0xcec189f3efaa30d3n, 0xf7475bb68330bf91n,
    0x37eb7bf7d5b01549n, 0x46b35660a4e91555n, 0xa567c12d81f151f7n, 0x4c724007bb2071b1n,
    0x0f4a0cce58a016bdn, 0xfa21068e66106475n, 0x244ab72b5a318ae1n, 0x366ce67e080d0f23n,
    0xd666fdae5dd2a449n, 0xd740ddd0acc06a0dn, 0xb050bbbb28e6f97bn, 0x70b003fe890a5c75n,
    0xd03aabff83037427n, 0x13ec4ca72c783bd7n, 0x90282c06afdbd96fn, 0x4414ddb9db4a95d5n,
    0xa2c68735ae6832e9n, 0xbf72d71455676665n, 0xa8469fab6b759b7fn, 0xc1e55b56e606caf9n,
    0x40455630fc4a1cffn, 0x0120a7b0046d16f7n, 0xa7c3553b08faef23n, 0x9f0bfd1b08d48639n,
    0xa433ffce9a304d37n, 0xa22ad1d53915c683n, 0xcb6cbc723ba5dd1dn, 0x547fb1b8ab9d0ba3n,
    0x547fb1b8ab9d0ba3n, 0x8f15a826498852e3n, 0x32e1a03f38880283n, 0x3de4cce63283f0c1n,
    0x5dfe6667e4da95b1n, 0xfda6eeeef479e47dn, 0xf14de991cc7882dfn, 0xe68db79247630ca9n,
    0xa7d6db8207ee8fa1n, 0x255e1f0fcf034499n, 0xc9a8990e43dd7e65n, 0x3279b6f289702e0fn,
    0xe7b5905d9b71b195n, 0x03025ba41ff0da69n, 0xb7df3d6d3be55aefn, 0xf89b212ebff2b361n,
    0xfe856d095996f0adn, 0xd6e533e9fdf20f9dn, 0xf8c0e84a63da3255n, 0xa677876cd91b4db7n,
    0x07ed4f97780d7d9bn, 0x90a8705f258db62fn, 0xa41bbb2be31b1c0dn, 0x6ec28690b038383bn,
    0xdb860c3bb2edd691n, 0x0838286838a980f9n, 0x558417a74b36f77dn, 0x71779afc3646ef07n,
    0x743cda377ccb6e91n, 0x7fdf9f3fe89153c5n, 0xdc97d25df49b9a4bn, 0x76321a778eb37d95n,
    0x7cbb5e27da3bd487n, 0x9cff4ade1a009de7n, 0x70eb166d05c15197n, 0xdcf0460b71d5fe3dn,
    0x5ac1ee5260b6a3c5n, 0xc922dedfdd78efe1n, 0xe5d381dc3b8eeb9bn, 0xd57e5347bafc6aadn,
    0x86939040983acd21n, 0x395b9d69740a4ff9n, 0x1467299c8e43d135n, 0x5fe440fcad975cdfn,
    0xcaa9a39794a6ca8dn, 0xf61dbd640868dea1n, 0xac09d98d74843be7n, 0x2b103b9e1a6b4809n,
    0x2ab92d16960f536fn, 0x6653323d5e3681dfn, 0xefd48c1c0624e2d7n, 0xa496fefe04816f0dn,
    0x1754a7b07bbdd7b1n, 0x23353c829a3852cdn, 0xbf831261abd59097n, 0x57a8e656df0618e1n,
    0x16e9206c3100680fn, 0xadad4c6ee921dac7n, 0x635f2b3860265353n, 0xdd6d0059f44b3d09n,
    0xac4dd6b894447dd7n, 0x42ea183eeaa87be3n, 0x15612d1550ee5b5dn, 0x226fa19d656cb623n,
]

const factorial_trailing_zeros = [
     0,  0,  1,  1,  3,  3,  4,  4,  7,  7,  8,  8, 10, 10, 11, 11,  //  0-15
    15, 15, 16, 16, 18, 18, 19, 19, 22, 22, 23, 23, 25, 25, 26, 26,  // 16-31
    31, 31, 32, 32, 34, 34, 35, 35, 38, 38, 39, 39, 41, 41, 42, 42,  // 32-47
    46, 46, 47, 47, 49, 49, 50, 50, 53, 53, 54, 54, 56, 56, 57, 57,  // 48-63
    63, 63, 64, 64, 66, 66, 67, 67, 70, 70, 71, 71, 73, 73, 74, 74,  // 64-79
    78, 78, 79, 79, 81, 81, 82, 82, 85, 85, 86, 86, 88, 88, 89, 89,  // 80-95
    94, 94, 95, 95, 97, 97, 98, 98, 101, 101, 102, 102, 104, 104, 105, 105,  // 96-111
    109, 109, 110, 110, 112, 112, 113, 113, 116, 116, 117, 117, 119, 119, 120, 120,  // 112-127
].map(BigInt)

const NULL = undefined

/* Calculate C(n, k) for n in the 63-bit range. */

function perm_comb_small(n, k, iscomb){
    if(k == 0){
        return 1n
    }

    /* For small enough n and k the result fits in the 64-bit range and can
     * be calculated without allocating intermediate PyLong objects. */
    if(iscomb){
        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)
         * fits into a uint64_t.  Exclude k = 1, because the second fast
         * path is faster for this case.*/
        var fast_comb_limits1 = [
            0, 0, 127, 127, 127, 127, 127, 127,  // 0-7
            127, 127, 127, 127, 127, 127, 127, 127,  // 8-15
            116, 105, 97, 91, 86, 82, 78, 76,  // 16-23
            74, 72, 71, 70, 69, 68, 68, 67,  // 24-31
            67, 67, 67  // 32-34
        ];
        if(k < fast_comb_limits1.length && n <= fast_comb_limits1[k]){
            /*
                comb(n, k) fits into a uint64_t. We compute it as
                    comb_odd_part << shift
                where 2**shift is the largest power of two dividing comb(n, k)
                and comb_odd_part is comb(n, k) >> shift. comb_odd_part can be
                calculated efficiently via arithmetic modulo 2**64, using three
                lookups and two uint64_t multiplications.
            */
            var comb_odd_part = reduced_factorial_odd_part[n]
                                   * inverted_factorial_odd_part[k]
                                   * inverted_factorial_odd_part[n - k];
            comb_odd_part %= p2_64
            var shift = factorial_trailing_zeros[n]
                      - factorial_trailing_zeros[k]
                      - factorial_trailing_zeros[n - k];
            return comb_odd_part << shift;
        }

        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)*k
         * fits into a long long (which is at least 64 bit).  Only contains
         * items larger than in fast_comb_limits1. */
        var fast_comb_limits2 = [
            0, ULLONG_MAX, 4294967296, 3329022, 102570, 13467, 3612, 1449,  // 0-7
            746, 453, 308, 227, 178, 147  // 8-13
        ];
        if (k < fast_comb_limits2.length && n <= fast_comb_limits2[k]) {
            /* C(n, k) = C(n, k-1) * (n-k+1) / k */
            var result = n,
                i = 1n;
            while(i < k){
                result *= --n;
                result /= ++i;
            }
            return result;
        }
    }else{
        /* Maps k to the maximal n so that k <= n and P(n, k)
         * fits into a long long (which is at least 64 bit). */
        var fast_perm_limits = [
            0, ULLONG_MAX, 4294967296, 2642246, 65537, 7133, 1627, 568,  // 0-7
            259, 142, 88, 61, 45, 36, 30, 26,  // 8-15
            24, 22, 21, 20, 20  // 16-20
        ];
        if (k < fast_perm_limits.length && n <= fast_perm_limits[k]) {
            if(n <= 127){
                /* P(n, k) fits into a uint64_t. */
                var perm_odd_part = reduced_factorial_odd_part[n]
                                       * inverted_factorial_odd_part[n - k];
                perm_odd_part %= p2_64
                var shift = factorial_trailing_zeros[n]
                          - factorial_trailing_zeros[n - k];
                var res = perm_odd_part << shift

                return res;
            }

            /* P(n, k) = P(n, k-1) * (n-k+1) */
            var result = n;
            for (var i = 1; i < k; i++) {
                result *= --n;
            }
            return result
        }
    }

    /* For larger n use recursive formulas:
     *
     *   P(n, k) = P(n, j) * P(n-j, k-j)
     *   C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j)
     */
    var j = k / 2n;
    var a = perm_comb_small(n, j, iscomb);
    var b = perm_comb_small(n - j, k - j, iscomb);
    a = a * b;
    if(iscomb){
        b = perm_comb_small(k, j, 1);
        a = a / b;
    }
    return a;
}

/* Calculate P(n, k) or C(n, k) using recursive formulas.
 * It is more efficient than sequential multiplication thanks to
 * Karatsuba multiplication.
 */
function perm_comb(n, k, iscomb){
    if(k == 0){
        return 1;
    }
    if(k == 1){
        return n;
    }

    /* P(n, k) = P(n, j) * P(n-j, k-j) */
    /* C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j) */
    var j = k / 2n
    var a = perm_comb(n, j, iscomb);
    //var t = j
    //n = n - t;
    var b = perm_comb(n - j, k - j, iscomb);
    a = a * b;
    if(iscomb){
        b = perm_comb_small(k, j, 1);
        a = a / b;
    }
    return a;
}

function comb(n, k){
    var $ = $B.args('comb', 2, {n: null, k: null}, ['n', 'k'],
            arguments, {}, null, null),
        n = $.n,
        k = $.k

    var result = NULL,
        temp,
        overflow, cmp;

    // accept integers or objects with __index__
    n = $B.PyNumber_Index(n)
    k = $B.PyNumber_Index(k)

    n = _b_.int.$to_bigint(n);
    k = _b_.int.$to_bigint(k);

    if(n < 0){
        throw _b_.ValueError.$factory(
                        "n must be a non-negative integer");
    }
    if(k < 0){
        throw _b_.ValueError.$factory(
                        "k must be a non-negative integer");
    }

    overflow = n > LLONG_MAX || n < LLONG_MIN
    if(! overflow){
        overflow = k > LLONG_MAX || k < LLONG_MIN
        if (overflow || k > n) {
            result = 0n;
        }else{
            if(n - k < k){
                k = n - k
            }
            if (k > 1) {
                result = perm_comb_small(n, k, 1);
            }
        }
        /* For k == 1 just return the original n in perm_comb(). */
    }else{
        /* k = min(k, n - k) */
        temp = n - k
        if(temp < 0) {
            result = 0n;
        }
        if (temp < k) {
            k = temp
        }

        overflow = k > LLONG_MAX || k < LLONG_MIN
        if (overflow) {
            throw _b_.OverflowError.$factory(
                         "min(n - k, k) must not exceed " +
                         LLONG_MAX);
        }
    }
    if(result === undefined){
        result = perm_comb(n, k, 1);
    }

    return _b_.int.$int_or_long(result)
}
function copysign(x, y){
    $B.check_nb_args_no_kw('copysign', 2, arguments)

    var x1 = Math.abs(float_check(x))
    var y1 = float_check(y)
    var sign = Math.sign(y1)
    sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1
    return _b_.float.$factory(x1 * sign)
}

function cos(x){
    $B.check_nb_args('cos ', 1, arguments)
    $B.check_no_kw('cos ', x)
    return _b_.float.$factory(Math.cos(float_check(x)))
}

function cosh(x){
    $B.check_nb_args('cosh', 1, arguments)
    $B.check_no_kw('cosh', x)

    if(_b_.float.$funcs.isinf(x)){return INF}
    var y = float_check(x)
    if(Math.cosh !== undefined){return _b_.float.$factory(Math.cosh(y))}
    return _b_.float.$factory((Math.pow(Math.E, y) +
        Math.pow(Math.E, -y)) / 2)
}

function degrees(x){
    $B.check_nb_args('degrees', 1, arguments)
    $B.check_no_kw('degrees', x)
    return _b_.float.$factory(float_check(x) * 180 / Math.PI)
}

function dist(p, q){
    $B.check_nb_args_no_kw('dist', 2, arguments)

    function test(x){
        if(typeof x === "number"){
            return x
        }else if(x.__class__ === _b_.float){
            return x.value
        }
        var y = $B.$getattr(x, '__float__', null)
        if(y === null){
            throw _b_.TypeError.$factory('not a float')
        }
        return $B.$call(y)().value
    }

    // build list of differences (as floats) between coordinates of p and q
    var diffs = [],
        diff

    if(Array.isArray(p) && Array.isArray(q)){
        // simple case : p and q are lists of tuples
        if(p.length != q.length){
            throw _b_.ValueError.$factory("both points must have " +
                "the same number of dimensions")
        }
        p = p.map(test)
        q = q.map(test)
        for(var i = 0, len = p.length; i < len; i++){
            var next_p = p[i],
                next_q = q[i]
            var diff = Math.abs(next_p - next_q)
            diffs.push(diff)
        }
    }else{
        var itp = _b_.iter(p),
            itq = _b_.iter(q),
            res = 0

        while(true){
            try{
                var next_p = _b_.next(itp)
            }catch(err){
                if(err.__class__ === _b_.StopIteration){
                    // check that the other iterator is also exhausted
                    try{
                        var next_q = _b_.next(itq)
                        throw _b_.ValueError.$factory("both points must have " +
                            "the same number of dimensions")
                    }catch(err){
                        if(err.__class__ === _b_.StopIteration){
                            break
                        }
                        throw err
                    }
                }
                throw err
            }
            next_p = test(next_p)
            try{
                var next_q = _b_.next(itq)
            }catch(err){
                if(err.__class__ === _b_.StopIteration){
                    throw _b_.ValueError.$factory("both points must have " +
                        "the same number of dimensions")
                }
                throw err
            }
            next_q = test(next_q)
            diff = Math.abs(next_p - next_q)
            diffs.push(diff)
        }
    }
    for(var diff of diffs){
        if(! isFinite(diff) && ! isNaN(diff)){
            return _mod.inf
        }
    }
    for(var diff of diffs){
        if(isNaN(diff)){
            return _mod.nan
        }
    }

    var res = 0,
        scale = 1,
        max_diff = Math.max(...diffs),
        min_diff = Math.min(...diffs)
        max_value = Math.sqrt(Number.MAX_VALUE) / p.length,
        min_value = Math.sqrt(Number.MIN_VALUE) * p.length
    if(max_diff > max_value){
        var nb = 0
        while(max_diff > max_value){
            scale *= 2
            max_diff /= 2
            nb++
        }
        for(var diff of diffs){
            diff = diff / scale
            res += diff * diff
        }
        return $B.fast_float(scale * Math.sqrt(res))
    }else if(min_diff !== 0 && min_diff < min_value){
        while(min_diff < min_value){
            scale *= 2
            min_diff *= 2
        }
        for(var diff of diffs){
            diff = diff * scale
            res += diff * diff
        }
        return $B.fast_float(Math.sqrt(res) / scale)
    }else{
        for(var diff of diffs){
            res += Math.pow(diff, 2)
        }
        return $B.fast_float(Math.sqrt(res))
    }
}

const e = _b_.float.$factory(Math.E)

const ERF_SERIES_CUTOFF = 1.5,
      ERF_SERIES_TERMS = 25,
      ERFC_CONTFRAC_CUTOFF = 30.0,
      ERFC_CONTFRAC_TERMS = 50

/*
   Error function, via power series.
   Given a finite float x, return an approximation to erf(x).
   Converges reasonably fast for small x.
*/

function m_erf_series(x){
    var x2, acc, fk, result
    var i

    x2 = x * x
    acc = 0.0
    fk = ERF_SERIES_TERMS + 0.5
    for(i = 0; i < ERF_SERIES_TERMS; i++){
        acc = 2.0 + x2 * acc / fk
        fk -= 1.0
    }
    result = acc * x * exp(-x2).value / sqrtpi
    return result
}

function m_erfc_contfrac(x){
    var x2, a, da, p, p_last, q, q_last, b, result;
    var i

    if(x >= ERFC_CONTFRAC_CUTOFF){
        return 0.0
    }

    x2 = x * x
    a = 0.0
    da = 0.5
    p = 1.0
    p_last = 0.0
    q = da + x2
    q_last = 1.0
    for(i = 0; i < ERFC_CONTFRAC_TERMS; i++){
        var temp
        a += da
        da += 2.0
        b = da + x2
        temp = p; p = b * p - a * p_last; p_last = temp
        temp = q; q = b * q - a * q_last; q_last = temp
    }
    result = p / q * x * exp(-x2).value / sqrtpi
    return result
}
function erf(x){
    var absx,
        cf
    var x1 = float_check(x)
    if(isNaN(x1)){
        return x
    }
    absx = fabs(x)
    if(absx.value < ERF_SERIES_CUTOFF){
        return $B.fast_float(m_erf_series(x1))
    }else{
        cf = m_erfc_contfrac(absx.value)
        return $B.fast_float(x1 > 0.0 ? 1.0 - cf : cf - 1.0)
    }
}

function erfc(x){

    // inspired from
    // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python
    var y = float_check(x)
    var t = 1.0 / (1.0 + 0.5 * Math.abs(y))
    var ans = 1 - t * Math.exp( -y * y - 1.26551223 +
                 t * ( 1.00002368 +
                 t * ( 0.37409196 +
                 t * ( 0.09678418 +
                 t * (-0.18628806 +
                 t * ( 0.27886807 +
                 t * (-1.13520398 +
                 t * ( 1.48851587 +
                 t * (-0.82215223 +
                 t * 0.17087277)))))))))
    if(y >= 0.0){return 1 - ans}
    return 1 + ans
}

function erfc(x){
    $B.check_nb_args_no_kw('erfc', 1, arguments)
    var absx, cf;

    var x1 = float_check(x)
    if(isNaN(x1)){
        return x
    }
    absx = fabs(x);
    if(absx.value < ERF_SERIES_CUTOFF){
        return $B.fast_float(1.0 - m_erf_series(x1))
    }else{
        cf = m_erfc_contfrac(absx.value)
        return $B.fast_float(x1 > 0.0 ? cf : 2.0 - cf)
    }
}

function exp(x){
    $B.check_nb_args('exp', 1, arguments)
    $B.check_no_kw('exp', x)

     if(_b_.float.$funcs.isninf(x)){
         return _b_.float.$factory(0)
     }
     if(_b_.float.$funcs.isinf(x)){
         return INF
     }
     var _r = Math.exp(float_check(x))
     if(! isNaN(_r) && ! isFinite(_r)){
         throw _b_.OverflowError.$factory("math range error")
     }
     return _b_.float.$factory(_r)
}

function exp2(x){
    return pow(2, x)
}

function expm1(x){
    $B.check_nb_args('expm1', 1, arguments)
    $B.check_no_kw('expm1', x)

     if(_b_.float.$funcs.isninf(x)){
         return $B.fast_float(-1)
     }else if(_b_.float.$funcs.isinf(x)){
         return INF
     }
     var _r = Math.expm1(float_check(x))
     if((! isNaN(_r)) && ! isFinite(_r)){
         overflow()
     }
     return $B.fast_float(_r)
}

function fabs(x){
    $B.check_nb_args_no_kw('fabs', 1, arguments)
    return _b_.float.$funcs.fabs(float_check(x)) // located in py_float.js
}

// factorial implementation, adapted from CPython's mathmodule.c

const SmallFactorials = [
    1n, 1n, 2n, 6n, 24n, 120n, 720n, 5040n, 40320n,
    362880n, 3628800n, 39916800n, 479001600n,
    6227020800n, 87178291200n, 1307674368000n,
    20922789888000n, 355687428096000n, 6402373705728000n,
    121645100408832000n, 2432902008176640000n
    ]

const SIZEOF_LONG = 4

function _Py_bit_length(x){
    const BIT_LENGTH_TABLE = [
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
    ]
    var msb = 0;
    while(x >= 32n){
        msb += 6;
        x >>= 6n;
    }
    msb += BIT_LENGTH_TABLE[parseInt(x)];
    return msb
}
function count_set_bits(n){
    var count = 0n;
    while(n != 0){
        ++count;
        n &= n - 1n; /* clear least significant bit */
    }
    return count;
}

function factorial_partial_product(start, stop, max_bits){
    var midpoint,
        num_operands,
        left,
        right,
        result

    /* If the return value will fit an unsigned long, then we can
     * multiply in a tight, fast loop where each multiply is O(1).
     * Compute an upper bound on the number of bits required to store
     * the answer.
     *
     * Storing some integer z requires floor(lg(z))+1 bits, which is
     * conveniently the value returned by bit_length(z).  The
     * product x*y will require at most
     * bit_length(x) + bit_length(y) bits to store, based
     * on the idea that lg product = lg x + lg y.
     *
     * We know that stop - 2 is the largest number to be multiplied.  From
     * there, we have: bit_length(answer) <= num_operands *
     * bit_length(stop - 2)
     */

    num_operands = (stop - start) / 2n;
    max_bits = BigInt(max_bits)
    /* The "num_operands <= 8 * SIZEOF_LONG" check guards against the
     * unlikely case of an overflow in num_operands * max_bits. */
    if(num_operands <= 8 * SIZEOF_LONG &&
        num_operands * max_bits <= 8 * SIZEOF_LONG) {
        var j,
            total;
        for (total = start, j = start + 2n; j < stop; j += 2n){
            total *= j;
        }
        return total
    }

    /* find midpoint of range(start, stop), rounded up to next odd number. */
    midpoint = (start + num_operands) | 1n;
    left = factorial_partial_product(start, midpoint,
                                     _Py_bit_length(midpoint - 2n));
    right = factorial_partial_product(midpoint, stop, max_bits);
    result = left * right
    return result;
}
function factorial_odd_part(n){
    var i,
        v, lower, upper,
        partial, tmp, inner, outer;

    inner = 1n
    outer = inner;
    upper = 3n;
    for (i = BigInt(_Py_bit_length(n)) - 2n; i >= 0; i--) {
        v = n >> i;
        if (v <= 2){
            continue
        }
        lower = upper;
        /* (v + 1) | 1 = least odd integer strictly larger than n / 2**i */
        upper = (v + 1n) | 1n;
        /* Here inner is the product of all odd integers j in the range (0,
           n/2**(i+1)].  The factorial_partial_product call below gives the
           product of all odd integers j in the range (n/2**(i+1), n/2**i]. */
        partial = factorial_partial_product(lower, upper,
                                            _Py_bit_length(upper-2n));
        /* inner *= partial */
        tmp = inner * partial
        inner = tmp;
        /* Now inner is the product of all odd integers j in the range (0,
           n/2**i], giving the inner product in the formula above. */

        /* outer *= inner; */
        tmp = outer * inner
        outer = tmp;
    }
    return outer;
}

function factorial(arg){
    var x,
        two_valuation,
        overflow,
        result,
        odd_part;
    // Check that arg can be converted to an integer, and transform it to
    // a bigint
    x = _b_.int.$to_bigint($B.PyNumber_Index(arg))
    overflow = x > LONG_MAX || x < LONG_MIN
    if(x > LONG_MAX) {
        throw _b_.OverflowError.$factory(
                     "factorial() argument should not exceed " +
                     LONG_MAX)
    }else if(x < 0) {
        throw _b_.ValueError.$factory(
                        "factorial() not defined for negative values");
    }

    /* use lookup table if x is small */
    if (x < SmallFactorials.length){
        return _b_.int.$int_or_long(SmallFactorials[x]);
    }
    /* else express in the form odd_part * 2**two_valuation, and compute as
       odd_part << two_valuation. */
    odd_part = factorial_odd_part(x);
    two_valuation = x - count_set_bits(x);
    return _b_.int.$int_or_long(odd_part << two_valuation);
}

function floor(x){
    $B.check_nb_args_no_kw('floor', 1, arguments)

    if(typeof x == "number" || x.__class__ === _b_.float){
        return Math.floor(float_check(x))
    }
    var klass = $B.get_class(x)
    try{
        return $B.$call($B.$getattr(klass, "__floor__"))(x)
    }catch(err){
        if($B.is_exc(err, [_b_.AttributeError])){
            try{
                var float = $B.$call($B.$getattr(klass, "__float__"))(x)
                return floor(float)
            }catch(err){
                if($B.is_exc(err, [_b_.AttributeError])){
                    throw _b_.TypeError.$factory("no __float__")
                }
                throw err
            }
        }
    }
}

function fmod(x, y){
    $B.check_nb_args_no_kw('fmod', 2, arguments)
    if($B.$isinstance(x, _b_.float)){
        if(_b_.float.$funcs.isinf(x)){
            throw _b_.ValueError.$factory('math domain error')
        }
    }
    y = float_check(y)
    if(y == 0){
        throw _b_.ValueError.$factory('math domain error')
    }
    return _b_.float.$factory(float_check(x) % float_check(y))
}

function frexp(x){
    $B.check_nb_args_no_kw('frexp', 1, arguments)

    var _l = _b_.float.$funcs.frexp(x)
    return _b_.tuple.$factory([_b_.float.$factory(_l[0]), _l[1]])
}

function fsum(x){
    $B.check_nb_args_no_kw('fsum', 1, arguments)

    /* Translation into Javascript of the function msum in an Active
       State Cookbook recipe : https://code.activestate.com/recipes/393090/
       by Raymond Hettinger
    */
    var partials = [],
        res = new Number(),
        _it = _b_.iter(x)
    while(true){
        try{
            var x = _b_.next(_it),
                i = 0
            x = float_check(x)
            for(var j = 0, len = partials.length; j < len; j++){
                var y = float_check(partials[j])
                if(Math.abs(x) < Math.abs(y)){
                    var z = x
                    x = y
                    y = z
                }
                var hi = x + y,
                    lo = y - (hi - x)
                if(lo){
                    partials[i] = lo
                    i++
                }
                x = hi
            }
            partials = partials.slice(0, i).concat([x])
        }catch(err){
            if($B.$isinstance(err, _b_.StopIteration)){break}
            throw err
        }
    }
    var res = 0
    for(var i = 0; i < partials.length; i++){
        res += partials[i]
    }
    return $B.fast_float(res)
}

function gamma(x){
    $B.check_nb_args('gamma', 1, arguments)
    $B.check_no_kw('gamma', x)
    var x_as_number = x,
        r,
        y,
        z,
        sqrtpow

    /* special cases */
    if($B.$isinstance(x, _b_.float)){
        x_as_number = x.value
    }else if(! $B.$isinstance(x, _b_.int)){
        throw _b_.TypeError.$factory("must be real number, not " +
            $B.class_name(x))
    }
    if(x_as_number === Number.POSITIVE_INFINITY || isNaN(x_as_number)){
        return x
    }else if(x_as_number === Number.NEGATIVE_INFINITY || x_as_number == 0){
        throw _b_.ValueError.$factory("math domain error")
    }

    /* integer arguments */
    if(Number.isInteger(x_as_number)){
        if($B.rich_comp('__lt__', x, 0.0)){
            throw _b_.ValueError.$factory("math domain error")
        }
        if($B.rich_comp('__le__', x, NGAMMA_INTEGRAL)){
            return $B.fast_float(gamma_integral[x_as_number - 1])
        }
    }
    var absx = fabs(x)

    /* tiny arguments:  tgamma(x) ~ 1/x for x near 0 */
    if(absx.value < 1e-20){
        r = 1.0 / x_as_number
        if(r === Infinity || r === -Infinity){
            overflow()
        }
        return $B.fast_float(r)
    }

    /* large arguments: assuming IEEE 754 doubles, tgamma(x) overflows for
       x > 200, and underflows to +-0.0 for x < -200, not a negative
       integer. */
    if(absx.value > 200.0){
        if(x_as_number < 0.0){
            return $B.fast_float(0.0 / m_sinpi(x).value);
        }else{
            overflow()
        }
    }

    y = absx.value + lanczos_g_minus_half;
    /* compute error in sum */
    if (absx.value > lanczos_g_minus_half) {
        /* note: the correction can be foiled by an optimizing
           compiler that (incorrectly) thinks that an expression like
           a + b - a - b can be optimized to 0.0.  This shouldn't
           happen in a standards-conforming compiler. */
        var q = y - absx.value;
        z = q - lanczos_g_minus_half;
    }else{
        var q = y - lanczos_g_minus_half;
        z = q - absx.value;
    }
    z = z * lanczos_g / y;
    if (x_as_number < 0.0) {
        r = -pi.value / m_sinpi(absx).value /
                absx.value * _mod.exp(y).value /
                lanczos_sum(absx.value);
        r -= z * r;
        if(absx.value < 140.0){
            r /= pow(y, absx.value - 0.5).value;
        }else{
            sqrtpow = pow(y, absx.value / 2.0 - 0.25);
            r /= sqrtpow.value;
            r /= sqrtpow.value;
        }
    }else{
        r = lanczos_sum(absx.value) / exp(y).value;
        r += z * r;
        if(absx.value < 140.0){
            r *= pow(y, absx.value - 0.5).value;
        }else{
            sqrtpow = pow(y, absx.value / 2.0 - 0.25);
            r *= sqrtpow.value;
            r *= sqrtpow.value;
        }
    }
    if(r === Number.POSITIVE_INFINITY){
        overflow()
    }
    return $B.fast_float(r);
}
// GCD algorithm. Javascript adaptation of Python script at
// https://gist.github.com/cmpute/baa545f0c2b6be8b628e9ded3c19f6c1
// by Jacob Zhong
function bit_length(x){
    return x.toString(2).length
}

$B.nb_simple_gcd = 0

function simple_gcd(a, b){
    /* a fits into a long, so b must too */
    $B.nb_simple_gcd++
    var x = a >= 0 ? a : -a,
        y = b >= 0 ? b : -b

    /* usual Euclidean algorithm for longs */
    while (y != 0) {
        t = y;
        y = x % y;
        x = t;
    }
    return x
}

function lgcd(x, y){
    var a, b, c, d
    if(x < y){
        return lgcd(y, x)
    }
    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),
                    Math.floor(bit_length(y) / 64))),
        xbar = x >> (shift * 64n),
        ybar = y >> (shift * 64n)
    while(y > p2_64){
        [a, b, c, d] = [1n, 0n, 0n, 1n]
        while(ybar + c != 0 && ybar + d != 0){
            q = (xbar + a) / (ybar + c)
            p = (xbar + b) / (ybar + d)
            if(q != p){
                break
            }
            [a, c] = [c, a - q * c]
            [b, d] = [d, b - q * d]
            [xbar, ybar] = [ybar, xbar - q * ybar]
        }
        if(b == 0){
            [x, y] = [y, x % y]
        }else{
            [x, y] = [a * x + b * y, c * x + d * y]
        }
    }
    return simple_gcd(x, y)
}

function xgcd(x, y){
    var xneg = x < 0 ? -1n : 1n,
        yneg = y < 0 ? -1n : 1n,
        last_r,
        last_s,
        last_t,
        q, r, s, t;

    [x, y] = [x >= 0 ? x : -x, y >= 0 ? y : -y];

    // it's maintained that r = s * x + t * y, last_r = last_s * x + last_t * y
    [last_r, r] = [x, y];
    [last_s, s] = [1n, 0n];
    [last_t, t] = [0n, 1n];

    while(r > 0){
        q = last_r / r;
        [last_r, r] = [r, last_r - q * r];
        [last_s, s] = [s, last_s - q * s];
        [last_t, t] = [t, last_t - q * t];
    }
    return [last_r, last_s * xneg, last_t * yneg]
}

function lxgcd(x, y){
    var g, cy, cx,
        s, last_s,
        t, last_t,
        a, b, c, d
    x = x >= 0 ? x : -x
    y = y >= 0 ? y : -y

    if(x < y){
        [g, cy, cx] = xgcd(y, x)
        return [g, cx, cy]
    }

    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),
                Math.floor(bit_length(y) / 64))),
        xbar = x >> (shift * 64n),
        ybar = y >> (shift * 64n);

    [last_s, s] = [1n, 0n];
    [last_t, t] = [0n, 1n];

    while(y > p2_64){
        [a, b, c, d] = [1n, 0n, 0n, 1n]
        while(ybar + c != 0 && ybar + d != 0){
            q = (xbar + a) / (ybar + c)
            p = (xbar + b) / (ybar + d)
            if(q != p){
                break
            };
            [a, c = c], [a - q * c];
            [b, d = d], [b - q * d];
            [xbar, ybar] = [ybar, xbar - q * ybar];
        }
        if(b == 0){
            q = x / y;
            [x, y] = [y, x % y];
            [last_s, s] = [s, last_s - q * s];
            [last_t, t] = [t, last_t - q * t];
        }else{
            [x, y] = [a * x + b * y, c * x + d * y];
            [last_s, s] = [a * last_s + b * s, c * last_s + d * s];
            [last_t, t] = [a * last_t + b * t, c * last_t + d * t];
        }
    }
    // notice that here x, y could be negative
    [g, cx, cy] = xgcd(x, y)

    return [g, cx * last_s + cy * s, cx * last_t + cy * t]
}

function gcd(x, y){
    var $ = $B.args("gcd", 0, {}, [], arguments, {}, 'args', null)
    var args = $.args.map($B.PyNumber_Index)
    if(args.length == 0){
        return 0
    }else if(args.length == 1){
        return _b_.abs(args[0])
    }
    x = _b_.int.$to_bigint(args[0])
    y = _b_.int.$to_bigint(args[1])
    var res = lxgcd(x, y)[0],
        i = 2
    while(i < args.length){
        res = lxgcd(res, _b_.int.$to_bigint(args[i]))[0]
        i++
    }
    return _b_.int.$int_or_long(res)
}
function hypot(x, y){
    var $ = $B.args("hypot", 0, {}, [],
                arguments, {}, "args", null)
    var args = []
    for(var arg of $.args){
        try{
            args.push(float_check(arg))
        }catch(err){
            if($B.is_exc(err, [_b_.ValueError])){
                throw _b_.TypeError.$factory('must be real number, not ' +
                    $B.class_name(arg))
            }
            throw err
        }
    }
    return $B.fast_float(Math.hypot(...args))
}

var inf = INF

function isclose(){
    var $ = $B.args("isclose",
                      4,
                      {a: null, b: null, rel_tol: null, abs_tol: null},
                      ['a', 'b', 'rel_tol', 'abs_tol'],
                      arguments,
                      {rel_tol: $B.fast_float(1e-09),
                       abs_tol: $B.fast_float(0.0)},
                      '*',
                      null)
    var a = float_check($.a),
        b = float_check($.b),
        rel_tol = float_check($.rel_tol),
        abs_tol = float_check($.abs_tol)

    if(rel_tol < 0.0 || abs_tol < 0.0){
        throw _b_.ValueError.$factory('tolerances must be non-negative')
    }

    if(a == b){
        return _b_.True
    }
    if(_b_.float.$funcs.isinf(a) || _b_.float.$funcs.isinf(b)){
        return a === b
    }
    // isclose(a, b, rel_tol, abs_tol) is the same as
    // abs_diff = abs(a - b)
    // max_ab = max(abs(a), abs(b))
    // abs_diff <= abs_tol or abs_diff / max_ab <= rel_tol
    // This is more correct than in Python docs:
    // "abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)"
    // because this fails for Decimal instances, which do not support
    // multiplication by floats

    var diff = b - a,
        abs_diff = Math.abs(diff)
    if(abs_diff <= abs_tol){
        return true
    }
    var abs_a = Math.abs(a),
        abs_b = Math.abs(b),
        max_ab = Math.max(abs_a, abs_b)
    return abs_diff / max_ab <= rel_tol
}

function isfinite(x){
    $B.check_nb_args('isfinite', 1, arguments)
    $B.check_no_kw('isfinite', x)
    return isFinite(float_check(x))
}

function isinf(x){
    $B.check_nb_args('isinf', 1, arguments)
    $B.check_no_kw('isinf', x)
    return _b_.float.$funcs.isinf(x)
}

function isnan(x){
    $B.check_nb_args('isnan', 1, arguments)
    $B.check_no_kw('isnan', x)
    return isNaN(float_check(x))
}

function isqrt(x){
    $B.check_nb_args_no_kw('isqrt', 1, arguments)

    x = $B.PyNumber_Index(x)
    if($B.rich_comp("__lt__", x, 0)){
        throw _b_.ValueError.$factory(
            "isqrt() argument must be nonnegative")
    }
    if(typeof x == "number"){
        return Math.floor(Math.sqrt(x))
    }else{ // big integer
        // adapted from code in mathmodule.c
        var n = x.value,
            bit_length = n.toString(2).length,
            c = BigInt(Math.floor((bit_length - 1) / 2)),
            c_bit_length = c.toString(2).length,
            a = 1n,
            d = 0n,
            e

        for(var s = BigInt(c_bit_length - 1); s >= 0; s--){
            // Loop invariant: (a-1)**2 < (n >> 2*(c - d)) < (a+1)**2
            e = d
            d = c >> s
            a = (a << d - e - 1n) + (n >> 2n*c - e - d + 1n) / a
        }
        return _b_.int.$int_or_long(a - (a * a > n ? 1n : 0n))
    }
}

function lcm(){
    var $ = $B.args("lcm", 0, {}, [], arguments, {}, 'args', null),
        product = 1

    var args = $.args.map($B.PyNumber_Index)
    if(args.length == 0){
        return 1
    }else if(args.length == 1){
        return _b_.abs(args[0])
    }
    var a = _b_.abs(args[0]),
        b,
        product, gcd
    for(var i = 0, len = args.length; i < len; i++){
        b = _b_.abs(args[i])
        if(b == 0){
            return 0
        }
        gcd = gcd2(a, b)
        product = $B.rich_op('__mul__', a, b)
        a = $B.$getattr(product, "__floordiv__")(gcd)
    }
    return a
}

function ldexp(x, i){
    $B.check_nb_args('ldexp', 2, arguments)
    $B.check_no_kw('ldexp', x, i)
    return _b_.float.$funcs.ldexp(x, i)   // in py_float.js
}

function lgamma(x){
    $B.check_nb_args('lgamma', 1, arguments)
    $B.check_no_kw('lgamma', x)

    return m_lgamma(x)
}

function longint_mant_exp(long_int){
    // Returns mantissa and exponent of a long integer
    var value = long_int.value,
        exp = value.toString(2).length,
        exp1 = exp,
        nb = 0n
    // 2 ** exp is infinite if n > 1023
    var nb = Math.floor(exp / 1023),
        exp1 = BigInt(exp - 1023 * nb)
    nb = BigInt(nb)
    var reduced_value = long_int.value / 2n ** (nb * 1023n)
    var mant = Number(reduced_value) / Number(2n ** exp1)
    return [mant, exp]
}

var log10_func = Math.log10 || (x => Math.log(x) / Math.log(10)),
    log2_func = Math.log2 || (x => Math.log(x) / Math.log(2))

function log(x, base){
    var $ = $B.args("log", 2, {x: null, base: null}, ['x', 'base'],
        arguments, {base: _b_.None}, null, null),
        x = $.x,
        base = $.base
    if(base == 10){
        return log10(x)
    }else if(base == 2){
        return log2(x)
    }
    var log
    if($B.$isinstance(x, $B.long_int)){
        if(x.value <= 0){
            throw _b_.ValueError.$factory('math domain error')
        }
        var mant_exp = longint_mant_exp(x)
        log = Math.log(mant_exp[0]) + Math.log(2) * mant_exp[1]
    }else if($B.$isinstance(x, _b_.int)){
        x = _b_.int.$int_value(x)
        if(x <= 0){
            throw _b_.ValueError.$factory('math domain error')
        }
        log = Math.log(x)
    }else{
        var x1 = float_check(x)
        if(x1 <= 0){
            throw _b_.ValueError.$factory('math domain error')
        }
        log = Math.log(x1)
    }
    if(x1 <= 0){
        throw _b_.ValueError.$factory("math domain error")
    }
    if(base === _b_.None){
        return $B.fast_float(log)
    }
    var denom = _mod.log(base).value
    if(denom == 0){
        throw _b_.ZeroDivisionError.$factory('float division by zero')
    }
    return $B.fast_float(log / denom)
}

function log1p(x){
    $B.check_nb_args('log1p', 1, arguments)
    $B.check_no_kw('log1p', x)
    if($B.$isinstance(x, $B.long_int)){
        if($B.long_int.bit_length(x) > 1024){
            throw _b_.OverflowError.$factory(
                "int too large to convert to float")
        }
        x = $B.long_int.$log2($B.fast_long_int(x.value + 1n))
        return $B.fast_float(Number(x.value) * Math.LN2)
    }
    x = float_check(x)
    if(x + 1 <= 0){
        throw _b_.ValueError.$factory("math domain error")
    }
    return $B.fast_float(Math.log1p(x))
}

function log2(x){
    $B.check_nb_args('log2', 1, arguments)
    $B.check_no_kw('log2', x)
    var log2_func = Math.log2 || (x => Math.log(x) / Math.LN2)
    if($B.$isinstance(x, $B.long_int)){
        if(x.value <= 0){
            throw _b_.ValueError.$factory('math domain error')
        }
        var mant_exp = longint_mant_exp(x)
        return $B.fast_float(log2_func(mant_exp[0]) + mant_exp[1])
    }
    if(_b_.float.$funcs.isninf(x)){
        throw _b_.ValueError.$factory('')
    }
    x = float_check(x)
    if(x == 0){
        throw _b_.ValueError.$factory("math domain error")
    }
    if(isNaN(x)){
        return _b_.float.$factory('nan')
    }
    if(x < 0.0){
        throw _b_.ValueError.$factory('math domain error')
    }
    return $B.fast_float(log2_func(x))
}

function log10(x){
    $B.check_nb_args('log10', 1, arguments)
    $B.check_no_kw('log10', x)
    if($B.$isinstance(x, $B.long_int)){
        return $B.fast_float($B.long_int.$log10(x).value)
    }
    x = float_check(x)
    if(x <= 0){
        throw _b_.ValueError.$factory("math domain error")
    }
    return $B.fast_float(Math.log10(x))
}

function modf(x){
    $B.check_nb_args('modf', 1, arguments)
    $B.check_no_kw('modf', x)

    if(_b_.float.$funcs.isninf(x)){
        return _b_.tuple.$factory([0.0, NINF])
    }
    if(_b_.float.$funcs.isinf(x)){
        return _b_.tuple.$factory([0.0, INF])
    }
    var x1 = float_check(x)

    if(isNaN(x1)){
        return _b_.tuple.$factory([_b_.float.$factory('nan'),
            _b_.float.$factory('nan')])
    }

    if(x1 > 0){
       var i = _b_.float.$factory(x1 - Math.floor(x1))
       return _b_.tuple.$factory([i, _b_.float.$factory(x1 - i.value)])
    }

    var x2 = Math.ceil(x1)
    var i = _b_.float.$factory(x1 - x2)
    return _b_.tuple.$factory([i, _b_.float.$factory(x2)])
}

var nan = _b_.float.$factory('nan')

function _nextafter(x, y){
    // always returns a Javascript number
    if($B.rich_comp('__lt__', y, x)){
        var nu = nextUp($B.rich_op('__mul__', -1, x))
        return -nu
    }else if($B.rich_comp('__gt__', y, x)){
        return nextUp(x)
    }else{
        var res = x !== x ? x : y
        res = typeof res == 'number' ? res : res.value
        return res
    }
}

function make_float(x){
    return typeof x == 'number' ? $B.fast_float(x) : x
}

function make_number(x){
    return typeof x == 'number' ? x : x.value
}

function doubleToByteArray(number) {
    // adapted from https://stackoverflow.com/questions/
    // 25942516/double-to-byte-array-conversion-in-javascript
    var buffer = new ArrayBuffer(8);         // JS numbers are 8 bytes long, or 64 bits
    var longNum = new Float64Array(buffer);  // so equivalent to Float64

    longNum[0] = number;

    return Array.from(new Uint8Array(buffer)).reverse();  // reverse to get little endian
}

function byteArrayToDouble(bytearray) {
    // adapted from https://stackoverflow.com/questions/
    // 42699162/javascript-convert-array-of-4-bytes-into-a-float-value-from-modbustcp-read
    // Create a buffer
    var buf = new ArrayBuffer(8);
    // Create a data view of it
    var view = new DataView(buf);

    // set bytes
    bytearray.forEach(function (b, i) {
        view.setUint8(i, b);
    });

    // Read the bits as a float
    var num = view.getFloat64(0);
    // Done
    return num
}

function addSteps(array, steps){
    // convert to BigInt, avoids issue when steps >= 2 ** 32
    if(steps.__class__ == $B.long_int){
        steps = steps.value
    }else{
        steps = BigInt(steps)
    }
    var positive = steps > 0n
    if(steps < 0n){
        steps = -steps
    }
    var x1 = steps >> 32n,
        x2 = steps - x1 * 2n ** 32n
    var buffer = new ArrayBuffer(8)
    var longStep = new BigInt64Array(buffer)
    longStep[0] = steps
    var stepArray = Array.from(new Uint8Array(buffer)).reverse()
    if(positive){
        var carry = 0
        for(var i = 7; i >= 0; i--){
            array[i] += stepArray[i] + carry
            if(array[i] > 255){
                carry = 1
                array[i] -= 256
            }else{
                carry = 0
            }
        }
    }else{
        var carry = 0
        for(var i = 7; i >= 0; i--){
            array[i] -= stepArray[i] - carry
            if(array[i] < 0){
                carry = -1
                array[i] += 256
            }else{
                carry = 0
            }
        }
    }
}

function nextafter(){
    var $ = $B.args("nextafter", 3, {x: null, y: null, steps: null},
                ['x', 'y', 'steps'], arguments, {steps: _b_.None}, null, null),
        x = $.x,
        y = $.y,
        steps = $.steps
    if(! $B.$isinstance(x, [_b_.int, _b_.float])){
        throw _b_.TypeError.$factory('must be a real number, not ' +
            $B.class_name(x))
    }
    if(! $B.$isinstance(y, [_b_.int, _b_.float])){
        throw _b_.TypeError.$factory('must be a real number, not ' +
            $B.class_name(y))
    }
    if(isnan(x)){
        return make_float(x)
    }
    if(isnan(y)){
        return make_float(y)
    }
    if(steps === _b_.None){
        return $B.fast_float(_nextafter(x, y))
    }
    steps = $B.PyNumber_Index(steps);
    if(steps < 0) {
        throw _b_.ValueError.$factory(
                        "steps must be a non-negative integer");
    }
    if(steps == 0){
        return make_float(x)
    }
    if(isnan(x)){
        return make_float(x)
    }
    if(isnan(y)){
        return make_float(y)
    }
    var x1 = make_number(x),
        y1 = make_number(y)

    if(y1 == x1){
        return make_float(y)
    }else if(y1 > x1){
        var x_uint64 = doubleToByteArray(x1)
        addSteps(x_uint64, steps)
        var res = byteArrayToDouble(x_uint64)
        return res >= y1 ? y : make_float(res)
    }else{
        var x_uint64 = doubleToByteArray(x1)
        addSteps(x_uint64, -steps)
        var res = byteArrayToDouble(x_uint64)
        return res <= y1 ? y : make_float(res)
    }
}

function perm(n, k){
    var $ = $B.args("perm", 2, {n: null, k: null}, ['n', 'k'],
                    arguments, {k: _b_.None}, null, null),
        n = $.n,
        k = $.k

    if(k === _b_.None){
        check_int(n)
        return _mod.factorial(n)
    }
    // raise TypeError if n or k is not an integer
    n = $B.PyNumber_Index(n)
    k = $B.PyNumber_Index(k)

    // transform to Javascript BigInt
    var n1 = _b_.int.$to_bigint(n),
        k1 = _b_.int.$to_bigint(k);

    if(k1 < 0){
        throw _b_.ValueError.$factory("k must be a non-negative integer")
    }
    if(n1 < 0){
        throw _b_.ValueError.$factory("n must be a non-negative integer")
    }
    if(k1 == 0){
        return 1
    }
    if(k1 == 1){
        return n
    }
    if(k1 == 2){
        return _b_.int.$int_or_long(n1 * (n1 - 1n))
    }
    if(k1 > n1){
        return 0
    }
    // Evaluates to n! / (n - k)!
    var fn = _mod.factorial(n),
        fn_k = _mod.factorial(n - k)
    return $B.rich_op('__floordiv__', fn, fn_k)
}

const pi = $B.fast_float(Math.PI)

function pow(){
    var $ = $B.args("pow", 2, {base: null, exp: null}, ['base', 'exp'],
                arguments, {}, null, null),
        x = $.base,
        y = $.exp

    var x1 = float_check(x)
    var y1 = float_check(y)

    if(y1 == 0){
        return _b_.float.$factory(1)
    }
    if(x1 == 0 && y1 < 0){
        if(y1 === -Infinity){
            return INF
        }
        throw _b_.ValueError.$factory('math domain error')
    }
    if(isFinite(x1) && x1 < 0 && isFinite(y1) && ! Number.isInteger(y1)){
        throw _b_.ValueError.$factory('math domain error')
    }

    if(isNaN(y1)){
        if(x1 == 1){return _b_.float.$factory(1)}
        return NAN
    }
    if(x1 == 0){
        return ZERO
    }

    if(_b_.float.$funcs.isninf(y)){
        if(_b_.float.$funcs.isinf(x)){ // pow(INF, NINF) = 0.0
            return ZERO
        }else if(_b_.float.$funcs.isninf(x)){ // pow(NINF, NINF) = 0.0
            return ZERO
        }
        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}
        if(x1 < 1 && x1 > -1){return INF}
        return ZERO
    }
    if(_b_.float.$funcs.isinf(y)){
        if(_b_.float.$funcs.isinf(x)){ // pow(INF, INF)
            return INF
        }
        if(_b_.float.$funcs.isninf(x)){
            return INF
        }
        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}
        if(x1 < 1 && x1 > -1){return ZERO}
        return INF
    }

    if(isNaN(x1)){return _b_.float.$factory('nan')}
    if(_b_.float.$funcs.isninf(x)){
        if(y1 > 0 && isOdd(y1)){return NINF}
        if(y1 > 0){return INF}  // this is even or a float
        if(y1 < 0){return ZERO}
        if(_b_.float.$float.isinf(y)){return INF}
        return _b_.float.$factory(1)
    }

    if(_b_.float.$funcs.isinf(x)){
        if(y1 > 0){return INF}
        if(y1 < 0){return ZERO}
        return _b_.float.$factory(1)
    }

    var r = Math.pow(x1, y1)
    if(isNaN(r)){
        return NAN
    }
    if(! isFinite(r)){
        overflow()
    }
    return _b_.float.$factory(r)
}

function prod(){
    var $ = $B.args("prod", 1, {iterable:null, start:null},
                    ["iterable", "start"], arguments, {start: 1}, "*",
                    null),
        iterable = $.iterable,
        start = $.start
    var res = start,
        it = _b_.iter(iterable),
        x
    while(true){
        try{
            x = _b_.next(it)
            if(x == 0){
                return 0
            }
            res = $B.rich_op('__mul__', res, x)
        }catch(err){
            if(err.__class__ === _b_.StopIteration){
                return res
            }
            throw err
        }
    }
}

function radians(x){
    $B.check_nb_args('radians', 1, arguments)
    $B.check_no_kw('radians', x)

    return _b_.float.$factory(float_check(x) * Math.PI / 180)
}

function is_finite(x){
    return typeof x == "number" ||
               (x.__class__ === _b_.floar && isFinite(x.value)) ||
               $B.$isinstance(x, _b_.int) ||
               ($B.$isinstance(x, _b_.float) && isFinite(x.value))
}

function remainder(x, y){
    $B.check_nb_args_no_kw('remainder', 2, arguments)
    float_check(x) // might raise TypeError
    /* Deal with most common case first. */
    if(is_finite(x) && is_finite(y)){
        var absx,
            absy,
            c,
            m,
            r;

        if(float_check(y) == 0.0){
            throw _b_.ValueError.$factory("math domain error")
        }

        absx = fabs(x);
        absy = fabs(y);
        m = fmod(absx, absy);

        c = absy.value - m.value
        if(m.value < c){
            r = m.value
        }else if(m.value > c){
            r = -c
        }else{
            r = m.value -
                    2.0 * fmod($B.fast_float(0.5 * (absx.value - m.value)), absy).value;
        }
        return $B.fast_float(copysign(1.0, x).value * r);
    }

    /* Special values. */
    if(float_check(y) == 0){
        if(isnan(x)){
            return x
        }
    }
    if(isinf(x)){
        if(isnan(y)){
            return y
        }
        throw _b_.ValueError.$factory("math domain error")
    }
    if(isnan(y)){
        return y;
    }
    return x;
}

function sin(x){
    $B.check_nb_args('sin ', 1, arguments)
    $B.check_no_kw('sin ', x)
    return _b_.float.$factory(Math.sin(float_check(x)))
}

function sinh(x) {
    $B.check_nb_args('sinh', 1, arguments)
    $B.check_no_kw('sinh', x)

    var y = float_check(x)
    if(Math.sinh !== undefined){
        return _b_.float.$factory(Math.sinh(y))
    }
    return _b_.float.$factory(
        (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)
}

function sqrt(x){
    $B.check_nb_args('sqrt ', 1, arguments)
    $B.check_no_kw('sqrt ', x)

    if(_b_.float.$funcs.isninf(x)){
        value_error()
    }else if(_b_.float.$funcs.isinf(x)){
        return INF
    }
    var y = float_check(x)
    if(y < 0){
        value_error()
    }
    var _r = $B.fast_float(Math.sqrt(y))
    if(_b_.float.$funcs.isinf(_r)){
        overflow()
    }
    return _r
}

/*[clinic input]
math.sumprod

    p: object
    q: object
    /

Return the sum of products of values from two iterables p and q.

Roughly equivalent to:

    sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))

For float and mixed int/float inputs, the intermediate products
and sums are computed with extended precision.
[clinic start generated code]*/

const tl_zero = {hi: 0, lo: 0, tiny: 0}

function _check_long_mult_overflow(a, b) {

    /* From Python2's int_mul code:

    Integer overflow checking for * is painful:  Python tried a couple ways, but
    they didn't work on all platforms, or failed in endcases (a product of
    -sys.maxint-1 has been a particular pain).

    Here's another way:

    The native long product x*y is either exactly right or *way* off, being
    just the last n bits of the true product, where n is the number of bits
    in a long (the delivered product is the true product plus i*2**n for
    some integer i).

    The native double product (double)x * (double)y is subject to three
    rounding errors:  on a sizeof(long)==8 box, each cast to double can lose
    info, and even on a sizeof(long)==4 box, the multiplication can lose info.
    But, unlike the native long product, it's not in *range* trouble:  even
    if sizeof(long)==32 (256-bit longs), the product easily fits in the
    dynamic range of a double.  So the leading 50 (or so) bits of the double
    product are correct.

    We check these two ways against each other, and declare victory if they're
    approximately the same.  Else, because the native long product is the only
    one that can lose catastrophic amounts of information, it's the native long
    product that must have overflowed.

    */

    /*

    var longprod = (long)((unsigned long)a * b);
    double doubleprod = (double)a * (double)b;
    double doubled_longprod = (double)longprod;

    if (doubled_longprod == doubleprod) {
        return 0;
    }

    const double diff = doubled_longprod - doubleprod;
    const double absdiff = diff >= 0.0 ? diff : -diff;
    const double absprod = doubleprod >= 0.0 ? doubleprod : -doubleprod;

    if (32.0 * absdiff <= absprod) {
        return 0;
    }

    return 1;
    */
    return 0
}

function long_add_would_overflow(a, b){
    return (a > 0n) ? (b > BigInt(LONG_MAX) - a) : (b < BigInt(LONG_MIN) - a);
}

function PyLong_CheckExact(n){
    return typeof n == 'number' || n.__class__ === $B.long_int
}

/*
   The default implementation of dl_mul() depends on the C math library
   having an accurate fma() function as required by  7.12.13.1 of the
   C99 standard.

   The UNRELIABLE_FMA option is provided as a slower but accurate
   alternative for builds where the fma() function is found wanting.
   The speed penalty may be modest (17% slower on an Apple M1 Max),
   so don't hesitate to enable this build option.

   The algorithms are from the T. J. Dekker paper:
   A Floating-Point Technique for Extending the Available Precision
   https://csclub.uwaterloo.ca/~pbarfuss/dekker1971.pdf
*/

function dl_split(x) {
    // Dekker (5.5) and (5.6).
    var t = x * 134217729.0;  // Veltkamp constant = 2.0 ** 27 + 1
    var hi = t - (t - x);
    var lo = x - hi;
    return {hi, lo};
}

function dl_mul(x, y){
    // Dekker (5.12) and mul12()
    var xx = dl_split(x);
    var yy = dl_split(y);
    var p = xx.hi * yy.hi;
    var q = xx.hi * yy.lo + xx.lo * yy.hi;
    var z = p + q;
    var zz = p - z + q + xx.lo * yy.lo;
    return {hi: z, lo:  zz};
}

function dl_sum(a, b){
    /* Algorithm 3.1 Error-free transformation of the sum */
    var x = a + b;
    var z = x - a;
    var y = (a - (x - z)) + (b - z);
    return {hi: x, lo: y};
}

function tl_fma(x, y, total){
    /* Algorithm 5.10 with SumKVert for K=3 */
    var pr = dl_mul(x, y);
    var sm = dl_sum(total.hi, pr.hi);
    var r1 = dl_sum(total.lo, pr.lo);
    var r2 = dl_sum(r1.hi, sm.lo);
    return {hi: sm.hi, lo: r2.hi, tiny: total.tiny + r1.lo + r2.lo}
}

function tl_to_d(total){
    var last = dl_sum(total.lo, total.hi);
    return total.tiny + last.lo + last.hi;
}

function sumprod(p, q){
    var $ = $B.args('sumprod', 2, {p: null, q: null}, ['p', 'q'],
            arguments, {}, null, null)
    var p_i = NULL,
        q_i = NULL,
        term_i = NULL,
        new_total = NULL;
    var p_it, q_it, total;
    var p_next, q_next;
    var p_stopped = false, q_stopped = false;
    var int_path_enabled = true,
        int_total_in_use = false;
    var flt_path_enabled = true,
        flt_total_in_use = false;
    var int_total = 0n;
    var flt_total = tl_zero;

    p_it = $B.make_js_iterator(p);
    q_it = $B.make_js_iterator(q);
    total = 0
    p_next = p_it.next
    q_next = q_it.next
    while (1) {
        var finished;
        p_i = p_it.next()
        if (p_i.done) {
            /*
            if (PyErr_Occurred()) {
                if (!PyErr_ExceptionMatches(PyExc_StopIteration)) {
                    goto err_exit;
                }
                PyErr_Clear();
            }
            */
            p_stopped = true;
        }else{
            p_i = p_i.value
        }
        q_i = q_it.next()
        if (q_i.done) {
            /*
            if (PyErr_Occurred()) {
                if (!PyErr_ExceptionMatches(PyExc_StopIteration)) {
                    goto err_exit;
                }
                PyErr_Clear();
            }
            */
            q_stopped = true;
        }else{
            q_i = q_i.value
        }
        if (p_stopped != q_stopped) {
            throw _b_.ValueError.$factory("Inputs are not the same length");
        }

        finished = p_stopped & q_stopped;

        if (int_path_enabled) {

            if (! finished && PyLong_CheckExact(p_i) & PyLong_CheckExact(q_i)) {
                var overflow;
                var int_p, int_q, int_prod;

                int_p = _b_.int.$to_bigint($B.PyNumber_Index(p_i))
                overflow = int_p > LONG_MAX || int_p < LONG_MIN

                if (overflow) {
                    finalize_int_path()
                }
                int_q = _b_.int.$to_bigint($B.PyNumber_Index(q_i));
                overflow = int_q > LONG_MAX || int_q < LONG_MIN
                if (overflow) {
                    finalize_int_path()
                }
                if (_check_long_mult_overflow(int_p, int_q)) {
                    finalize_int_path()
                }
                int_prod = int_p * int_q;
                if (long_add_would_overflow(int_total, int_prod)) {
                    finalize_int_path()
                }
                if(int_path_enabled){
                    int_total = int_total + int_prod;
                    int_total_in_use = true;
                    continue;
                }
            }

            if(finished){
                finalize_int_path()
            }

          function finalize_int_path(){
            // We're finished, overflowed, or have a non-int
            int_path_enabled = false;
            if (int_total_in_use) {
                term_i = _b_.int.$int_or_long(int_total);
                new_total = $B.rich_op('__add__', total, term_i);
                total = new_total
                new_total = NULL;
                int_total = 0;   // An ounce of prevention, ...
                int_total_in_use = false;
            }
          }
        }

        if (flt_path_enabled) {

            if (!finished) {
                var flt_p, flt_q;
                var p_type_float = p_i.__class__ === _b_.float;
                var q_type_float = q_i.__class__ === _b_.float
                if(p_type_float && q_type_float) {
                    flt_p = p_i;
                    flt_q = q_i;
                }else if (p_type_float && (PyLong_CheckExact(q_i) ||
                                           typeof q_i == 'boolean')){
                    /* We care about float/int pairs and int/float pairs because
                       they arise naturally in several use cases such as price
                       times quantity, measurements with integer weights, or
                       data selected by a vector of bools. */
                    flt_p = p_i
                    flt_q = _b_.int.$int_value(q_i)
                }else if(q_type_float && (PyLong_CheckExact(p_i) ||
                                          typeof p_i == 'boolean')) {
                    flt_q = q_i
                    flt_p = _b_.int.$int_value(p_i)
                }else{
                    finalize_flt_path()
                }
                if(flt_path_enabled){
                    var new_flt_total = tl_fma(flt_p.value, flt_q.value, flt_total);
                    if (isfinite(new_flt_total.hi)) {
                        flt_total = new_flt_total;
                        flt_total_in_use = true;
                        continue;
                    }
                }
            }
            if(finished){
                finalize_flt_path()
            }

          function finalize_flt_path(){
            // We're finished, overflowed, have a non-float, or got a non-finite value
            flt_path_enabled = false;
            if(flt_total_in_use){
                term_i = $B.fast_float(tl_to_d(flt_total));
                if (term_i == NULL) {
                    err_exit()
                }
                new_total = $B.rich_op('__add__', total, term_i);
                total = new_total
                new_total = NULL
                flt_total = tl_zero;
                flt_total_in_use = false;
            }
          }
        }

        if (finished) {
            return total
        }
        term_i = $B.rich_op('__mul__', p_i, q_i);
        new_total = $B.rich_op('__add__', total, term_i);
        total = new_total
        new_total = NULL;
    }

}
function tan(x) {
    $B.check_nb_args('tan', 1, arguments)
    $B.check_no_kw('tan', x)

    var y = float_check(x)
    return _b_.float.$factory(Math.tan(y))
}

function tanh(x) {
    $B.check_nb_args('tanh', 1, arguments)
    $B.check_no_kw('tanh', x)

    var y = float_check(x)
    if(Math.tanh !== undefined){return _b_.float.$factory(Math.tanh(y))}
    return _b_.float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/
         (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))
}

const tau = $B.fast_float(2 * Math.PI)

function trunc(x) {
    $B.check_nb_args('trunc', 1, arguments)
    $B.check_no_kw('trunc', x)

   try{return $B.$getattr(x, '__trunc__')()}catch(err){}
   var x1 = float_check(x)
   if(!isNaN(parseFloat(x1)) && isFinite(x1)){
      if(Math.trunc !== undefined){return _b_.int.$factory(Math.trunc(x1))}
      if(x1 > 0){return _b_.int.$factory(Math.floor(x1))}
      return _b_.int.$factory(Math.ceil(x1))  // x1 < 0
   }
   throw _b_.ValueError.$factory(
       'object is not a number and does not contain __trunc__')
}

function ulp(){
    var $ = $B.args("ulp", 1, {x: null}, ['x'], arguments, {}, null, null),
        x = $.x
    if($B.$isinstance(x, _b_.float)){
        if(_b_.float.$funcs.isinf(x)){
            return _mod.inf
        }else if(_b_.float.$funcs.isnan(x)){
            return _mod.nan
        }
    }
    if(typeof x == "number"){
        return x >= 0 ? $B.fast_float(nextUp(x) - x) :
                       $B.fast_float(x - (-nextUp(-x)))
    }else if($B.$isinstance(x, $B.long_int)){
        x = Number(_b_.int.$to_bigint(x))
        return x > 0 ? $B.fast_float(nextUp(x) - x) :
                       $B.fast_float(x - (-nextUp(-x)))
    }else{
        if($B.rich_comp('__ge__', x, 0)){
            return $B.rich_op('__sub__', $B.fast_float(nextUp(x.value)), x)
        }else{
            var neg_x = $B.$call($B.$getattr(x, "__neg__"))()
            return $B.rich_op('__sub__', x,
                $B.$call($B.$getattr($B.fast_float(nextUp(neg_x.value)), '__neg__'))())
        }
    }
}

var _mod = {
    acos,
    acosh,
    asin,
    asinh,
    atan,
    atan2,
    atanh,
    cbrt,
    ceil,
    comb,
    copysign,
    cos,
    cosh,
    degrees,
    dist,
    e,
    erf,
    erfc,
    exp,
    exp2,
    expm1,
    fabs,
    factorial,
    floor,
    fmod,
    frexp,
    fsum,
    gamma,
    gcd,
    hypot,
    inf,
    isclose,
    isfinite,
    isinf,
    isnan,
    isqrt,
    lcm,
    ldexp,
    lgamma,
    log,
    log1p,
    log2,
    log10,
    modf,
    nan,
    nextafter,
    perm,
    pi,
    pow,
    prod,
    radians,
    remainder,
    sin,
    sinh,
    sqrt,
    sumprod,
    tan,
    tanh,
    tau,
    trunc,
    ulp
}

for(var $attr in _mod){
    if(typeof _mod[$attr] === 'function'){
        _mod[$attr].__class__ = $B.builtin_function_or_method
    }
}

$B.addToImported('math', _mod)

})(__BRYTHON__)
====math.js(file) end====

====os.py(module) start====
''
import abc
import sys

error=OSError
name='posix'
linesep='\n'

from posix import *
import posixpath as path

sys.modules['os.path']=path
from os.path import(curdir,pardir,sep,pathsep,defpath,extsep,altsep,
devnull)

environ={'HOME':__BRYTHON__.curdir,
'PYTHONPATH':__BRYTHON__.brython_path
}

SEEK_SET=0
SEEK_CUR=1
SEEK_END=2
class terminal_size:

 def __init__(self,fileno):
  self.columns=120
  self.lines=30
def get_terminal_size(*args):
 return terminal_size(None)
def _get_exports_list(module):
 try:
  return list(module.__all__)
 except AttributeError:
  return[n for n in dir(module)if n[0]!='_']
def getenv(key,default=None):
 ''
 return environ.get(key,default)
supports_bytes_environ=True

def chdir(path):
 __BRYTHON__.curdir=path
def fsencode(filename):
 ''
 encoding=sys.getfilesystemencoding()
 errors='surrogateescape'
 if isinstance(filename,bytes):
  return filename
 elif isinstance(filename,str):
  return filename.encode(encoding,errors)
 else:
  raise TypeError("expect bytes or str, not %s"%type(filename).__name__)
def fsdecode(filename):
 ''
 encoding=sys.getfilesystemencoding()
 errors='surrogateescape'
 if isinstance(filename,str):
  return filename
 elif isinstance(filename,bytes):
  return filename.decode(encoding,errors)
 else:
  raise TypeError("expect bytes or str, not %s"%type(filename).__name__)
def fspath(path):
 if isinstance(path,[str,bytes]):
  return path
 return path.__fspath__()
def getcwd():
 return __BRYTHON__.curdir
class PathLike(abc.ABC):

 ''
 @abc.abstractmethod
 def __fspath__(self):
  ''
  raise NotImplementedError
 @classmethod
 def __subclasshook__(cls,subclass):
  return hasattr(subclass,'__fspath__')
if name =='nt':
 class _AddedDllDirectory:
  def __init__(self,path,cookie,remove_dll_directory):
   self.path=path
   self._cookie=cookie
   self._remove_dll_directory=remove_dll_directory
  def close(self):
   self._remove_dll_directory(self._cookie)
   self.path=None
  def __enter__(self):
   return self
  def __exit__(self,*args):
   self.close()
  def __repr__(self):
   if self.path:
    return "<AddedDllDirectory({!r})>".format(self.path)
   return "<AddedDllDirectory()>"
 def add_dll_directory(path):
  ''
  import nt
  cookie=nt._add_dll_directory(path)
  return _AddedDllDirectory(
  path,
  cookie,
  nt._remove_dll_directory
  )
def scandir(*args,**kw):
 raise NotImplementedError('browsers cannot read a directory content')
def waitstatus_to_exitcode(status):
 return status >>8
_set=set()

supports_dir_fd=_set

supports_effective_ids=_set

supports_fd=_set

supports_follow_symlinks=_set

====os.py(module) end====

====pathlib.py(module) start====
''
import fnmatch
import functools
import io
import ntpath
import os
import posixpath
import re
import sys
import warnings
from _collections_abc import Sequence
from errno import ENOENT,ENOTDIR,EBADF,ELOOP
from stat import S_ISDIR,S_ISLNK,S_ISREG,S_ISSOCK,S_ISBLK,S_ISCHR,S_ISFIFO
from urllib.parse import quote_from_bytes as urlquote_from_bytes
__all__=[
"PurePath","PurePosixPath","PureWindowsPath",
"Path","PosixPath","WindowsPath",
]
_WIN_RESERVED_NAMES=frozenset(
{'CON','PRN','AUX','NUL','CONIN$','CONOUT$'}|
{f'COM{c}'for c in '123456789\xb9\xb2\xb3'}|
{f'LPT{c}'for c in '123456789\xb9\xb2\xb3'}
)

_WINERROR_NOT_READY=21
_WINERROR_INVALID_NAME=123
_WINERROR_CANT_RESOLVE_FILENAME=1921
_IGNORED_ERRNOS=(ENOENT,ENOTDIR,EBADF,ELOOP)

_IGNORED_WINERRORS=(
_WINERROR_NOT_READY,
_WINERROR_INVALID_NAME,
_WINERROR_CANT_RESOLVE_FILENAME)

def _ignore_error(exception):
 return(getattr(exception,'errno',None)in _IGNORED_ERRNOS or
 getattr(exception,'winerror',None)in _IGNORED_WINERRORS)
@functools.cache
def _is_case_sensitive(flavour):
 return flavour.normcase('Aa')=='Aa'
_FNMATCH_PREFIX,_FNMATCH_SUFFIX=fnmatch.translate('_').split('_')
_FNMATCH_SLICE=slice(len(_FNMATCH_PREFIX),-len(_FNMATCH_SUFFIX))
_SWAP_SEP_AND_NEWLINE={
'/':str.maketrans({'/':'\n','\n':'/'}),
'\\':str.maketrans({'\\':'\n','\n':'\\'}),
}
@functools.lru_cache()
def _make_selector(pattern_parts,flavour,case_sensitive):
 pat=pattern_parts[0]
 if not pat:
  return _TerminatingSelector()
 if pat =='**':
  child_parts_idx=1
  while child_parts_idx <len(pattern_parts)and pattern_parts[child_parts_idx]=='**':
   child_parts_idx +=1
  child_parts=pattern_parts[child_parts_idx:]
  if '**'in child_parts:
   cls=_DoubleRecursiveWildcardSelector
  else:
   cls=_RecursiveWildcardSelector
 else:
  child_parts=pattern_parts[1:]
  if pat =='..':
   cls=_ParentSelector
  elif '**'in pat:
   raise ValueError("Invalid pattern: '**' can only be an entire path component")
  else:
   cls=_WildcardSelector
 return cls(pat,child_parts,flavour,case_sensitive)
@functools.lru_cache(maxsize=256)
def _compile_pattern(pat,case_sensitive):
 flags=re.NOFLAG if case_sensitive else re.IGNORECASE
 return re.compile(fnmatch.translate(pat),flags).match
@functools.lru_cache()
def _compile_pattern_lines(pattern_lines,case_sensitive):
 ''
 parts=['^']
 for part in pattern_lines.splitlines(keepends=True):
  if part =='*\n':
   part=r'.+\n'
  elif part =='*':
   part=r'.+'
  else:
   part=fnmatch.translate(part)[_FNMATCH_SLICE]
  parts.append(part)
 parts.append(r'\Z')
 flags=re.MULTILINE
 if not case_sensitive:
  flags |=re.IGNORECASE
 return re.compile(''.join(parts),flags=flags)
class _Selector:
 ''
 def __init__(self,child_parts,flavour,case_sensitive):
  self.child_parts=child_parts
  if child_parts:
   self.successor=_make_selector(child_parts,flavour,case_sensitive)
   self.dironly=True
  else:
   self.successor=_TerminatingSelector()
   self.dironly=False
 def select_from(self,parent_path):
  ''
  path_cls=type(parent_path)
  scandir=path_cls._scandir
  if not parent_path.is_dir():
   return iter([])
  return self._select_from(parent_path,scandir)
class _TerminatingSelector:

 def _select_from(self,parent_path,scandir):
  yield parent_path
class _ParentSelector(_Selector):

 def __init__(self,name,child_parts,flavour,case_sensitive):
  _Selector.__init__(self,child_parts,flavour,case_sensitive)
 def _select_from(self,parent_path,scandir):
  path=parent_path._make_child_relpath('..')
  for p in self.successor._select_from(path,scandir):
   yield p
class _WildcardSelector(_Selector):

 def __init__(self,pat,child_parts,flavour,case_sensitive):
  _Selector.__init__(self,child_parts,flavour,case_sensitive)
  if case_sensitive is None:
   case_sensitive=_is_case_sensitive(flavour)
  self.match=_compile_pattern(pat,case_sensitive)
 def _select_from(self,parent_path,scandir):
  try:
   with scandir(parent_path)as scandir_it:
    entries=list(scandir_it)
  except OSError:
   pass
  else:
   for entry in entries:
    if self.dironly:
     try:
      if not entry.is_dir():
       continue
     except OSError:
      continue
    name=entry.name
    if self.match(name):
     path=parent_path._make_child_relpath(name)
     for p in self.successor._select_from(path,scandir):
      yield p
class _RecursiveWildcardSelector(_Selector):

 def __init__(self,pat,child_parts,flavour,case_sensitive):
  _Selector.__init__(self,child_parts,flavour,case_sensitive)
 def _iterate_directories(self,parent_path):
  yield parent_path
  for dirpath,dirnames,_ in parent_path.walk():
   for dirname in dirnames:
    yield dirpath._make_child_relpath(dirname)
 def _select_from(self,parent_path,scandir):
  successor_select=self.successor._select_from
  for starting_point in self._iterate_directories(parent_path):
   for p in successor_select(starting_point,scandir):
    yield p
class _DoubleRecursiveWildcardSelector(_RecursiveWildcardSelector):
 ''
 def _select_from(self,parent_path,scandir):
  yielded=set()
  try:
   for p in super()._select_from(parent_path,scandir):
    if p not in yielded:
     yield p
     yielded.add(p)
  finally:
   yielded.clear()
class _PathParents(Sequence):
 ''
 __slots__=('_path','_drv','_root','_tail')
 def __init__(self,path):
  self._path=path
  self._drv=path.drive
  self._root=path.root
  self._tail=path._tail
 def __len__(self):
  return len(self._tail)
 def __getitem__(self,idx):
  if isinstance(idx,slice):
   return tuple(self[i]for i in range(*idx.indices(len(self))))
  if idx >=len(self)or idx <-len(self):
   raise IndexError(idx)
  if idx <0:
   idx +=len(self)
  return self._path._from_parsed_parts(self._drv,self._root,
  self._tail[:-idx -1])
 def __repr__(self):
  return "<{}.parents>".format(type(self._path).__name__)
class PurePath(object):
 ''
 __slots__=(
 '_raw_paths',
 '_drv','_root','_tail_cached',
 '_str',
 '_str_normcase_cached',
 '_parts_normcase_cached',
 '_lines_cached',
 '_hash',
 )
 _flavour=os.path
 def __new__(cls,*args,**kwargs):
  ''
  if cls is PurePath:
   cls=PureWindowsPath if os.name =='nt'else PurePosixPath
  return object.__new__(cls)
 def __reduce__(self):
  return(self.__class__,self.parts)
 def __init__(self,*args):
  paths=[]
  for arg in args:
   if isinstance(arg,PurePath):
    if arg._flavour is ntpath and self._flavour is posixpath:
     paths.extend(path.replace('\\','/')for path in arg._raw_paths)
    else:
     paths.extend(arg._raw_paths)
   else:
    try:
     path=os.fspath(arg)
    except TypeError:
     path=arg
    if not isinstance(path,str):
     raise TypeError(
     "argument should be a str or an os.PathLike "
     "object where __fspath__ returns a str, "
     f"not {type(path).__name__ !r}")
    paths.append(path)
  self._raw_paths=paths
 def with_segments(self,*pathsegments):
  ''
  return type(self)(*pathsegments)
 @classmethod
 def _parse_path(cls,path):
  if not path:
   return '','',[]
  sep=cls._flavour.sep
  altsep=cls._flavour.altsep
  if altsep:
   path=path.replace(altsep,sep)
  drv,root,rel=cls._flavour.splitroot(path)
  if not root and drv.startswith(sep)and not drv.endswith(sep):
   drv_parts=drv.split(sep)
   if len(drv_parts)==4 and drv_parts[2]not in '?.':
    root=sep
   elif len(drv_parts)==6:
    root=sep
  parsed=[sys.intern(str(x))for x in rel.split(sep)if x and x !='.']
  return drv,root,parsed
 def _load_parts(self):
  paths=self._raw_paths
  if len(paths)==0:
   path=''
  elif len(paths)==1:
   path=paths[0]
  else:
   path=self._flavour.join(*paths)
  drv,root,tail=self._parse_path(path)
  self._drv=drv
  self._root=root
  self._tail_cached=tail
 def _from_parsed_parts(self,drv,root,tail):
  path_str=self._format_parsed_parts(drv,root,tail)
  path=self.with_segments(path_str)
  path._str=path_str or '.'
  path._drv=drv
  path._root=root
  path._tail_cached=tail
  return path
 @classmethod
 def _format_parsed_parts(cls,drv,root,tail):
  if drv or root:
   return drv+root+cls._flavour.sep.join(tail)
  elif tail and cls._flavour.splitdrive(tail[0])[0]:
   tail=['.']+tail
  return cls._flavour.sep.join(tail)
 def __str__(self):
  ''
  try:
   return self._str
  except AttributeError:
   self._str=self._format_parsed_parts(self.drive,self.root,
   self._tail)or '.'
   return self._str
 def __fspath__(self):
  return str(self)
 def as_posix(self):
  ''
  f=self._flavour
  return str(self).replace(f.sep,'/')
 def __bytes__(self):
  ''
  return os.fsencode(self)
 def __repr__(self):
  return "{}({!r})".format(self.__class__.__name__,self.as_posix())
 def as_uri(self):
  ''
  if not self.is_absolute():
   raise ValueError("relative path can't be expressed as a file URI")
  drive=self.drive
  if len(drive)==2 and drive[1]==':':
   prefix='file:///'+drive
   path=self.as_posix()[2:]
  elif drive:
   prefix='file:'
   path=self.as_posix()
  else:
   prefix='file://'
   path=str(self)
  return prefix+urlquote_from_bytes(os.fsencode(path))
 @property
 def _str_normcase(self):
  try:
   return self._str_normcase_cached
  except AttributeError:
   if _is_case_sensitive(self._flavour):
    self._str_normcase_cached=str(self)
   else:
    self._str_normcase_cached=str(self).lower()
   return self._str_normcase_cached
 @property
 def _parts_normcase(self):
  try:
   return self._parts_normcase_cached
  except AttributeError:
   self._parts_normcase_cached=self._str_normcase.split(self._flavour.sep)
   return self._parts_normcase_cached
 @property
 def _lines(self):
  try:
   return self._lines_cached
  except AttributeError:
   path_str=str(self)
   if path_str =='.':
    self._lines_cached=''
   else:
    trans=_SWAP_SEP_AND_NEWLINE[self._flavour.sep]
    self._lines_cached=path_str.translate(trans)
   return self._lines_cached
 def __eq__(self,other):
  if not isinstance(other,PurePath):
   return NotImplemented
  return self._str_normcase ==other._str_normcase and self._flavour is other._flavour
 def __hash__(self):
  try:
   return self._hash
  except AttributeError:
   self._hash=hash(self._str_normcase)
   return self._hash
 def __lt__(self,other):
  if not isinstance(other,PurePath)or self._flavour is not other._flavour:
   return NotImplemented
  return self._parts_normcase <other._parts_normcase
 def __le__(self,other):
  if not isinstance(other,PurePath)or self._flavour is not other._flavour:
   return NotImplemented
  return self._parts_normcase <=other._parts_normcase
 def __gt__(self,other):
  if not isinstance(other,PurePath)or self._flavour is not other._flavour:
   return NotImplemented
  return self._parts_normcase >other._parts_normcase
 def __ge__(self,other):
  if not isinstance(other,PurePath)or self._flavour is not other._flavour:
   return NotImplemented
  return self._parts_normcase >=other._parts_normcase
 @property
 def drive(self):
  ''
  try:
   return self._drv
  except AttributeError:
   self._load_parts()
   return self._drv
 @property
 def root(self):
  ''
  try:
   return self._root
  except AttributeError:
   self._load_parts()
   return self._root
 @property
 def _tail(self):
  try:
   return self._tail_cached
  except AttributeError:
   self._load_parts()
   return self._tail_cached
 @property
 def anchor(self):
  ''
  anchor=self.drive+self.root
  return anchor
 @property
 def name(self):
  ''
  tail=self._tail
  if not tail:
   return ''
  return tail[-1]
 @property
 def suffix(self):
  ''
  name=self.name
  i=name.rfind('.')
  if 0 <i <len(name)-1:
   return name[i:]
  else:
   return ''
 @property
 def suffixes(self):
  ''
  name=self.name
  if name.endswith('.'):
   return[]
  name=name.lstrip('.')
  return['.'+suffix for suffix in name.split('.')[1:]]
 @property
 def stem(self):
  ''
  name=self.name
  i=name.rfind('.')
  if 0 <i <len(name)-1:
   return name[:i]
  else:
   return name
 def with_name(self,name):
  ''
  if not self.name:
   raise ValueError("%r has an empty name"%(self,))
  f=self._flavour
  drv,root,tail=f.splitroot(name)
  if drv or root or not tail or f.sep in tail or(f.altsep and f.altsep in tail):
   raise ValueError("Invalid name %r"%(name))
  return self._from_parsed_parts(self.drive,self.root,
  self._tail[:-1]+[name])
 def with_stem(self,stem):
  ''
  return self.with_name(stem+self.suffix)
 def with_suffix(self,suffix):
  ''
  f=self._flavour
  if f.sep in suffix or f.altsep and f.altsep in suffix:
   raise ValueError("Invalid suffix %r"%(suffix,))
  if suffix and not suffix.startswith('.')or suffix =='.':
   raise ValueError("Invalid suffix %r"%(suffix))
  name=self.name
  if not name:
   raise ValueError("%r has an empty name"%(self,))
  old_suffix=self.suffix
  if not old_suffix:
   name=name+suffix
  else:
   name=name[:-len(old_suffix)]+suffix
  return self._from_parsed_parts(self.drive,self.root,
  self._tail[:-1]+[name])
 def relative_to(self,other,/,*_deprecated,walk_up=False):
  ''
  if _deprecated:
   msg=("support for supplying more than one positional argument "
   "to pathlib.PurePath.relative_to() is deprecated and "
   "scheduled for removal in Python {remove}")
   warnings._deprecated("pathlib.PurePath.relative_to(*args)",msg,
   remove=(3,14))
  other=self.with_segments(other,*_deprecated)
  for step,path in enumerate([other]+list(other.parents)):
   if self.is_relative_to(path):
    break
   elif not walk_up:
    raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
   elif path.name =='..':
    raise ValueError(f"'..' segment in {str(other)!r} cannot be walked")
  else:
   raise ValueError(f"{str(self)!r} and {str(other)!r} have different anchors")
  parts=['..']*step+self._tail[len(path._tail):]
  return self.with_segments(*parts)
 def is_relative_to(self,other,/,*_deprecated):
  ''
  if _deprecated:
   msg=("support for supplying more than one argument to "
   "pathlib.PurePath.is_relative_to() is deprecated and "
   "scheduled for removal in Python {remove}")
   warnings._deprecated("pathlib.PurePath.is_relative_to(*args)",
   msg,remove=(3,14))
  other=self.with_segments(other,*_deprecated)
  return other ==self or other in self.parents
 @property
 def parts(self):
  ''
  if self.drive or self.root:
   return(self.drive+self.root,)+tuple(self._tail)
  else:
   return tuple(self._tail)
 def joinpath(self,*pathsegments):
  ''
  return self.with_segments(self,*pathsegments)
 def __truediv__(self,key):
  try:
   return self.joinpath(key)
  except TypeError:
   return NotImplemented
 def __rtruediv__(self,key):
  try:
   return self.with_segments(key,self)
  except TypeError:
   return NotImplemented
 @property
 def parent(self):
  ''
  drv=self.drive
  root=self.root
  tail=self._tail
  if not tail:
   return self
  return self._from_parsed_parts(drv,root,tail[:-1])
 @property
 def parents(self):
  ''
  return _PathParents(self)
 def is_absolute(self):
  ''
  if self._flavour is ntpath:
   return bool(self.drive and self.root)
  elif self._flavour is posixpath:
   for path in self._raw_paths:
    if path.startswith('/'):
     return True
   return False
  else:
   return self._flavour.isabs(str(self))
 def is_reserved(self):
  ''
  if self._flavour is posixpath or not self._tail:
   return False
  if self.drive.startswith('\\\\'):
   return False
  name=self._tail[-1].partition('.')[0].partition(':')[0].rstrip(' ')
  return name.upper()in _WIN_RESERVED_NAMES
 def match(self,path_pattern,*,case_sensitive=None):
  ''
  if not isinstance(path_pattern,PurePath):
   path_pattern=self.with_segments(path_pattern)
  if case_sensitive is None:
   case_sensitive=_is_case_sensitive(self._flavour)
  pattern=_compile_pattern_lines(path_pattern._lines,case_sensitive)
  if path_pattern.drive or path_pattern.root:
   return pattern.match(self._lines)is not None
  elif path_pattern._tail:
   return pattern.search(self._lines)is not None
  else:
   raise ValueError("empty pattern")
os.PathLike.register(PurePath)
class PurePosixPath(PurePath):
 ''
 _flavour=posixpath
 __slots__=()
class PureWindowsPath(PurePath):
 ''
 _flavour=ntpath
 __slots__=()
class Path(PurePath):
 ''
 __slots__=()
 def stat(self,*,follow_symlinks=True):
  ''
  return os.stat(self,follow_symlinks=follow_symlinks)
 def lstat(self):
  ''
  return self.stat(follow_symlinks=False)
 def exists(self,*,follow_symlinks=True):
  ''
  try:
   self.stat(follow_symlinks=follow_symlinks)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
  return True
 def is_dir(self):
  ''
  try:
   return S_ISDIR(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_file(self):
  ''
  try:
   return S_ISREG(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_mount(self):
  ''
  return self._flavour.ismount(self)
 def is_symlink(self):
  ''
  try:
   return S_ISLNK(self.lstat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_junction(self):
  ''
  return self._flavour.isjunction(self)
 def is_block_device(self):
  ''
  try:
   return S_ISBLK(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_char_device(self):
  ''
  try:
   return S_ISCHR(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_fifo(self):
  ''
  try:
   return S_ISFIFO(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def is_socket(self):
  ''
  try:
   return S_ISSOCK(self.stat().st_mode)
  except OSError as e:
   if not _ignore_error(e):
    raise
   return False
  except ValueError:
   return False
 def samefile(self,other_path):
  ''
  st=self.stat()
  try:
   other_st=other_path.stat()
  except AttributeError:
   other_st=self.with_segments(other_path).stat()
  return self._flavour.samestat(st,other_st)
 def open(self,mode='r',buffering=-1,encoding=None,
 errors=None,newline=None):
  ''
  if "b"not in mode:
   encoding=io.text_encoding(encoding)
  return io.open(self,mode,buffering,encoding,errors,newline)
 def read_bytes(self):
  ''
  with self.open(mode='rb')as f:
   return f.read()
 def read_text(self,encoding=None,errors=None):
  ''
  encoding=io.text_encoding(encoding)
  with self.open(mode='r',encoding=encoding,errors=errors)as f:
   return f.read()
 def write_bytes(self,data):
  ''
  view=memoryview(data)
  with self.open(mode='wb')as f:
   return f.write(view)
 def write_text(self,data,encoding=None,errors=None,newline=None):
  ''
  if not isinstance(data,str):
   raise TypeError('data must be str, not %s'%
   data.__class__.__name__)
  encoding=io.text_encoding(encoding)
  with self.open(mode='w',encoding=encoding,errors=errors,newline=newline)as f:
   return f.write(data)
 def iterdir(self):
  ''
  for name in os.listdir(self):
   yield self._make_child_relpath(name)
 def _scandir(self):
  return os.scandir(self)
 def _make_child_relpath(self,name):
  path_str=str(self)
  tail=self._tail
  if tail:
   path_str=f'{path_str}{self._flavour.sep}{name}'
  elif path_str !='.':
   path_str=f'{path_str}{name}'
  else:
   path_str=name
  path=self.with_segments(path_str)
  path._str=path_str
  path._drv=self.drive
  path._root=self.root
  path._tail_cached=tail+[name]
  return path
 def glob(self,pattern,*,case_sensitive=None):
  ''
  sys.audit("pathlib.Path.glob",self,pattern)
  if not pattern:
   raise ValueError("Unacceptable pattern: {!r}".format(pattern))
  drv,root,pattern_parts=self._parse_path(pattern)
  if drv or root:
   raise NotImplementedError("Non-relative patterns are unsupported")
  if pattern[-1]in(self._flavour.sep,self._flavour.altsep):
   pattern_parts.append('')
  selector=_make_selector(tuple(pattern_parts),self._flavour,case_sensitive)
  for p in selector.select_from(self):
   yield p
 def rglob(self,pattern,*,case_sensitive=None):
  ''
  sys.audit("pathlib.Path.rglob",self,pattern)
  drv,root,pattern_parts=self._parse_path(pattern)
  if drv or root:
   raise NotImplementedError("Non-relative patterns are unsupported")
  if pattern and pattern[-1]in(self._flavour.sep,self._flavour.altsep):
   pattern_parts.append('')
  selector=_make_selector(("**",)+tuple(pattern_parts),self._flavour,case_sensitive)
  for p in selector.select_from(self):
   yield p
 def walk(self,top_down=True,on_error=None,follow_symlinks=False):
  ''
  sys.audit("pathlib.Path.walk",self,on_error,follow_symlinks)
  paths=[self]
  while paths:
   path=paths.pop()
   if isinstance(path,tuple):
    yield path
    continue
   try:
    scandir_it=path._scandir()
   except OSError as error:
    if on_error is not None:
     on_error(error)
    continue
   with scandir_it:
    dirnames=[]
    filenames=[]
    for entry in scandir_it:
     try:
      is_dir=entry.is_dir(follow_symlinks=follow_symlinks)
     except OSError:
      is_dir=False
     if is_dir:
      dirnames.append(entry.name)
     else:
      filenames.append(entry.name)
   if top_down:
    yield path,dirnames,filenames
   else:
    paths.append((path,dirnames,filenames))
   paths +=[path._make_child_relpath(d)for d in reversed(dirnames)]
 def __init__(self,*args,**kwargs):
  if kwargs:
   msg=("support for supplying keyword arguments to pathlib.PurePath "
   "is deprecated and scheduled for removal in Python {remove}")
   warnings._deprecated("pathlib.PurePath(**kwargs)",msg,remove=(3,14))
  super().__init__(*args)
 def __new__(cls,*args,**kwargs):
  if cls is Path:
   cls=WindowsPath if os.name =='nt'else PosixPath
  return object.__new__(cls)
 def __enter__(self):
  warnings.warn("pathlib.Path.__enter__() is deprecated and scheduled "
  "for removal in Python 3.13; Path objects as a context "
  "manager is a no-op",
  DeprecationWarning,stacklevel=2)
  return self
 def __exit__(self,t,v,tb):
  pass
 @classmethod
 def cwd(cls):
  ''
  return cls().absolute()
 @classmethod
 def home(cls):
  ''
  return cls("~").expanduser()
 def absolute(self):
  ''
  if self.is_absolute():
   return self
  elif self.drive:
   cwd=self._flavour.abspath(self.drive)
  else:
   cwd=os.getcwd()
   if not self.root and not self._tail:
    result=self.with_segments(cwd)
    result._str=cwd
    return result
  return self.with_segments(cwd,self)
 def resolve(self,strict=False):
  ''
  def check_eloop(e):
   winerror=getattr(e,'winerror',0)
   if e.errno ==ELOOP or winerror ==_WINERROR_CANT_RESOLVE_FILENAME:
    raise RuntimeError("Symlink loop from %r"%e.filename)
  try:
   s=self._flavour.realpath(self,strict=strict)
  except OSError as e:
   check_eloop(e)
   raise
  p=self.with_segments(s)
  if not strict:
   try:
    p.stat()
   except OSError as e:
    check_eloop(e)
  return p
 def owner(self):
  ''
  try:
   import pwd
   return pwd.getpwuid(self.stat().st_uid).pw_name
  except ImportError:
   raise NotImplementedError("Path.owner() is unsupported on this system")
 def group(self):
  ''
  try:
   import grp
   return grp.getgrgid(self.stat().st_gid).gr_name
  except ImportError:
   raise NotImplementedError("Path.group() is unsupported on this system")
 def readlink(self):
  ''
  if not hasattr(os,"readlink"):
   raise NotImplementedError("os.readlink() not available on this system")
  return self.with_segments(os.readlink(self))
 def touch(self,mode=0o666,exist_ok=True):
  ''
  if exist_ok:
   try:
    os.utime(self,None)
   except OSError:
    pass
   else:
    return
  flags=os.O_CREAT |os.O_WRONLY
  if not exist_ok:
   flags |=os.O_EXCL
  fd=os.open(self,flags,mode)
  os.close(fd)
 def mkdir(self,mode=0o777,parents=False,exist_ok=False):
  ''
  try:
   os.mkdir(self,mode)
  except FileNotFoundError:
   if not parents or self.parent ==self:
    raise
   self.parent.mkdir(parents=True,exist_ok=True)
   self.mkdir(mode,parents=False,exist_ok=exist_ok)
  except OSError:
   if not exist_ok or not self.is_dir():
    raise
 def chmod(self,mode,*,follow_symlinks=True):
  ''
  os.chmod(self,mode,follow_symlinks=follow_symlinks)
 def lchmod(self,mode):
  ''
  self.chmod(mode,follow_symlinks=False)
 def unlink(self,missing_ok=False):
  ''
  try:
   os.unlink(self)
  except FileNotFoundError:
   if not missing_ok:
    raise
 def rmdir(self):
  ''
  os.rmdir(self)
 def rename(self,target):
  ''
  os.rename(self,target)
  return self.with_segments(target)
 def replace(self,target):
  ''
  os.replace(self,target)
  return self.with_segments(target)
 def symlink_to(self,target,target_is_directory=False):
  ''
  if not hasattr(os,"symlink"):
   raise NotImplementedError("os.symlink() not available on this system")
  os.symlink(target,self,target_is_directory)
 def hardlink_to(self,target):
  ''
  if not hasattr(os,"link"):
   raise NotImplementedError("os.link() not available on this system")
  os.link(target,self)
 def expanduser(self):
  ''
  if(not(self.drive or self.root)and
  self._tail and self._tail[0][:1]=='~'):
   homedir=self._flavour.expanduser(self._tail[0])
   if homedir[:1]=="~":
    raise RuntimeError("Could not determine home directory.")
   drv,root,tail=self._parse_path(homedir)
   return self._from_parsed_parts(drv,root,tail+self._tail[1:])
  return self
class PosixPath(Path,PurePosixPath):
 ''
 __slots__=()
 if os.name =='nt':
  def __new__(cls,*args,**kwargs):
   raise NotImplementedError(
   f"cannot instantiate {cls.__name__ !r} on your system")
class WindowsPath(Path,PureWindowsPath):
 ''
 __slots__=()
 if os.name !='nt':
  def __new__(cls,*args,**kwargs):
   raise NotImplementedError(
   f"cannot instantiate {cls.__name__ !r} on your system")
====pathlib.py(module) end====

====posix.js(file) start====
/*
This module provides access to operating system functionality that is
standardized by the C Standard and the POSIX standard (a thinly
disguised Unix interface).  Refer to the library manual and
corresponding Unix manual entries for more information on calls.
*/
var $B = __BRYTHON__,
    _b_ = $B.builtins

function _randint(a, b){
    return parseInt(Math.random() * (b - a + 1) + a)
}

var stat_result = $B.make_class("stat_result",
    function(filename){
        filename = _b_.str.$factory(filename)
        if($B.file_cache && $B.file_cache.hasOwnProperty(filename)){
            var f = $B.file_cache[filename],
                res = {
                    __class__: stat_result,
                    st_atime: __BRYTHON__.timestamp,
                    st_ctime: f.ctime,
                    st_mtime: f.mtime,
                    st_uid: -1,
                    st_gid: -1,
                    st_ino: -1,
                    st_mode: 0,
                    st_size: f.length
                };
                ["mtime", "ctime", "atime_ns", "mtime_ns", "ctime_ns"].
                    forEach(function(item){
                        res["st_" + item] = res.st_atime
                    });
            return res
        }else if($B.files && $B.files.hasOwnProperty(filename)){
            var f = $B.files[filename],
                res = {
                    __class__: stat_result,
                    st_atime: __BRYTHON__.timestamp,
                    st_ctime: f.ctime,
                    st_mtime: f.mtime,
                    st_uid: -1,
                    st_gid: -1,
                    st_ino: -1,
                    st_mode: 0,
                    st_size: f.content.length
                };
            for(var item of ["mtime", "ctime", "atime_ns", "mtime_ns", "ctime_ns"]){
                res["st_" + item] = res.st_atime
            }
            return res

        }else{
            var res = {
                __class__: stat_result,
                st_atime: __BRYTHON__.timestamp,
                st_uid: -1,
                st_gid: -1,
                st_ino: -1,
                st_mode: filename.endsWith('/') ? 16895 : 33206,
                st_size: 1 // fake
            };
            ["mtime", "ctime", "atime_ns", "mtime_ns", "ctime_ns"].
                forEach(function(item){
                    res["st_" + item] = res.st_atime
                });
            return res
        }
    }
)
$B.set_func_names(stat_result, "posix")

var module = {
    F_OK: 0,
    O_APPEND: 8,
    O_BINARY: 32768,
    O_CREAT: 256,
    O_EXCL: 1024,
    O_NOINHERIT: 128,
    O_RANDOM: 16,
    O_RDONLY: 0,
    O_RDWR: 2,
    O_SEQUENTIAL: 32,
    O_SHORT_LIVED: 4096,
    O_TEMPORARY: 64,
    O_TEXT: 16384,
    O_TRUNC: 512,
    O_WRONLY: 1,
    P_DETACH: 4,
    P_NOWAIT: 1,
    P_NOWAITO: 3,
    P_OVERLAY: 2,
    P_WAIT: 0,
    R_OK: 4,
    TMP_MAX: 32767,
    W_OK: 2,
    X_OK: 1,
    _have_functions: ['MS_WINDOWS'],
    environ: _b_.dict.$factory(
        [['PYTHONPATH', $B.brython_path],
         ['PYTHONUSERBASE', ' ']]),
    error: _b_.OSError,
    fspath: function(path){
        return path
    },
    getcwd: function(){return $B.brython_path},
    getpid: function(){return 0},
    lstat: function(filename){
        return stat_result.$factory(filename)
    },
    open: function(path, flags){return _b_.open(path, flags)},
    remove: function(path) {
        var $ = $B.args("remove", 1, { path: null }, ["path"], arguments, {}, null, null)
        console.log($)

        var path = $.path
        var found_file = false

        if ($B.file_cache && $B.file_cache.hasOwnProperty(path)){
            delete $B.file_cache[path]
            found_file = true
        }
        if ($B.files && $B.files.hasOwnProperty(path)){
            delete $B.files[path]
            found_file = true
        }

        if(!found_file) {
            throw _b_.FileNotFoundError.$factory(`No such file or directory: '${path}'`)
        }

        return _b_.None
    },
    stat: function(filename){return stat_result.$factory(filename)},
    stat_result: function(filename){return stat_result.$factory(filename)},
    urandom: function(n){
        const randbytes = new Uint8Array(n);
        crypto.getRandomValues(randbytes);
        return _b_.bytes.$factory(Array.from(randbytes));
    },
    WTERMSIG: function(){return 0},
    WNOHANG: function(){return _b_.tuple.$factory([0, 0])}
};

["WCOREDUMP", "WIFCONTINUED", "WIFSTOPPED", "WIFSIGNALED", "WIFEXITED"].forEach(function(funcname){
        module[funcname] = function(){return false}
    });

["WEXITSTATUS", "WSTOPSIG", "WTERMSIG"].
    forEach(function(funcname){
        module[funcname] = function(){return _b_.None}
    });

["_exit", "_getdiskusage", "_getfileinformation", "_getfinalpathname",
    "_getfullpathname", "_isdir", "abort", "access", "chdir", "chmod",
    "close", "closerange", "device_encoding", "dup", "dup2",
    "execv", "execve", "fsat", "fsync", "get_terminal_size", "getcwdb",
    "getlogin", "getppid", "isatty", "kill", "link", "listdir", "lseek",
    "mkdir", "pipe", "putenv", "read", "readlink", "rename",
    "replace", "rmdir", "spawnv", "spawnve", "startfile", "stat_float_times",
    "statvfs_result", "strerror", "symlink", "system", "terminal_size",
    "times", "times_result", "umask", "uname_result", "unlink", "utime",
    "waitpid", "write"].forEach(function(funcname){
        module[funcname] = function(){
            throw _b_.NotImplementedError.$factory("posix." + funcname +
                " is not implemented")
        }
    });

$B.addToImported('posix', module)====posix.js(file) end====

====posixpath.py(module) start====
''
curdir='.'
pardir='..'
extsep='.'
sep='/'
pathsep=':'
defpath='/bin:/usr/bin'
altsep=None
devnull='/dev/null'

import os
import sys
import stat
import genericpath
from genericpath import *

__all__=["normcase","isabs","join","splitdrive","splitroot","split","splitext",
"basename","dirname","commonprefix","getsize","getmtime",
"getatime","getctime","islink","exists","lexists","isdir","isfile",
"ismount","expanduser","expandvars","normpath","abspath",
"samefile","sameopenfile","samestat",
"curdir","pardir","sep","pathsep","defpath","altsep","extsep",
"devnull","realpath","supports_unicode_filenames","relpath",
"commonpath","isjunction"]
def _get_sep(path):
 if isinstance(path,bytes):
  return b'/'
 else:
  return '/'
def normcase(s):
 ''
 return os.fspath(s)
def isabs(s):
 ''
 s=os.fspath(s)
 sep=_get_sep(s)
 return s.startswith(sep)
def join(a,*p):
 ''
 a=os.fspath(a)
 sep=_get_sep(a)
 path=a
 try:
  if not p:
   path[:0]+sep
  for b in map(os.fspath,p):
   if b.startswith(sep):
    path=b
   elif not path or path.endswith(sep):
    path +=b
   else:
    path +=sep+b
 except(TypeError,AttributeError,BytesWarning):
  genericpath._check_arg_types('join',a,*p)
  raise
 return path
def split(p):
 ''
 p=os.fspath(p)
 sep=_get_sep(p)
 i=p.rfind(sep)+1
 head,tail=p[:i],p[i:]
 if head and head !=sep *len(head):
  head=head.rstrip(sep)
 return head,tail
def splitext(p):
 p=os.fspath(p)
 if isinstance(p,bytes):
  sep=b'/'
  extsep=b'.'
 else:
  sep='/'
  extsep='.'
 return genericpath._splitext(p,sep,None,extsep)
splitext.__doc__=genericpath._splitext.__doc__
def splitdrive(p):
 ''
 p=os.fspath(p)
 return p[:0],p
def splitroot(p):
 ''
 p=os.fspath(p)
 if isinstance(p,bytes):
  sep=b'/'
  empty=b''
 else:
  sep='/'
  empty=''
 if p[:1]!=sep:
  return empty,empty,p
 elif p[1:2]!=sep or p[2:3]==sep:
  return empty,sep,p[1:]
 else:
  return empty,p[:2],p[2:]
def basename(p):
 ''
 p=os.fspath(p)
 sep=_get_sep(p)
 i=p.rfind(sep)+1
 return p[i:]
def dirname(p):
 ''
 p=os.fspath(p)
 sep=_get_sep(p)
 i=p.rfind(sep)+1
 head=p[:i]
 if head and head !=sep *len(head):
  head=head.rstrip(sep)
 return head
def isjunction(path):
 ''
 os.fspath(path)
 return False
def lexists(path):
 ''
 try:
  os.lstat(path)
 except(OSError,ValueError):
  return False
 return True
def ismount(path):
 ''
 try:
  s1=os.lstat(path)
 except(OSError,ValueError):
  return False
 else:
  if stat.S_ISLNK(s1.st_mode):
   return False
 path=os.fspath(path)
 if isinstance(path,bytes):
  parent=join(path,b'..')
 else:
  parent=join(path,'..')
 parent=realpath(parent)
 try:
  s2=os.lstat(parent)
 except(OSError,ValueError):
  return False
 dev1=s1.st_dev
 dev2=s2.st_dev
 if dev1 !=dev2:
  return True
 ino1=s1.st_ino
 ino2=s2.st_ino
 if ino1 ==ino2:
  return True
 return False
def expanduser(path):
 ''
 path=os.fspath(path)
 if isinstance(path,bytes):
  tilde=b'~'
 else:
  tilde='~'
 if not path.startswith(tilde):
  return path
 sep=_get_sep(path)
 i=path.find(sep,1)
 if i <0:
  i=len(path)
 if i ==1:
  if 'HOME'not in os.environ:
   try:
    import pwd
   except ImportError:
    return path
   try:
    userhome=pwd.getpwuid(os.getuid()).pw_dir
   except KeyError:
    return path
  else:
   userhome=os.environ['HOME']
 else:
  try:
   import pwd
  except ImportError:
   return path
  name=path[1:i]
  if isinstance(name,bytes):
   name=str(name,'ASCII')
  try:
   pwent=pwd.getpwnam(name)
  except KeyError:
   return path
  userhome=pwent.pw_dir
 if userhome is None and sys.platform =="vxworks":
  return path
 if isinstance(path,bytes):
  userhome=os.fsencode(userhome)
  root=b'/'
 else:
  root='/'
 userhome=userhome.rstrip(root)
 return(userhome+path[i:])or root
_varprog=None
_varprogb=None

def expandvars(path):
 ''
 path=os.fspath(path)
 global _varprog,_varprogb
 if isinstance(path,bytes):
  if b'$'not in path:
   return path
  if not _varprogb:
   import re
   _varprogb=re.compile(br'\$(\w+|\{[^}]*\})',re.ASCII)
  search=_varprogb.search
  start=b'{'
  end=b'}'
  environ=getattr(os,'environb',None)
 else:
  if '$'not in path:
   return path
  if not _varprog:
   import re
   _varprog=re.compile(r'\$(\w+|\{[^}]*\})',re.ASCII)
  search=_varprog.search
  start='{'
  end='}'
  environ=os.environ
 i=0
 while True:
  m=search(path,i)
  if not m:
   break
  i,j=m.span(0)
  name=m.group(1)
  if name.startswith(start)and name.endswith(end):
   name=name[1:-1]
  try:
   if environ is None:
    value=os.fsencode(os.environ[os.fsdecode(name)])
   else:
    value=environ[name]
  except KeyError:
   i=j
  else:
   tail=path[j:]
   path=path[:i]+value
   i=len(path)
   path +=tail
 return path
try:
 from posix import _path_normpath
except ImportError:
 def normpath(path):
  ''
  path=os.fspath(path)
  if isinstance(path,bytes):
   sep=b'/'
   empty=b''
   dot=b'.'
   dotdot=b'..'
  else:
   sep='/'
   empty=''
   dot='.'
   dotdot='..'
  if path ==empty:
   return dot
  _,initial_slashes,path=splitroot(path)
  comps=path.split(sep)
  new_comps=[]
  for comp in comps:
   if comp in(empty,dot):
    continue
   if(comp !=dotdot or(not initial_slashes and not new_comps)or
   (new_comps and new_comps[-1]==dotdot)):
    new_comps.append(comp)
   elif new_comps:
    new_comps.pop()
  comps=new_comps
  path=initial_slashes+sep.join(comps)
  return path or dot
else:
 def normpath(path):
  ''
  path=os.fspath(path)
  if isinstance(path,bytes):
   return os.fsencode(_path_normpath(os.fsdecode(path)))or b"."
  return _path_normpath(path)or "."
def abspath(path):
 ''
 path=os.fspath(path)
 if not isabs(path):
  if isinstance(path,bytes):
   cwd=os.getcwdb()
  else:
   cwd=os.getcwd()
  path=join(cwd,path)
 return normpath(path)
def realpath(filename,*,strict=False):
 ''
 filename=os.fspath(filename)
 path,ok=_joinrealpath(filename[:0],filename,strict,{})
 return abspath(path)
def _joinrealpath(path,rest,strict,seen):
 if isinstance(path,bytes):
  sep=b'/'
  curdir=b'.'
  pardir=b'..'
 else:
  sep='/'
  curdir='.'
  pardir='..'
 if isabs(rest):
  rest=rest[1:]
  path=sep
 while rest:
  name,_,rest=rest.partition(sep)
  if not name or name ==curdir:
   continue
  if name ==pardir:
   if path:
    path,name=split(path)
    if name ==pardir:
     path=join(path,pardir,pardir)
   else:
    path=pardir
   continue
  newpath=join(path,name)
  try:
   st=os.lstat(newpath)
  except OSError:
   if strict:
    raise
   is_link=False
  else:
   is_link=stat.S_ISLNK(st.st_mode)
  if not is_link:
   path=newpath
   continue
  if newpath in seen:
   path=seen[newpath]
   if path is not None:
    continue
   if strict:
    os.stat(newpath)
   else:
    return join(newpath,rest),False
  seen[newpath]=None
  path,ok=_joinrealpath(path,os.readlink(newpath),strict,seen)
  if not ok:
   return join(path,rest),False
  seen[newpath]=path
 return path,True
supports_unicode_filenames=(sys.platform =='darwin')

def relpath(path,start=None):
 ''
 if not path:
  raise ValueError("no path specified")
 path=os.fspath(path)
 if isinstance(path,bytes):
  curdir=b'.'
  sep=b'/'
  pardir=b'..'
 else:
  curdir='.'
  sep='/'
  pardir='..'
 if start is None:
  start=curdir
 else:
  start=os.fspath(start)
 try:
  start_list=[x for x in abspath(start).split(sep)if x]
  path_list=[x for x in abspath(path).split(sep)if x]
  i=len(commonprefix([start_list,path_list]))
  rel_list=[pardir]*(len(start_list)-i)+path_list[i:]
  if not rel_list:
   return curdir
  return join(*rel_list)
 except(TypeError,AttributeError,BytesWarning,DeprecationWarning):
  genericpath._check_arg_types('relpath',path,start)
  raise
def commonpath(paths):
 ''
 if not paths:
  raise ValueError('commonpath() arg is an empty sequence')
 paths=tuple(map(os.fspath,paths))
 if isinstance(paths[0],bytes):
  sep=b'/'
  curdir=b'.'
 else:
  sep='/'
  curdir='.'
 try:
  split_paths=[path.split(sep)for path in paths]
  try:
   isabs,=set(p[:1]==sep for p in paths)
  except ValueError:
   raise ValueError("Can't mix absolute and relative paths")from None
  split_paths=[[c for c in s if c and c !=curdir]for s in split_paths]
  s1=min(split_paths)
  s2=max(split_paths)
  common=s1
  for i,c in enumerate(s1):
   if c !=s2[i]:
    common=s1[:i]
    break
  prefix=sep if isabs else sep[:0]
  return prefix+sep.join(common)
 except(TypeError,AttributeError):
  genericpath._check_arg_types('commonpath',*paths)
  raise
====posixpath.py(module) end====

====python_re.js(file) start====
// Regular expression
(function($B){

var _debug = {value: 0}

var _b_ = $B.builtins

var MAXGROUPS = 2147483647,
    MAXREPEAT = 2147483648

var word_gcs = ['Ll', 'Lu', 'Lm', 'Lt', 'Lo',
                'Nd',
                'Mc', 'Me', 'Mn',
                'Pc']

function is_word(cp){
    if((cp >= 97 && cp <= 122) // a-z
            || (cp >= 65 && cp <= 90) // A-Z
        ){
            return true
    }
    for(var word_gc of word_gcs){
        if($B.in_unicode_category(word_gc, cp)){
            return true
        }
    }
    return false
}

var ascii_word = {}

for(var cp = 0; cp <= 127; cp++){
    if(is_word(cp)){
        ascii_word[cp] = true
    }
}

function is_ascii_word(cp){
    return ascii_word[cp] !== undefined
}

function is_digit(cp){
    if(cp >= 48 && cp <= 57){
        return true
    }
    return $B.in_unicode_category('Nd', cp)
}

function is_ascii_digit(cp){
    return cp <= 127 && is_digit(cp)
}

var $error_2 = {
    $name: "error",
    $qualname: "error",
    $is_class: true,
    __module__: "re"
}

var error = $B.make_class("error",
    function(message){
        return {
            __class__: error,
            msg: message,
            args: $B.fast_tuple([]),
            __cause__: _b_.None,
            __context__: _b_.None,
            __suppress_context__: false
        }
    })
error.__bases__ = [_b_.Exception, _b_.object]
error.__mro__ = [_b_.Exception, _b_.BaseException, _b_.object]

error.__str__ = function(self){
    var s = self.msg + ' at position ' + self.pos
    if(self.lineno > 1){
        s += ` (line ${self.lineno}, column ${self.colno})`
    }
    return s
}

$B.set_func_names(error, "re")

function $last(t){
    return t[t.length - 1]
}

function fail(message, pos, pattern){
    var err = error.$factory(message)
    err.msg = message
    err.pos = pos
    if(pattern){
        err.pattern = pattern.py_obj // Python object passed to compile()
        err.lineno = 1
        var linestart = 0
        for(var i = 0, len = pattern.string.length; i < pos; i++){
            if(pattern.string[i] == '\n'){
                err.lineno++
                linestart = i + 1
            }
        }
        err.colno = pos - linestart + 1
    }
    throw err
}

function warn(klass, message, pos, text){
    var frame = $B.frame_obj.frame,
        file = frame[3].__file__,
        src = $B.file_cache[file]
    if(text === undefined){
        var lineno = frame[1].$lineno
        var lines = src.split('\n'),
            line = lines[lineno - 1]
    }else{
        if(Array.isArray(text)){
            text = from_codepoint_list(text)
        }
        var lineno = 1,
            line_start = 0
        for(var i = 0; i < pos; i++){
            if(text[i] == '\n'){
                lineno++
                line_start = i + 1
            }
        }
        var line_end = text.substr(line_start).search('\n'),
            line
        if(line_end == -1){
            line = text.substr(line_start)
        }else{
            line = text.substr(line_start, line_end)
        }
        var col_offset = pos - line_start
    }
    var warning = klass.$factory(message)
    warning.pos = pos
    warning.args[1] = [file, lineno, col_offset, lineno, col_offset,
        line]
    warning.filename = file
    warning.lineno = warning.end_lineno = lineno
    warning.offset = warning.end_offset = col_offset
    warning.line = line
    // module _warning is in builtin_modules.js
    $B.imported._warnings.warn(warning)
}

function chr(i){
    if(i < 0 || i > 1114111){
        throw _b_.ValueError.$factory('Outside valid range')
    }else if(i >= 0x10000 && i <= 0x10FFFF){
        var code = (i - 0x10000)
        return String.fromCodePoint(0xD800 | (code >> 10)) +
            String.fromCodePoint(0xDC00 | (code & 0x3FF))
    }else{
        return String.fromCodePoint(i)
    }
}

function ord(char){
    return char.charCodeAt(0)
}

const LETTERS = {
    b: ord('b'),
    N: ord('N'),
    P: ord('P'),
    u: ord('u'),
    U: ord('U'),
    x: ord('x')
}

const PARENTH_OPEN = ord('('),
      PARENTH_CLOSE = ord(')'),
      BRACKET_OPEN = ord('['),
      BRACKET_CLOSE = ord(']'),
      BRACE_OPEN = ord('{'),
      BRACE_CLOSE = ord('}'),
      EQUAL = ord('='),
      SUP = ord('>'),
      INF = ord('<'),
      MINUS = ord('-'),
      PLUS = ord('+'),
      OR = ord('|'),
      DOT = ord('.'),
      QUESTION_MARK = ord('?'),
      EXCLAMATION_MARK = ord('!'),
      COLON = ord(':'),
      BACKSLASH = ord('\\'),
      DOLLAR = ord('$'),
      CARET = ord('^'),
      LINEFEED = ord('\n')

// pattern tokenizer

function is_ascii(name){
    return /^[\x00-\x7F]*$/.test(name)
}

function open_unicode_db(){
    if($B.unicodedb === undefined){
        var xhr = new XMLHttpRequest
        xhr.open("GET",
            $B.brython_path + "unicode.txt?" + (new Date()).getTime(), false)
        xhr.onreadystatechange = function(){
            if(this.readyState == 4){
                if(this.status == 200){
                    $B.unicodedb = this.responseText
                }else{
                    console.log(
                        "Warning - could not load unicode.txt")
                }
            }
        }
        xhr.send()
    }
}

function validate_named_char(description, pos){
    // validate that \N{<description>} is in the Unicode db
    // Load unicode table if not already loaded
    if(description.length == 0){
        fail("missing character name", pos)
    }
    open_unicode_db()
    if($B.unicodedb !== undefined){
        var re = new RegExp("^([0-9A-F]+);" +
            description.toUpperCase() + ";.*$", "m")
        search = re.exec($B.unicodedb)
        if(search === null){
            fail(`undefined character name '${description}'`, pos)
        }
        return parseInt(search[1], 16)
    }else{
        fail("could not load unicode.txt", pos)
    }
}

function validate_group_name(sname, pos, is_bytes){
    // sname is an instance of StringObj
    if(! _b_.str.isidentifier(sname.string)){
        fail(`bad character in group name '${sname.string}'`, pos + 4)
    }
    if(is_bytes && ! is_ascii(sname.string)){
        var s = _b_.bytes.decode(_b_.bytes.$factory(sname.codepoints),
                                 'ascii', 'backslashreplace')
        warn(_b_.DeprecationWarning,
            `bad character in group name '${s}' at position ${pos + 4}`)
    }
    return true
}

function validate_group_num(so, pos){
    var s = so.string
    if(s.match(/^\d+$/)){
        return true
    }
    try{
        var num = _b_.int.$factory(s)
        warn(_b_.DeprecationWarning,
            `bad character in group name '${s}' at position ${pos + 3}`,
            pos + 3, s)
        so.string = num + ''
        return true
    }catch(err){
        return false
    }
}

function validate_num_or_name(so, pos, is_bytes){
    return validate_group_num(so, pos, is_bytes) ||
               validate_group_name(so, pos - 1, is_bytes)
}

var character_classes = {
    in_charset: to_codepoint_list('dDsSwW'),
    in_re: to_codepoint_list('AbBdDsSwWZ')
}

function escaped_char(args){
    var cps = args.codepoints,
        pos = args.pos,
        in_charset = args.in_charset,
        is_bytes = args.is_bytes // if pattern is bytes
    var special = cps[pos + 1]
    if(special === undefined){
        fail('bad escape (end of pattern)', pos)
    }
    var key = in_charset ? 'in_charset' : 'in_re'
    if(in_charset && special == LETTERS.b){
        // Inside a character range, \b represents the backspace character,
        // for compatibility with Pythons string literals.
        return '\b'
    }
    if(character_classes[key].indexOf(special) > -1){
        return new CharacterClass(pos, special, 2)
    }else if(special == LETTERS.N && ! is_bytes){
        if(cps[pos + 2] != BRACE_OPEN){
            fail('missing {', pos)
        }
        var i = pos + 3,
            description = []
        while(i < cps.length){
            if(cps[i] == BRACE_CLOSE){
                break
            }
            description.push(cps[i])
            i++
        }
        if(description.length == 0){
            fail("missing character name", pos)
        }
        if(i == cps.length){
            fail("missing }, unterminated name", pos)
        }
        var cp = validate_named_char(from_codepoint_list(description), pos)
        return {
            type: 'N',
            ord: cp,
            char: chr(cp),
            length: i - pos + 1
        }
    }else if(special == LETTERS.x){
        // \xhh = character with hex value hh
        var rest = from_codepoint_list(cps.slice(pos + 2)),
            mo = /^[0-9a-fA-F]{0,2}/.exec(rest),
            hh = mo ? mo[0] : ''
        if(mo && mo[0].length == 2){
            var cp = parseInt(mo[0], 16)
            return {
                type: 'x',
                ord: cp,
                char: chr(cp),
                length: 2 + mo[0].length
            }
        }
        fail('incomplete escape \\x' + hh, pos)
    }else if(special == LETTERS.u){
        // \uxxxx = character with 16-bit hex value xxxx
        var rest = from_codepoint_list(cps.slice(pos + 2)),
            mo = /^[0-9a-fA-F]{0,4}/.exec(rest),
            xx = mo ? mo[0] : ''
        if(mo && mo[0].length == 4){
            var cp = parseInt(mo[0], 16)
            return {
                type: 'u',
                ord: cp,
                char: chr(cp),
                length: 2 + mo[0].length
            }
        }
        fail('incomplete escape \\u' + xx, pos)
    }else if(special == LETTERS.U){
        // \Uxxxxxxxx = character with 32-bit hex value xxxxxxxx
        var rest = from_codepoint_list(cps.slice(pos + 2)),
            mo = /^[0-9a-fA-F]{0,8}/.exec(rest),
            xx = mo ? mo[0] : ''
        if(mo && mo[0].length == 8){
            var cp = parseInt(mo[0], 16)
            if(cp > 0x10FFFF){
                fail(`bad escape \\U${mo[0]}`, pos)
            }
            return {
                type: 'U',
                ord: cp,
                char: chr(cp),
                length: 2 + mo[0].length
            }
        }
        fail('incomplete escape \\U' + xx, pos)
    }else{
        // octal ?
        // If the first digit of number is 0, or number is 3 octal digits
        // long, it will not be interpreted as a group match, but as the
        // character with octal value number
        var rest = from_codepoint_list(cps.slice(pos + 1)),
            mo = /^[0-7]{3}/.exec(rest)
        if(in_charset){
            try{
                var res = $B.test_escape(rest, -1)
                if(res){
                    return {
                        type: 'u',
                        ord: res[0].codePointAt(0),
                        char: res[0],
                        length: res[1]
                    }
                }
            }catch(err){
                // ignore
            }
        }
        if(mo == null){
            mo = /^0[0-7]*/.exec(rest)
        }
        if(mo){
            var octal_value = parseInt(mo[0], 8)
            if(octal_value > 0o377){
                fail(`octal escape value \\` +
                    `${mo[0]} outside of range 0-0o377`, pos)
            }
            return {
                type: 'o',
                ord: octal_value,
                char: chr(octal_value),
                length: 1 + mo[0].length
            }
        }
        var mo = /^\d{1,2}/.exec(rest) // backref is at most 99
        if(mo){
            return {
                type: 'backref',
                value: parseInt(mo[0]),
                length: 1 + mo[0].length
            }
        }
        var trans = {a: chr(7), f: '\f', n: '\n', r: '\r', t: '\t', v: '\v'},
            res = trans[chr(special)]
        if(res){
            return ord(res)
        }
        if(chr(special).match(/[a-zA-Z]/)){
            fail("bad escape \\" + chr(special), pos)
        }else{
            return special
        }
    }
}

function check_character_range(t, positions){
    // Check if last 2 items in t are a valid character range
    var start = t[t.length - 2],
        end = t[t.length - 1]
    if(start instanceof CharacterClass || end instanceof CharacterClass){
        fail(`bad character range ${start}-${end}`,
            positions[positions.length - 2])
    }else if(end < start){
        fail(`bad character range ${start}-${end}`,
            positions[positions.length - 2])
    }
    t.splice(t.length - 2, 2, {
        type: 'character_range',
        start: start,
        end: end,
        ord: [start.ord, end.ord]
    })
}

function parse_character_set(text, pos, is_bytes){
    // Parse character set starting at position "pos" in "text"
    // pos is the position of the leading "["
    var start = pos,
        result = {items: []},
        positions = []
    pos++
    if(text[pos] == CARET){
        result.neg = true
        pos++
    }else if(text[pos] == BRACKET_CLOSE){
        // a leading ] is the character "]", not the set end
        result.items.push(']')
        positions.push(pos)
        pos++
    }else if(text[pos] == BRACKET_OPEN){
        // send FutureWarning
        warn(_b_.FutureWarning, "Possible nested set", pos, text)
    }
    var range = false
    while(pos < text.length){
        var cp = text[pos],
            char = chr(cp)
        if(char == ']'){
            if(pos == start + 2 && result.neg){
                // in "[^]]", the first ] is the character "]"
                result.items.push(']')
            }else{
                return [result, pos]
            }
        }
        if(char == '\\'){
            var escape = escaped_char({
                    codepoints: text,
                    pos,
                    in_charset: true,
                    is_bytes
                })
            if(typeof escape == "number"){
                var s = chr(escape)
                escape = {
                    ord: escape,
                    length: 2,
                    toString: function(){
                        return s
                    }
                }
            }
            if(escape.type == "num"){
                // [\9] is invalid
                fail("bad escape 1 \\" +
                    escape.value.toString()[0], pos)
            }
            result.items.push(escape)
            positions.push(pos)
            if(range){
                check_character_range(result.items, positions)
            }
            range = false
            pos += escape.length
        }else if(char == '-'){
            // Character range, or character "-"
            if(pos == start + 1 ||
                    (result.neg && pos == start + 2) ||
                    pos == text.length - 2 || // [a-]
                    range ||
                    (result.items.length > 0 &&
                    result.items[result.items.length - 1].type ==
                        "character_range")){
                result.items.push({
                    ord: cp,
                    char,
                    toString: function(){
                        return this.char
                    }
                })
                if(text[pos + 1] == cp){
                    warn(_b_.FutureWarning, "Possible set difference", pos, text)
                }
                pos++
                if(range){
                    check_character_range(result.items, positions)
                }
                range = false
            }else{
                range = true
                if(text[pos + 1] == cp){
                    warn(_b_.FutureWarning, "Possible set difference", pos, text)
                }
                pos++
            }
        }else{
            positions.push(pos)
            result.items.push({
                ord: cp,
                char,
                toString: function(){
                    return this.char
                }
            })
            if(range){
                check_character_range(result.items, positions)
            }
            range = false
            // FutureWarning for consecutive "&", "|" or "~"
            if(char == "&" && text[pos + 1] == cp){
                warn(_b_.FutureWarning, "Possible set intersection", pos, text)
            }else if(char == "|" && text[pos + 1] == cp){
                warn(_b_.FutureWarning, "Possible set union", pos, text)
            }else if(char == "~" && text[pos + 1] == cp){
                warn(_b_.FutureWarning, "Possible set symmetric difference",
                    pos, text)
            }
            pos++
        }
    }
    fail("unterminated character set", start)
}

function* tokenize(pattern, type, _verbose){
    // pattern is a list of codepoints
    var is_bytes = type == "bytes"
    // verbose_stack is the stack of verbose state for each group in the regex
    var verbose_stack = [_verbose],
        verbose = _verbose,
        parenth_pos
    var pos = 0
    while(pos < pattern.length){
        var cp = pattern[pos],
            char = String.fromCharCode(cp)
        if(verbose){
            // current group is in verbose mode
            if(char == "#"){
                // skip until next line feed
                while(pos < pattern.length && pattern[pos] != 10){
                    pos++
                }
                pos++
                continue
            }else{
                while(pos < pattern.length &&
                        [9, 10, 11, 12, 13, 32].indexOf(pattern[pos]) > -1){
                    pos++
                }
            }
            cp = pattern[pos]
            if(cp === undefined){
                break
            }
            char = String.fromCharCode(cp)
            if(char == '#'){
                continue
            }
        }
        if(char == '('){
            parenth_pos = pos
            if(pattern[pos + 1] == QUESTION_MARK){
                if(pattern[pos + 2] == LETTERS.P){
                    if(pattern[pos + 3] == INF){
                        var name = [],
                            i = pos + 4
                        while(i < pattern.length){
                            if(pattern[i] == SUP){
                                break
                            }else if(pattern[i] == PARENTH_CLOSE){
                                fail("missing >, unterminated name", pos)
                            }
                            name.push(pattern[i])
                            i++
                        }
                        var sname = StringObj.from_codepoints(name)
                        validate_group_name(sname, pos, is_bytes)
                        name = sname
                        if(i == pattern.length){
                            fail("missing >, unterminated name", pos)
                        }
                        yield new Group(pos, {type: 'name_def', value: name})
                        verbose_stack.push(verbose)
                        pos = i + 1
                        continue
                    }else if(pattern[pos + 3] == EQUAL){
                        var name = [],
                            i = pos + 4
                        while(i < pattern.length){
                            if(pattern[i] == PARENTH_CLOSE){
                                break
                            }
                            name.push(pattern[i])
                            i++
                        }
                        name = StringObj.from_codepoints(name)
                        validate_group_name(name, pos, is_bytes)
                        if(i == pattern.length){
                            fail("missing ), unterminated name", pos)
                        }
                        yield new BackReference(pos, 'name', name.string)
                        pos = i + 1
                        continue
                    }else if(pattern[pos + 3] === undefined){
                        fail("unexpected end of pattern", pos)
                    }else{
                        fail("unknown extension ?P" + chr(pattern[pos + 3]), pos)
                    }
                }else if(pattern[pos + 2] == PARENTH_OPEN){
                    var ref = [],
                        i = pos + 3
                    while(i < pattern.length){
                        if(pattern[i] == PARENTH_CLOSE){
                            break
                        }
                        ref.push(pattern[i])
                        i++
                    }
                    var sref = StringObj.from_codepoints(ref)
                    if(sref.string.match(/^\d+$/)){
                        ref = parseInt(sref.string)
                    }else{
                        validate_num_or_name(sref, pos, is_bytes)
                        ref = sref.string
                    }
                    if(i == pattern.length){
                        fail("missing ), unterminated name", pos)
                    }
                    yield new ConditionalBackref(pos, ref)
                    pos = i + 1
                    continue
                }else if(pattern[pos + 2] == EQUAL){
                    // (?=...) : lookahead assertion
                    yield new Group(pos, {type: 'lookahead_assertion'})
                    verbose_stack.push(verbose)
                    pos += 3
                    continue
                }else if(pattern[pos + 2] == EXCLAMATION_MARK){
                    // (?!...) : negative lookahead assertion
                    yield new Group(pos, {type: 'negative_lookahead_assertion'})
                    verbose_stack.push(verbose)
                    pos += 3
                    continue
                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<!'){
                    // (?<!...) : negative lookbehind
                    yield new Group(pos, {type: 'negative_lookbehind'})
                    verbose_stack.push(verbose)
                    pos += 4
                    continue
                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<='){
                    // (?<=...) : positive lookbehind
                    yield new Group(pos, {type: 'positive_lookbehind'})
                    verbose_stack.push(verbose)
                    pos += 4
                    continue
                }else if(pattern[pos + 2] == INF){
                    pos += 3
                    if(pos == pattern.length){
                        fail("unexpected end of pattern", pos)
                    }
                    fail("unknown extension ?<" + _b_.chr(pattern[pos]), pos)
                }else if(pattern[pos + 2] == COLON){
                    yield new Group(pos, {non_capturing: true})
                    verbose_stack.push(verbose)
                    pos += 3
                    continue
                }else if(pattern[pos + 2] == SUP){
                    yield new Group(pos, {atomic: true})
                    verbose_stack.push(verbose)
                    pos += 3
                    continue
                }else if(pattern[pos + 2] === undefined){
                    fail("unexpected end of pattern", pos)
                }

                var flags = to_codepoint_list('aiLmsux'),
                    auL_flags = to_codepoint_list('auL'),
                    flags_start = pos
                if(pattern[pos + 2] == MINUS ||
                        flags.indexOf(pattern[pos + 2]) > -1){
                    if(pattern[pos + 2] == MINUS){
                        var on_flags = [],
                            has_off = true,
                            off_flags = []
                        pos += 3
                    }else{
                        var on_flags = [chr(pattern[pos + 2])],
                            has_off = false,
                            off_flags = [],
                            auL = auL_flags.indexOf(pattern[pos + 2]) > -1 ?
                                1 : 0,
                            closed = false
                        pos += 3
                        while(pos < pattern.length){
                            if(flags.indexOf(pattern[pos]) > -1){
                                if(auL_flags.indexOf(pattern[pos]) > -1){
                                    auL++
                                    if(auL > 1){
                                        fail("bad inline flags: flags 'a', 'u'" +
                                            " and 'L' are incompatible", pos)
                                    }
                                }
                                on_flags.push(chr(pattern[pos]))
                                pos++
                            }else if(pattern[pos] == MINUS){
                                has_off = true
                                closed = true
                                pos++
                                break
                            }else if(String.fromCharCode(pattern[pos]).
                                    match(/[a-zA-Z]/)){
                                fail("unknown flag", pos)
                            }else if(pattern[pos] == PARENTH_CLOSE){
                                closed = true
                                break
                            }else if(pattern[pos] == COLON){
                                yield new Group(pos, {name: "Group", type: "flags"})
                                verbose_stack.push(verbose)
                                closed = true
                                break
                            }else{
                                fail("missing -, : or )", pos)
                            }
                        }
                        if(! closed){
                            fail("missing -, : or )", pos)
                        }
                    }
                    if(has_off){
                        while(pos < pattern.length){
                            if(flags.indexOf(pattern[pos]) > -1){
                                if(auL_flags.indexOf(pattern[pos]) > -1){
                                    fail("bad inline flags: cannot turn off " +
                                        "flags 'a', 'u' and 'L'", pos)
                                }
                                if(on_flags.indexOf(chr(pattern[pos])) > -1){
                                    fail("bad inline flags: flag turned on and off", pos)
                                }
                                off_flags.push(chr(pattern[pos]))
                                pos++
                            }else if(pattern[pos] == COLON){
                                yield new Group(pos, {name: "Group", type: "flags"})
                                verbose_stack.push(verbose)
                                break
                            }else if(String.fromCharCode(pattern[pos]).
                                    match(/[a-zA-Z]/)){
                                fail("unknown flag", pos)
                            }else if(off_flags.length == 0){
                                fail("missing flag", pos)
                            }else{
                                fail("missing :", pos)
                            }
                        }
                        if(off_flags.length == 0){
                            fail("missing flag", pos)
                        }
                    }
                    if(has_off && pattern[pos] != COLON){
                        fail("missing :", pos)
                    }
                    if(on_flags.length == 0 && off_flags.length == 0){
                        fail("missing flag", pos)
                    }
                    var set_flags = new SetFlags(flags_start,
                        {on_flags, off_flags})

                    yield set_flags
                    // reset verbose
                    if(on_flags.indexOf('x') > -1){
                        verbose = true
                        verbose_stack.push(verbose)
                    }
                    if(off_flags.indexOf('x') > -1){
                        verbose = false
                    }
                    if(! closed){
                        node = set_flags
                    }
                    pos++
                }else if(pattern[pos + 2] == ord('#')){
                    pos += 3
                    while(pos < pattern.length){
                        if(pattern[pos] == PARENTH_CLOSE){
                            break
                        }
                        pos++
                    }
                    if(pos == pattern.length){
                        fail("missing ), unterminated comment", pos)
                    }
                    pos++
                    continue
                }else{
                    fail("unknown extension ?" + _b_.chr(pattern[pos + 2]),
                        pos)
                }
            }else{
                yield new Group(pos)
                verbose_stack.push(verbose)
                pos++
            }
        }else if(cp == PARENTH_CLOSE){
            yield new GroupEnd(pos)
            verbose_stack.pop()
            verbose = $last(verbose_stack)
            pos++
        }else if(cp == BACKSLASH){
            var escape = escaped_char({codepoints: pattern, pos, is_bytes})
            if(escape instanceof CharacterClass){
                yield escape
                pos += escape.length
            }else if(escape.char !== undefined){
                yield new Char(pos, escape.ord)
                pos += escape.length
            }else if(escape.type == "backref"){
                var len = escape.length
                if(escape.value.length > 2){
                    escape.value = escape.value.substr(0, 2)
                    len = 2
                }
                yield new BackReference(pos, "num", escape.value)
                pos += len
            }else if(typeof escape == "number"){
                // eg "\."
                var esc = new Char(pos, escape)
                esc.escaped = true
                yield esc
                pos += 2
            }else{
                yield new Char(pos, escape)
                pos += escape.length
            }
        }else if(cp == BRACKET_OPEN){
            // Set of characters
            var set,
                end_pos
            [set, end_pos] = parse_character_set(pattern, pos, is_bytes)
            yield new CharacterSet(pos, set)
            pos = end_pos + 1
        }else if('+?*'.indexOf(char) > -1){
            yield new Repeater(pos, char)
            pos++
        }else if(cp == BRACE_OPEN){
            var reps = /\{(\d*)((,)(\d*))?\}/.exec(
                    from_codepoint_list(pattern.slice(pos)))
            if(reps && reps[0] != '{}'){
                if(reps[1] == ""){
                    var limits = [0]
                }else{
                    var limits = [parseInt(reps[1])]
                }
                if(reps[4] !== undefined){
                    if(reps[4] == ""){
                        var max = Number.POSITIVE_INFINITY
                    }else{
                        var max = parseInt(reps[4])
                    }
                    limits.push(max)
                }
                yield new Repeater(pos, limits)
                pos += reps[0].length
            }else if(pattern[pos + 1] == BRACE_CLOSE){
                // {} is the characters "{" and "}"
                yield new Char(pos, BRACE_OPEN)
                pos++
            }else{
                yield new Char(pos, BRACE_OPEN)
                pos++
            }
        }else if(cp == OR){
            yield new Or(pos)
            pos++
        }else if(cp == DOT){
            yield new CharacterClass(pos, cp, 1)
            pos++
        }else if(cp == CARET){
            yield new StringStart(pos)
            pos++
        }else if(cp == DOLLAR){
            yield new StringEnd(pos)
            pos++
        }else{
            yield new Char(pos, cp)
            pos++
        }
    }
}

function transform_repl(data, pattern){
    // data.repl is a StringObj instance
    var repl = data.repl.string
    repl = repl.replace(/\\n/g, '\n')
    repl = repl.replace(/\\r/g, '\r')
    repl = repl.replace(/\\t/g, '\t')
    repl = repl.replace(/\\b/g, '\b')
    repl = repl.replace(/\\v/g, '\v')
    repl = repl.replace(/\\f/g, '\f')
    repl = repl.replace(/\\a/g, '\x07')
    // detect backreferences
    var pos = 0,
        escaped = false,
        br = false,
        repl1 = "",
        has_backref = false
    while(pos < repl.length){
        br = false
        if(repl[pos] == "\\"){
            escaped = ! escaped
            if(escaped){
                pos++
                continue
            }
        }else if(escaped){
            escaped = false
            var mo = /^\d+/.exec(repl.substr(pos))
            if(mo){
                var cps = to_codepoint_list(repl)
                var escape = escaped_char({
                        codepoints: cps,
                        pos: pos - 1,
                        is_bytes: cps.type == "bytes"
                     })
                if(escape.type == "o"){
                    if(escape.ord > 0o377){
                        fail(`octal escape value \\${mo[0]} ` +
                            " outside of range 0-0o377", pos)
                    }
                    repl1 += escape.char
                    pos += escape.length - 1
                    continue
                }else if(escape.type != "backref"){
                    var group_num = mo[0].substr(0,
                        Math.min(2, mo[0].length))
                    fail(`invalid group reference ${group_num}`, pos)
                }else{
                    // only keep first 2 digits
                    var group_num = mo[0].substr(0,
                        Math.min(2, mo[0].length))
                    // check that pattern has the specified group num
                    if(pattern.groups === undefined){
                        throw _b_.AttributeError.$factory("$groups")
                    }
                    if(pattern.groups[group_num] === undefined){
                        fail(`invalid group reference ${group_num}`,
                            pos)
                    }else{
                        mo[0] = group_num
                    }
                }
                if(! has_backref){
                    var parts = [repl.substr(0, pos - 1),
                            parseInt(mo[0])]
                }else{
                    parts.push(repl.substring(next_pos, pos - 1))
                    parts.push(parseInt(mo[0]))
                }
                has_backref = true
                var next_pos = pos + mo[0].length
                br = true
                pos += mo[0].length
            }else if(repl[pos] == "g"){
                pos++
                if(repl[pos] != '<'){
                    fail("missing <", pos)
                }
                pos++
                mo = /(.*?)>/.exec(repl.substr(pos))
                if(mo){
                    if(mo[1] == ""){
                        pos += mo[0].length
                        fail("missing group name", pos - 1)
                    }
                    var group_name = mo[1]
                    if(group_name == '0'){
                        //  The backreference \g<0> substitutes in the entire
                        // substring matched by the RE.
                    }else if(/^\d+$/.exec(group_name)){
                        if(pattern.groups[group_name] === undefined){
                            fail(`invalid group reference ${group_name}`,
                                pos)
                        }
                    }else{
                        try{
                            var group_num = _b_.int.$factory(group_name)
                            if(group_num < 0){
                                fail(`bad character in group name ` +
                                    `'${group_name}' at position ${pos}`, pos)
                            }
                            warn(_b_.DeprecationWarning,
                                `bad character in group name '${group_name}' ` +
                                `at position ${pos}`)
                            mo[1] = group_name = group_num + ''
                        }catch(err){
                            if(! _b_.str.isidentifier(group_name)){
                                var cps = to_codepoint_list(group_name)
                                if(! $B.is_XID_Start(cps[0])){
                                    fail("bad character in group name '" +
                                        group_name + "'", pos)
                                }else{
                                    for(cp of cps.slice(1)){
                                        if(! $B.is_XID_Continue(cp)){
                                            fail("bad character in group name '" +
                                                group_name + "'", pos)
                                        }
                                    }
                                }
                            }else if(data.type == "bytes" && ! is_ascii(group_name)){
                                var b = _b_.bytes.$factory(group_name, 'latin-1'),
                                    s = _b_.bytes.decode(b, 'ascii', 'backslashreplace')
                                warn(_b_.DeprecationWarning,
                                    `bad character in group name '${s}'` +
                                    ` at position ${pos}`)
                            }
                        }
                        if(pattern.groups[group_name] === undefined){
                            throw _b_.IndexError.$factory(
                                `unknown group name '${group_name}'`,
                                pos)
                        }
                    }
                    if(! has_backref){
                        var parts = [repl.substr(0, pos - 3),
                                mo[1]]
                    }else{
                        parts.push(repl.substring(next_pos, pos - 3))
                        parts.push(mo[1])
                    }
                    has_backref = true
                    var next_pos = pos + mo[0].length
                    br = true
                    pos = next_pos
                }else{
                    if(repl.substr(pos).length > 0){
                        fail("missing >, unterminated name", pos)
                    }else{
                        fail("missing group name", pos)
                    }
                }
            }else{
                if(/[a-zA-Z]/.exec(repl[pos])){
                    fail("unknown escape", pos)
                }
                pos += repl[pos]
            }
        }
        if(! br){
            repl1 += repl[pos]
            pos ++
        }
    }
    data.repl1 = repl1
    if(has_backref){
        parts.push(repl.substr(next_pos))
        data.repl = function(bmo){
            var mo = bmo.mo,
                res = parts[0],
                groups = mo.$groups,
                s = mo.string,
                group,
                is_bytes = s.type == 'bytes'
            for(var i = 1, len = parts.length; i < len; i += 2){
                if(parts[i] == 0){
                    var x = s.substring(mo.start, mo.end)
                    if(is_bytes){
                        x = _b_.bytes.decode(x, 'latin-1')
                    }
                    res += x
                }else if(groups[parts[i]] === undefined){
                    if(mo.node.$groups[parts[i]] !== undefined){
                        // group is defined in the RE, but didn't contribute
                        // to the match
                        // groups[parts[i]] = ''
                    }else{
                        // group is not defined in the RE
                        pos++
                        group_num = parts[i].toString().substr(0, 2)
                        fail(`invalid group reference ${group_num}`, pos)
                    }
                }else{
                    group = groups[parts[i]]
                    var x = s.substring(group.start, group.end)
                    if(is_bytes){
                        x = _b_.bytes.decode(x, 'latin-1')
                    }
                    res += x
                }
                res += parts[i + 1]
            }
            return res
        }
    }else{
        data.repl = new StringObj(repl)
    }
    return data
}
var Flag = $B.make_class("Flag",
    function(value){
        return {
            __class__: Flag,
            value
        }
    }
)

Flag.__and__ = function(self, other){
    if(other.__class__ === Flag){
        return Flag.$factory(self.value & other.value)
    }else if(typeof other == "number" || typeof other == "boolean"){
        return Flag.$factory(self.value & other)
    }
    return _b_.NotImplemented
}

Flag.__index__ = function(self){
    return self.value
}

Flag.__invert__ = function(self){
    return Flag.$factory(~self.value)
}

Flag.__eq__ = function(self, other){
    return self.value == other.value
}

Flag.__or__ = function(self, other){
    if(other.__class__ === Flag){
        return Flag.$factory(self.value | other.value)
    }else if(typeof other == "number" || typeof other == "boolean"){
        return Flag.$factory(self.value | other)
    }
    return _b_.NotImplemented
}

Flag.__rand__ = function(self, other){
    if(typeof other == "number" || $B.$isinstance(other, _b_.int)){
        if(other == 0){
            return false // Flag.$factory(self.value)
        }
        return self.value & other
    }
    return _b_.NotImplemented
}

Flag.__ror__ = function(self, other){
    if(typeof other == "number" || $B.$isinstance(other, _b_.int)){
        if(other == 0){
            return self.value
        }
        return self.value | other
    }
    return _b_.NotImplemented
}

Flag.__repr__ = Flag.__str__ = function(self){
    if(self.value == 0){
        return "re.none"
    }
    var inverted = self.value < 0

    var t = [],
        value = inverted ? ~self.value : self.value
    for(var flag in inline_flags){
        if(value & inline_flags[flag].value){
            t.push('re.' + flag_names[flag])
            value &= ~inline_flags[flag].value
        }
    }
    if(value > 0){
        t.push('0x' + value.toString(16))
    }
    var res = t.join('|')
    if(inverted){
        if(t.length > 1){
            return '~(' + res + ')'
        }else{
            return '~' + res
        }
    }
    return res
}

Flag.__xor__ = function(self, other){
    return Flag.$factory(self.value ^ other.value)
}

$B.set_func_names(Flag, "re")

var no_flag = {}

var Scanner = $B.make_class("Scanner",
    function(pattern, string, pos, endpos){
        var $ = $B.args('__init__', 4,
                    {pattern: null, string: null, pos: null, endpos:null},
                    ['pattern', 'string', 'pos', 'endpos'],
                    arguments, {pos: 0, endpos: _b_.None}, null, null),
            endpos = endpos === _b_.None ? $.string.length : endpos
        return {
            __class__: Scanner,
            $string: $.string,
            pattern: $.pattern,
            pos: $.pos,
            endpos
        }
    }
)

Scanner.match = function(self){
    return Pattern.match(self.pattern, self.$string)
}

Scanner.search = function(self){
    if(! self.$iterator){
        self.$iterator = module.finditer(self.pattern, self.$string)
    }
    // return last match
    var mo = _b_.None
    for(mo of self.$iterator.js_gen){
        // set mo
    }
    return mo
}

var GroupIndex = $B.make_class("GroupIndex",
    function(self, _default){
        var res = $B.empty_dict()
        res.__class__ = GroupIndex
        for(var key in self.$groups){
            if(isNaN(parseInt(key))){
                _b_.dict.$setitem(res, key, self.$groups[key].num)
            }
        }
        return res
    }
)
GroupIndex.__mro__ = [_b_.dict, _b_.object]
GroupIndex.__setitem__ = function(){
    throw _b_.TypeError.$factory("read only")
}

$B.set_func_names(GroupIndex, "re")

var Pattern = $B.make_class("Pattern",
    function(pattern){
        var nb_groups = 0
        for(var key in pattern.groups){
            if(isFinite(key)){
                nb_groups++
            }
        }
        return {
            __class__: Pattern,
            pattern: pattern.text,
            groups: nb_groups,
            flags: pattern.flags,
            $groups: pattern.groups,
            $pattern: pattern
        }
    }
)

Pattern.__copy__ = function(self){
    return self
}

Pattern.__deepcopy__ = function(self){
    return self
}

Pattern.__eq__ = function(self, other){
    if(other.$pattern && self.$pattern.type != other.$pattern.$type){
        // warn(_b_.BytesWarning, "cannot compare str and bytes pattern", 1)
    }
    return self.pattern == other.pattern &&
        self.flags.value == other.flags.value
}

Pattern.__hash__ = function(self){
    // best effort ;-)
    return _b_.hash(self.pattern) + self.flags.value
}

Pattern.__new__ = Pattern.$factory

Pattern.__reduce__ = function(self){
    return Pattern.__reduce_ex__(self, 4)
}

Pattern.__reduce_ex__ = function(self, protocol){
    var res = _reconstructor,
        state = [self.__class__].concat(self.__class__.__mro__)
    var d = $B.empty_dict()
    _b_.dict.$setitem(d, 'pattern', self.pattern)
    _b_.dict.$setitem(d, 'flags', self.flags.value)
    state.push(d)
    return $B.fast_tuple([res, $B.fast_tuple(state)])
}

function _reconstructor(cls, base, state){
    var pattern = _b_.dict.$getitem(state, 'pattern'),
        flags = Flag.$factory(_b_.dict.$getitem(state, 'flags'))
    return module.compile(pattern, flags)
}

Pattern.__repr__ = Pattern.__str__ = function(self){
    var text = self.$pattern.text,
        s = text
    if(self.$pattern.type == "bytes"){
        s = _b_.str.$factory(_b_.str.encode(s, 'latin-1'))
    }else{
        s = _b_.repr(s)
    }
    s = s.substr(0, 200)
    var res = `re.compile(${s}`,
        flags = self.$pattern.flags
    if(flags === no_flag){
        return res + ')'
    }
    // mask UNICODE flag
    if(flags.__class__ === Flag){
        // copy flag, otherwise U.value would become 0
        flags = Flag.$factory(flags.value)
        flags.value &= ~U.value
    }else if(typeof flags == "number"){
        flags &= ~U.value
    }
    if(flags != 0 && flags.value != 0){
        res += `, ${_b_.str.$factory(flags)}`
    }
    return res + ')'
}

Pattern.findall = function(self){
    var iter = Pattern.finditer.apply(null, arguments).js_gen,
        res = []

    while(true){
        var next = iter.next()
        if(next.done){
            return res
        }
        var bmo = next.value,
            mo = bmo.mo,
            groups = MatchObject.groups(bmo)

        // replace None by the empty string
        for(var i = 0, len = groups.length; i < len; i++){
            groups[i] = groups[i] === _b_.None ? "" : groups[i]
        }
        if(groups.length > 0){
            if(groups.length == 1){
                res.push(groups[0])
            }else{
                res.push($B.fast_tuple(groups))
            }
        }else{
            res.push(mo.string.substring(mo.start, mo.end))
        }
    }
}

Pattern.finditer = function(self){
    var $ = $B.args("finditer", 4,
            {self: null, string: null, pos: null, endpos: null},
            'self string pos endpos'.split(' '), arguments,
            {pos: 0, endpos: _b_.None}, null, null)
    var data = prepare({string: $.string})
    var endpos = $.endpos === _b_.None ? data.string.length : $.endpos
    return $B.generator.$factory(iterator)(self.$pattern, data.string,
            self.flags, $.string, $.pos, endpos)
}

Pattern.fullmatch = function(self, string){
    var $ = $B.args("match", 4,
                    {self: null, string: null, pos: null, endpos: null},
                    ["self", "string", "pos", "endpos"], arguments,
                    {pos: 0, endpos: _b_.None}, null, null)
    if($.endpos === _b_.None){
        $.endpos = $.string.length
    }
    var data = prepare({string: $.string})
    if(self.$pattern.type != data.string.type){
        throw _b_.TypeError.$factory("not the same type for pattern " +
            "and string")
    }
    var fullmatch_pattern = create_fullmatch_pattern($.self.$pattern)
    var mo = match(fullmatch_pattern, data.string, $.pos, $.endpos)
    if(mo && mo.end - mo.start == $.endpos - $.pos){
        return MatchObject.$factory(mo)
    }else{
        return _b_.None
    }
}

Pattern.groupindex = {
    __get__: function(self){
        return GroupIndex.$factory(self)
    }
}

Pattern.match = function(self, string){
    var $ = $B.args("match", 4,
                    {self: null, string: null, pos: null, endpos: null},
                    ["self", "string", "pos", "endpos"], arguments,
                    {pos: 0, endpos: _b_.None}, null, null)
    if($.endpos === _b_.None){
        $.endpos = $.string.length
    }
    var data = prepare({string: $.string})
    if(self.$pattern.type != data.string.type){
        throw _b_.TypeError.$factory("not the same type for pattern " +
            "and string")
    }
    var mo = match($.self.$pattern, data.string, $.pos,
        $.endpos)
    return mo ? MatchObject.$factory(mo) : _b_.None
}

Pattern.scanner = function(self, string, pos, endpos){
    return Scanner.$factory.apply(null, arguments) // self, string, pos, endpos)
}

Pattern.search = function(self, string){
    var $ = $B.args("match", 4,
                    {self: null, string: null, pos: null, endpos: null},
                    ["self", "string", "pos", "endpos"], arguments,
                    {pos: 0, endpos: _b_.None}, null, null)
    var data = prepare({string: $.string})
    if(self.$pattern.type != data.string.type){
        throw _b_.TypeError.$factory("not the same type for pattern " +
            "and string")
    }
    if($.endpos === _b_.None){
        $.endpos = data.string.length
    }
    var pos = $.pos
    while(pos <= $.endpos){
        var mo = match(self.$pattern, data.string, pos)
        if(mo){
            return MatchObject.$factory(mo)
        }else{
            pos++
        }
    }
    return _b_.None
}

Pattern.split = function(){
    return module.split.apply(null, arguments)
}

Pattern.sub = function(){
    var $ = $B.args("match", 4,
                    {self: null, repl: null, string: null, count: null},
                    "self repl string count".split(' '), arguments,
                    {count: 0}, null, null)
    var data = prepare({string: $.string})
    if($.self.$pattern.type != data.string.type){
        throw _b_.TypeError.$factory("not the same type for pattern " +
            "and string")
    }

    return module.sub($.self, $.repl, $.string, $.count)
}

$B.set_func_names(Pattern, "re")

function Node(parent){
    this.parent = parent
    this.items = []
}

Node.prototype.add = function(item){
    this.items.push(item)
    item.parent = this
}

Node.prototype.fixed_length = function(){
    // Return the sum of items lengths if fixed, else undefined
    if(this.repeat){
        return false
    }
    var len = 0
    for(var item of this.items){
        if(item.fixed_length === undefined){
            console.log("pas de fixed length", item)
            alert()
        }
        var sublen = item.fixed_length()
        if(sublen === false){
            return false
        }
        len += sublen
    }
    return len
}

function get_top(node){
    var top = node.parent
    while(top.parent){
        top = top.parent
    }
    return top
}

var BackReference = function(pos, type, value){
    // for "\number"
    this.name = "BackReference"
    this.pos = pos
    this.type = type // "name" or "num"
    this.value = value
    this.groups = []
}

BackReference.prototype.fixed_length = function(){
    // Return length of referenced group if it is fixed, else undefined
    if(this.repeat){
        return undefined
    }
    var group = this.get_group()
    if(group.fixed_length === undefined){
        console.log("group", group, "no fixed length")
    }
    return group === undefined ? false : group.fixed_length()
}

BackReference.prototype.get_group = function(){
    var top = get_top(this)
    return top.$groups[this.value]
}

BackReference.prototype.match = function(string, pos, endpos, groups){
    this.repeat = this.repeat || {min: 1, max: 1}

    var group = groups[this.value]
    if(group === undefined){
        if(this.repeat.min == 0){
            return {
                nb_min: 0,
                nb_max: 0
            }
        }
        return false
    }

    // Get the codepoints matched by the referenced group
    group_cps = string.codepoints.slice(group.start, group.end)

    // search (repetitions of) the matched group codepoints
    var _pos = pos,
        nb = 0,
        group_len = group_cps.length,
        flag,
        cp
    while(string.cp_at(_pos) !== undefined && nb < this.repeat.max){
        flag = true
        for(var i = 0; i < group_len; i++){
            cp = string.cp_at(_pos + i)
            if(cp != group_cps[i]){
                flag = false
                break
            }
        }
        if(flag){
            nb++
            _pos += group_len
        }else{
            break
        }
    }
    if(nb >= this.repeat.min){
        // Returns the accepted minimum and maximum number of repeats
        // and the length of each repeat
        return {
            nb_min: this.repeat.min,
            nb_max: nb,
            group_len
        }
    }
    return false
}

BackReference.prototype.toString = function(){
    return "BackRef to group" + this.value
}

var Case = function(){
    this.name = "Case"
    this.items = []
    this.groups = []
    this.text = 'Case '
}

Case.prototype.add = function(item){
    this.items.push(item)
    item.parent = this
}

Case.prototype.fixed_length = function(){
    var len
    for(var item of this.items){
        var fl = item.fixed_length()
        if(fl === false){
            return false
        }else if(len === undefined){
            len = fl
        }else{
            len += fl
        }
    }
    return len
}

Case.prototype.toString = function(){
    var res = 'Case '
    res += this.items.map(x => x + '').join(' ')
    return this.text = res
}

var Choice = function(){
    this.type = "choice"
    this.items = []
    this.groups = []
}

Choice.prototype.add = Node.prototype.add

Choice.prototype.fixed_length = function(){
    var len
    for(var item of this.items){
        var fl = item.fixed_length()
        if(fl === false){
            return false
        }else if(len === undefined){
            len = fl
        }else if(len != fl){
            return false
        }
     }
     return len
}

Choice.prototype.toString = function(){
    return 'Choice'
}

var EmptyString = {
        toString: function(){
            return ''
        },
        match: function(string, pos, endpos){
            return {nb_min: 0, nb_max: 0}
        },
        fixed_length: function(){
            return 1
        },
        length: 0
    },
    Flags = function(flags){
        this.flags = flags
    },
    GroupEnd = function(pos){
        this.name = "GroupEnd"
        this.pos = pos
        this.text = ')'
        this.toString = function(){
            return '[end of group #' + this.group.num + ']'
        }
    },
    Or = function(pos){
        this.name = "Or"
        this.pos = pos
        this.text = '|'
        this.toString = function(){
            return '|'
        }
    },
    Repeater = function(pos, op){
        this.name = "Repeater"
        this.pos = pos
        this.op = op
    }

function cased_cps(cp, ignore_case, ascii){
    // If cp is the codepoint of a cased Unicode character, return the list
    // of the codepoints that match the character in a case-insensitive way

    // ignore_case = this.flags && this.flags.value & IGNORECASE.value
    // ascii = this.flags.value & ASCII.value
    var cps,
        char = $B.codepoint2jsstring(cp)
    if(! ignore_case){
        return [cp]
    }
    if(ascii){
        // only test ASCII letters
        ignore_case = ignore_case && (
            (char >= 'a' && char <= 'z') ||
            (char >= 'A' && char <= 'Z'))
    }
    if(ignore_case){
        var char_up = char.toUpperCase(),
            char_low = char.toLowerCase(),
            cps = new Set([cp, $B.jsstring2codepoint(char_low),
                $B.jsstring2codepoint(char_up)])
        // special cases
        if(char.toLowerCase() == "k"){
            cps.add(0x212a) // Kelvin sign
        }
        if(cp == 0x212a){
            cps.add(ord('k'))
            cps.add(ord('K'))
        }
        if(char.toLowerCase() == "s"){
            cps.add(0x017f) //  (Latin small letter long s)
        }
        if(cp == 0x017f){
            cps.add(ord('s'))
            cps.add(ord('S'))
        }
        if(char.toLowerCase() == 'i'){
            cps.add(0x0130) //  (Latin capital letter I with dot above)
            cps.add(0x0131) //  (Latin small letter dotless i)
        }
        if(cp == 0x0130 || cp == 0x0131){
            cps.add(ord('i'))
            cps.add(ord('I'))
        }
        return Array.from(cps)
    }else{
        cps = [cp]
    }
    return cps
}

var Char = function(pos, cp, groups){
    // character in a regular expression or in a character set
    // pos : position of the character in the pattern string
    // cp : the character's codepoint
    // groups (optional) : the groups that contain the character
    this.pos = pos
    this.cp = cp
    this.char = chr(this.cp)
    this.text = this.char
}

Char.prototype.fixed_length = function(){
    if(this.repeat){
        return this.repeat.min
    }
    return this.char === EmptyString ? 0 : 1
}

Char.prototype.match = function(string, pos, endpos){
    // Returns {pos1, pos2} such that "this" matches all the substrings
    // string[pos:i] with pos1 <= i < pos2, or false if no match
    this.repeat = this.repeat || {min: 1, max: 1}

    var i = 0

    // browse string codepoints until they don't match, or the number of
    // matches is above the maximum allowed
    if(this.flags){
        if(this.flags.value & ASCII.value){
            if(this.cp > 127){
                return false
            }
        }
        if(this.flags.value & IGNORECASE.value &&
                (! this.is_bytes || this.cp <= 127)){
            // Flag IGNORECASE set
            // For bytes pattern, case insensitive matching only works
            // for ASCII characters
            var char_upper = this.char.toUpperCase(),
                char_lower = this.char.toLowerCase(),
                cp
            while(i < this.repeat.max && pos + i < endpos){
                cp = string.cp_at(pos + i)
                var char = chr(cp)
                if(char.toUpperCase() != char_upper &&
                        char.toLowerCase() != char_lower){
                   break
                }
                i++
            }
        }else{
            while(pos + i < endpos &&
                    string.cp_at(pos + i) == this.cp &&
                    i < this.repeat.max){
                i++
            }
        }
    }else{
        while(pos + i < endpos &&
                string.cp_at(pos + i) == this.cp &&
                i < this.repeat.max){
            i++
        }
    }
    var nb = i
    if(nb >= this.repeat.min){
        // Number of repeats ok
        return {
            nb_min: this.repeat.min,
            nb_max: nb
        }
    }else{
        return false
    }
}

Char.prototype.toString = function(){
    var res = 'Char ' + this.text
    if(this.repeat !== undefined){
        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'
        if(this.non_greedy){
            res += '?'
        }
    }
    return res
}

function CharSeq(chars, flags){
    // sequence of consecutive characters
    this.chars = chars
    this.flags = flags
    this.merge_same_chars()
}

CharSeq.prototype.add_char = function(char){
    this.chars.push(char)
    this.merge_same_chars()
}

CharSeq.prototype.fixed_length = function(){
    var len = 0,
        cps = [],
        char_len
    for(var char of this.chars){
        if(! char.repeat){
            char_len = 1
        }else if(char.repeat.min == char.repeat.max){
            char_len = char.repeat.min
        }else{
            len = false
            break
        }
        for(var i = 0; i < char_len; i++){
            cps.push(char.cp)
        }
        len += char_len
    }
    this.cps = cps
    return this.len = len
}

CharSeq.prototype.match = function(string, pos, endpos){
    var mos = [],
        i = 0,
        backtrack,
        nb
    this.len = this.len === undefined ? this.fixed_length() : this.len
    // optimization if character sequence has a fixed length
    if(this.len !== false && ! (this.flags.value & IGNORECASE.value)){
        for(var i = 0; i < this.len; i++){
            if(string.cp_at(pos + i) !== this.cps[i]){
                return false
            }
        }
        return {nb_min: this.len, nb_max: this.len}
    }
    for(var i = 0, len = this.chars.length; i < len; i++){
        var char =  this.chars[i],
            mo = char.match(string, pos, endpos) // form {nb_min, nb_max}
        if(_debug.value){
            console.log('CharSeq match, pos', pos, 'char', char, 'mo', mo)
            alert()
        }
        if(mo){
            nb = char.non_greedy ? mo.nb_min : mo.nb_max
            mos.push({nb,
                      nb_min: mo.nb_min,
                      nb_max: mo.nb_max,
                      non_greedy: !!char.non_greedy
                     })
            pos += nb
        }else{
            // backtrack
            backtrack = false
            while(mos.length > 0){
                i--
                mo = mos.pop()
                pos -= mo.nb
                nb = mo.nb
                if(mo.non_greedy && nb < mo.nb_max){
                    nb += 1
                    backtrack = true
                }else if(! mo.non_greedy && nb - 1 >= mo.nb_min){
                    nb -= 1
                    backtrack = true
                }
                if(backtrack){
                    pos += nb
                    mo.nb = nb
                    mos.push(mo)
                    break
                }
            }
            if(mos.length == 0){
                return false
            }
        }
    }
    var nb = 0,
        last_mo = $B.last(mos)
    for(var mo of mos.slice(0, mos.length - 1)){
        nb += mo.nb
    }
    var res = {
        nb_min: nb + last_mo.nb_min,
        nb_max: nb + last_mo.nb_max
    }
    return res
}

CharSeq.prototype.merge_same_chars = function(){
    // b?b merged into b+ etc.
    var current,
        chars = [],
        merged
    for(var item of this.chars){
        if(current && current.char == item.char &&
                current.non_greedy === item.non_greedy){
            if(! current.repeat){
                current.repeat = {min: 1, max: 1}
            }
            if(item.repeat){
                current.repeat.min += item.repeat.min
                current.repeat.max += item.repeat.max
            }else{
                current.repeat.min += 1
                current.repeat.max += 1
            }
            merged = true
        }else{
            chars.push(item)
        }
        current = item
    }
    if(merged){
        this.chars = chars
    }
}

CharSeq.prototype.toString = function(){
    var res = ''
    for(var char of this.chars){
        res += char.text
    }
    return 'CharSeq ' + res
}

function CharacterClass(pos, cp, length, groups){
    this.cp = cp
    this.value = chr(cp)
    this.length = length
    this.pos = pos

    var flags = this.flags

    // Test function : test(string, pos) returns:
    // - true if "this" matches 1 character string[pos]
    // - [true, 0] if "this" matches the empty string at pos
    // - false or undefined if "this" doesn't match
    switch(this.value){
        case 'A':
            this.test_func = function(string, pos){
                if(pos == 0){
                    return [true, 0]
                }
            }
            break
        case 's':
            this.test_func = function(string, pos){
                var cp = string.cp_at(pos)
                return $B.in_unicode_category('Zs', cp) ||
                    $B.unicode_bidi_whitespace.indexOf(cp) > -1
            }
            break
        case 'S':
            this.test_func = function(string, pos){
                var cp = string.cp_at(pos)
                return cp !== undefined &&
                    ! $B.in_unicode_category('Zs', cp) &&
                    $B.unicode_bidi_whitespace.indexOf(cp) == -1
            }
            break
        case '.':
            this.test_func = function(string, pos){
                if(string.cp_at(pos) === undefined){
                    return false
                }
                if(this.flags.value & DOTALL.value){
                    return true
                }else{
                    return string.cp_at(pos) != 10
                }
            }
            break
        case 'd':
            this.test_func = function(string, pos){
                if(this.flags === undefined){
                    console.log("\\d, no flags", this)
                }
                var cp = string.cp_at(pos),
                    tester = (this.flags.value & ASCII.value) ?
                        is_ascii_digit : is_digit
                return tester(cp)
            }
            break
        case 'D':
            this.test_func = function(string, pos){
                var cp = string.cp_at(pos),
                    tester = (this.flags.value & ASCII.value) ?
                        is_ascii_digit : is_digit
                return ! tester(cp)
            }
            break
        case 'b':
            this.test_func = function(string, pos){
                var tester = is_word
                if(this.is_bytes || (this.flags.value & ASCII.value)){
                    tester = is_ascii_word
                }
                var cp = string.cp_at(pos),
                    ok = {nb_min: 0, nb_max: 0}

                // return true if char at pos is at the beginning or start
                // of a word
                if(pos == 0 && tester(cp)){
                    return ok
                }
                if(string.cp_at(pos) === undefined && tester(string.cp_at(pos - 1))){
                    return ok
                }
                if(pos > 0 && string.cp_at(pos) !== undefined){
                    if((tester(string.cp_at(pos - 1))) !==
                            tester(cp)){
                        return ok
                    }
                }
                return false
            }
            break
        case 'B':
            this.test_func = function(string, pos){
                var tester = is_word
                if(this.is_bytes || (this.flags.value & ASCII.value)){
                    tester = is_ascii_word
                }

                var cp = string.cp_at(pos),
                    ok = {nb_min: 0, nb_max: 0}
                // test is true if char at pos is not at the beginning or
                // start of a word
                if(pos == 0 && cp === undefined){
                    // empty string
                    return false
                }
                if(pos == 0 && tester(cp)){
                    return false
                }
                if(cp === undefined &&
                        tester(string.cp_at(pos - 1))){
                    return false
                }
                if(pos > 0 && cp !== undefined){
                    if(tester(string.cp_at(pos - 1)) !== tester(cp)){
                        return false
                    }
                }
                return ok
            }
            break
        case 'w':
            this.test_func = function(string, pos){
                var tester = is_word
                if(this.is_bytes || (this.flags.value & ASCII.value)){
                    tester = is_ascii_word
                }
                return tester(string.cp_at(pos))
            }
            break
        case 'W':
            this.test_func = function(string, pos){
                var tester = is_word
                if(this.is_bytes || (this.flags.value & ASCII.value)){
                    tester = is_ascii_word
                }
                return ! tester(string.cp_at(pos))
            }
            break
        case 'Z':
            this.test_func = function(string, pos){
                if(string.cp_at(pos) === undefined){
                    return {nb_min: 0, nb_max: 0}
                }
            }
            break
    }
}

CharacterClass.prototype.fixed_length = function(){
    return this.repeat ? false : 1
}

CharacterClass.prototype.match = function(string, pos, endpos){
    // Returns {pos1, pos2} such that "this" matches all the substrings
    // string[pos:i] with pos1 <= i < pos2, or false if no match
    if(pos === undefined){
        console.log('no pos')
        throw Error()
    }
    var len = string.length
    this.repeat = this.repeat || {min: 1, max: 1}

    // browse string codepoints until they don't match, or the number of
    // matches is above the maximum allowed
    var i = 0
    while(i < this.repeat.max && i < len){
        var test = this.test_func(string, pos + i, this.flags)
        if(! test){
            break
        }
        i++
    }

    var nb = i
    if(nb >= this.repeat.min){
        // Number of repeats ok
        if('bBAZ'.indexOf(this.value) > -1 ){
            return {nb_min: 0, nb_max: 0}
        }
        return {
            nb_min: this.repeat.min,
            nb_max: nb
        }
    }else{
        return false
    }
}

CharacterClass.prototype.nb_repeats = Char.prototype.nb_repeats

CharacterClass.prototype.toString = function(){
    return '\\' + this.value
}

var CharacterSet = function(pos, set, groups){
    // character set
    this.pos = pos
    this.set = set
    this.neg = set.neg
}

CharacterSet.prototype.fixed_length = function(){
    return 1
}

CharacterSet.prototype.match = function(string, pos, endpos){
    var ignore_case = this.flags && (this.flags.value & IGNORECASE.value),
        test,
        match = false,
        i = 0,
        cp

    this.repeat = this.repeat || {min: 1, max: 1}

    while(i < this.repeat.max && (cp = string.cp_at(pos + i)) !== undefined){
        test = false

        if(string.cp_at(pos) === undefined){
            cp = EmptyString
        }
        try{
            $B.codepoint2jsstring(cp)
        }catch(err){
            console.log(err.message)
            console.log('cp', cp, '\nstring', string, 'pos', pos)
            console.log($B.print_stack())
            throw _b_.Exception.$factory('bad codepoint')
        }
        var char = $B.codepoint2jsstring(cp),
            cps = cased_cps(cp, ignore_case, this.flags.value & ASCII.value),
            char_is_cased = cps.length > 1

        for(var cp1 of cps){
            for(var item of this.set.items){
                if(typeof item == 'string'){

                }
                if(Array.isArray(item.ord)){
                    if(cp1 >= item.ord[0] &&
                            cp1 <= item.ord[1]){
                        test = true
                        break
                    }else if(ignore_case && char_is_cased){
                        var start1 = chr(item.ord[0]).toUpperCase(),
                            end1 = chr(item.ord[1]).toUpperCase(),
                            char1 = char.toUpperCase()
                        if(char1 >= start1 && char1 <= end1){
                            test = true
                        }
                        var start1 = chr(item.ord[0]).toLowerCase(),
                            end1 = chr(item.ord[1]).toLowerCase(),
                            char1 = char.toLowerCase()
                        if(char1 >= start1 && char1 <= end1){
                            test = true
                        }
                    }
                }else if(item instanceof CharacterClass){
                    test = !! item.match(string, pos + i, endpos) // boolean
                }else{
                    if(item.ord == cp1){
                        test = true
                        break
                    }
                    item_str = typeof item == 'string' ? item : chr(item.ord)
                    if(item_str == char){
                        test = true
                        break
                    }
                    if(ignore_case && char_is_cased &&
                            (char.toUpperCase() == item_str.toUpperCase() ||
                            char.toLowerCase() == item_str.toLowerCase())){
                        test = true
                        break
                    }
                }
            }
        }
        if(this.neg){
            test = ! test
        }
        if(test){
            i++
        }else{
            break
        }
    }
    var nb = i
    if(nb >= this.repeat.min){
        // Number of repeats ok
        return {
            nb_min: this.repeat.min,
            nb_max: nb
        }
    }else{
        return false
    }

}

CharacterSet.prototype.nb_repeats = Char.prototype.nb_repeats

CharacterSet.prototype.toString = function(){
    return 'CharSet'
}

var ConditionalBackref = function(pos, group_ref){
    this.type = "conditional backref"
    this.pos = pos
    this.group_ref = group_ref
    this.chars = []
    this.match_codepoints = []
    this.nb_success = 0
    this.re_if_exists = new Group(pos)
    this.re_if_not_exists = new Group(pos)
    this.nb_options = 1
}

ConditionalBackref.prototype.add = function(item){
    if(this.nb_options == 1){
        this.re_if_exists.add(item)
    }else if(this.nb_options == 2){
        this.re_if_not_exists.add(item)
    }
    item.parent = this
}

ConditionalBackref.prototype.fixed_length = function(){
    var len = this.re_if_exists.fixed_length()
    if(len !== false && len == this.re_if_not_exists.fixed_length()){
        return len
    }
    return false
}

ConditionalBackref.prototype.match = function(string, pos, endpos, groups){
    var re = groups[this.group_ref] ? this.re_if_exists :
            this.re_if_not_exists,
        pattern = {node: re, text: re + ''},
        mo = match(pattern, string, pos, endpos, false, groups)
    if(mo){
        return {nb_min: mo.end - mo.start, nb_max: mo.end - mo.start}
    }
    return false
}

ConditionalBackref.prototype.toString = function(){
    return 'ConditionalBackref'
}

var Group = function(pos, extension){
    this.type = "group"
    this.pos = pos
    this.items = []
    this.chars = []
    this.groups = []
    for(var key in extension){
        this[key] = extension[key]
    }
    if(extension && extension.type){
        if(extension.type.indexOf('lookahead') > -1){
            this.is_lookahead = true
        }else if(extension.type.indexOf('lookbehind') > -1){
            this.is_lookbehind = true
        }
    }
}

Group.prototype.add = Node.prototype.add

Group.prototype.toString = function(){
    if(this.num === undefined){
        var res = 'Group ' + this.type + ' ' + this.pattern
    }else{
        var res = 'Group #' + this.num + ' ' + this.pattern
    }
    if(this.repeat !== undefined){
        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'
        if(this.non_greedy){
            res += '?'
        }
    }
    return res
}

BackReference.prototype.nb_repeats = Group.prototype.nb_repeats

Group.prototype.fixed_length = Node.prototype.fixed_length

function groups_in(pattern, group_list){
    if(group_list === undefined){
        group_list = new Set()
    }
    if(pattern instanceof Group && pattern.hasOwnProperty('num')){
        group_list.add(pattern.num)
    }
    if(pattern.items){
        for(var subpattern of pattern.items){
            for(var group of groups_in(subpattern, group_list)){
                group_list.add(group)
            }
        }
    }
    return group_list
}

function GroupRef(group_num, item){
    this.num = group_num
    this.item = item
}

GroupRef.prototype.fixed_length = function(){
    return this.item.fixed_length()
}

function Lookbehind(item){
    this.re = item
    this.neg = this.re.type == "negative_lookbehind"
}

Lookbehind.prototype.match = function(string, pos, endpos, groups){
    var ok = {nb_min: 0, nb_max: 0},
        pattern = {node: this.re, text: this.re + ''},
        length = this.re.length,
        mo
    if(pos - length < 0){
        mo = false
    }else{
        mo = match(pattern, string, pos - length, endpos, false, groups)
    }
    if(mo){
        return this.neg ? false : ok
    }else{
        return this.neg ? ok : false
    }
}

Lookbehind.prototype.fixed_length = function(){
    return this.re.fixed_length()
}

Lookbehind.prototype.toString = function(){
    return "Lookbehind"
}

function SetFlags(pos, flags){
    this.pos = pos
    this.on_flags = flags.on_flags
    this.off_flags = flags.off_flags
    this.items = []
}

SetFlags.prototype.add = Node.prototype.add

function StringStart(pos){
    this.pos = pos
}

StringStart.prototype.match = function(string, pos, endpos){
    var ok = {nb_min:0, nb_max: 0}
    if(this.flags.value & MULTILINE.value){
        return (pos == 0 || string.cp_at(pos - 1) == 10) ? ok : false
    }
    return pos == 0 ? ok : false
}

StringStart.prototype.fixed_length = function(){
    return 0
}

StringStart.prototype.toString = function(){
    return '^'
}

function StringEnd(pos){
    this.pos = pos
}

StringEnd.prototype.match = function(string, pos, endpos){
    var ok = {nb_min:0, nb_max: 0},
        cp = string.cp_at(pos)
    if(this.flags.value & MULTILINE.value){
        return (pos > string.codepoints.length - 1 ||
            cp == 10) ? ok : false
    }
    return pos > endpos - 1 ? ok :
           (pos == endpos - 1 && cp == 10) ? ok : false
}

StringEnd.prototype.fixed_length = function(){
    return 0
}

StringEnd.prototype.toString = function(){
    return '$<end>'
}

var cache = new Map()

function compile(pattern, flags){
    if(pattern.__class__ === Pattern){
        if(flags !== no_flag){
            throw _b_.ValueError.$factory("no flags")
        }
        return pattern
    }
    if(cache.has(pattern.py_obj)){
        if(cache.get(pattern.py_obj).has(flags.value || 0)){
            return cache.get(pattern.py_obj).get(flags.value || 0)
        }
    }
    var original_pattern = pattern,
        original_flags = flags,
        type = pattern.type,
        choices,
        allow_global_flags = true
    pattern = pattern.codepoints
    var is_bytes = type !== "str"
    if(is_bytes && flags && (flags.value & U.value)){
        throw _b_.ValueError.$factory("cannot use UNICODE flag with " +
            "a bytes pattern")
    }
    if(flags && (flags.value & U.value) &&
            (flags.value & ASCII.value)){
        throw _b_.ValueError.$factory("ASCII and UNICODE flags " +
            "are incompatible")
    }
    if(is_bytes){
        // bytes patterns ignore re.ASCII flag
        flags = Flag.$factory(flags.value || 0)
        //flags.value &= ~ASCII.value
    }
    var group_num = 0,
        group_stack = [],
        groups = {},
        pos,
        lookbehind,
        node = new Node(),
        accept_inline_flag = true,
        verbose = (flags.value || 0) & VERBOSE.value,
        comment = false,
        backrefs = {}
    node.$groups = groups
    for(var item of tokenize(pattern, type, verbose)){
        item.flags = flags
        item.is_bytes = is_bytes
        if(lookbehind){
            item.lookbehind = lookbehind
            lookbehind.parent = item
            lookbehind = false
        }
        if(allow_global_flags &&
                (group_stack.length > 0 || ! (item instanceof SetFlags))){
            allow_global_flags = false
        }
        if(item instanceof Group){
            group_stack.push(item)
            node.add(item)
            item.state = "open"
            group_num++
            item.num = group_num
            node = item // next items will be stored as group's items
            pos = item.pos
            if(item.non_capturing){
                delete item.num
                group_num--
            }else if(item.type == "name_def"){
                var value = item.value
                if(groups[value.string] !== undefined){
                    fail(`redefinition of group name` +
                        ` '${value.string}' as group ${group_num}; was group` +
                        ` ${groups[value.string].num}`, pos)
                }
                item.name = value.string
                groups[value.string] = groups[group_num] =
                    new GroupRef(group_num, item)
            }else if(item.is_lookahead){
                // a lookahead assertion is relative to the previous regexp
                group_num--
                while(node.items.length > 0){
                    item.add(node.items.shift())
                }
                node = item
            }else if(item.is_lookbehind){
                // a lookbehind assertion is relative to the next regexp
                node.parent.items.pop() // remove from node items
                // temporarily create a group
                groups[group_num] = new GroupRef(group_num, item)
            }else if(item.type == "flags"){
                // save flags before a group with inline flags, eg "(?i:a)"
                item.flags_before = Flag.$factory(flags.value | 0)
            }else{
                groups[group_num] = new GroupRef(group_num, item)
            }
        }else if(item instanceof GroupEnd){
            end_pos = item.pos
            if(group_stack.length == 0){
                fail("unbalanced parenthesis", end_pos, original_pattern)
            }
            var item = group_stack.pop()
            item.end_pos = end_pos
            try{
                item.pattern = from_codepoint_list(
                    pattern.slice(item.pos, end_pos + 1))
            }catch(err){
                console.log("err avec pattern substring", pattern)
                throw err
            }
            if(item.is_lookbehind){
                delete groups[group_num]
                group_num--
                // check that all elements have a fixed length
                item.length = item.fixed_length()
                if(item.length === false){
                    fail("look-behind requires fixed-width pattern", pos)
                }
                item.parent.add(new Lookbehind(item))
                item.non_capturing = true
                // store in variable "lookbehind", will be applied to next item
                lookbehind = item
            }else if(item.is_lookahead){
                delete item.num
            }
            if(item instanceof Group && item.items.length == 0){
                item.add(EmptyString)
            }else if(item instanceof ConditionalBackref){
                if(groups[item.group_ref] === undefined){
                    // might be defined later; store in backrefs and check
                    // when all items have been processed
                    backrefs[item.group_ref] = backrefs[item.group_ref] | pos + 3
                }
                if(item.re_if_exists.items.length == 0){
                    item.re_if_exists.add(EmptyString)
                }else if(item.re_if_not_exists.items.length == 0){
                    item.re_if_not_exists.pos = pos
                    item.re_if_not_exists.add(EmptyString)
                }
            }else if(item.type == "flags"){
                // restore flags when entering the group
                flags = Flag.$factory(item.flags_before.value)
            }
            item.state = 'closed'
            node = item.parent
        }else if(item instanceof ConditionalBackref){
            var pos = item.pos,
                group_ref = item.group_ref
            if(typeof group_ref == "number"){
                if(group_ref == 0){
                    fail(`bad group number`, pos + 3)
                }else if(group_ref >= MAXGROUPS){
                    fail(`invalid group reference ${group_ref}`, pos + 1)
                }else if(groups[group_ref] &&
                        groups[group_ref].item.state == "open"){
                    fail("cannot refer to an open group", pos)
                }
            }else if(groups[group_ref] !== undefined){
                if(groups[group_ref].item.state == "open"){
                    fail("cannot refer to an open group", pos)
                }
            }else{
                fail(`unknown group name '${group_ref}'`, pos)
            }
            group_stack.push(item)
            node.add(item)
            item.state = "open"
            node = item // next items will be stored as group's items
        }else if(item instanceof BackReference){
            pos = item.pos
            if(item.type == "num" && item.value > 99){
                var head = item.value.toString().substr(0, 2)
                fail(`invalid group reference ${head}`, pos + 1)
            }
            if(groups[item.value] !== undefined){
                if(groups[item.value].item.state == "open"){
                    fail("cannot refer to an open group", pos)
                }
                var ref_item = groups[item.value].item.parent
                while(ref_item){
                    if(ref_item.is_lookbehind){
                        fail("cannot refer to group defined in the same lookbehind subpattern", pos)
                    }
                    ref_item = ref_item.parent
                }
            }else if(item.type == "name"){
                fail(`unknown group name '${item.value}'`, pos)
            }else if(item.type == "num"){
                fail(`invalid group reference ${item.value}`, pos)
            }
            node.add(item)
        }else if(item instanceof Char ||
                item instanceof CharacterClass ||
                item instanceof CharacterSet){
            if(item instanceof CharacterSet){
                for(var elt of item.set.items){
                    elt.flags = flags
                }
            }
            var added_to_charseq = false
            if(item instanceof Char){
                if(node.items && node.items.length > 0){
                    var previous = $last(node.items)
                    if(previous instanceof CharSeq){
                        previous.add_char(item)
                        added_to_charseq = true
                    }else if(previous instanceof Char && ! previous.repeater){
                        node.items.pop()
                        node.items.push(new CharSeq([previous, item], flags))
                        added_to_charseq = true
                    }
                }
            }
            if(! added_to_charseq){
                node.add(item)
            }
        }else if(item instanceof Repeater){
            // check that item is not in a lookbehind group
            var pnode = node
            while(pnode){
                if(pnode.extension && pnode.extension.type &&
                        pnode.extension.type.indexOf("lookbehind") > -1){
                    fail("look-behind requires fixed-width pattern", pos)
                }
                pnode = pnode.parent
            }
            pos = item.pos
            if(node.items.length == 0){
                fail("nothing to repeat", pos)
            }
            previous = $last(node.items)
            if(previous instanceof Char ||
                    previous instanceof CharSeq ||
                    previous instanceof CharacterClass ||
                    previous instanceof CharacterSet ||
                    previous instanceof Group ||
                    previous instanceof BackReference){
                if(previous instanceof GroupEnd){
                    // associate repeat with Group
                    previous = previous.group
                }else if(previous instanceof CharSeq){
                    previous = $last(previous.chars)
                }
                if(previous.repeater){
                    if(item.op == '?' && ! previous.non_greedy){
                        if(previous.possessive){
                            fail('multiple repeat', pos)
                        }
                        previous.non_greedy = true
                        if(previous instanceof CharacterClass &&
                                previous.value == '.'){
                            previous.min_repeat_one = true
                        }
                    }else{
                        if(item instanceof Repeater && item.op == '+'){
                            if(previous.possessive || previous.non_greedy){
                                fail('multiple repeat', pos)
                            }
                            previous.possessive = true
                        }else{
                            fail("multiple repeat", pos)
                        }
                    }
                }else{
                    // convert to minimum and maximum number of repeats
                    var min = 1,
                        max = 1
                    if(Array.isArray(item.op)){
                        min = item.op[0]
                        if(min >= MAXREPEAT){
                            throw _b_.OverflowError.$factory(
                                "the repetition number is too large")
                        }
                        max = item.op[1] === undefined ? min : item.op[1]
                        if(isFinite(max) && max >= MAXREPEAT){
                            throw _b_.OverflowError.$factory(
                                "the repetition number is too large")
                        }
                        if(max < min){
                            fail('min repeat greater than max repeat', pos)
                        }
                    }else if(item.op == "?"){
                        min = 0
                        max = 1
                    }else if(item.op == "*"){
                        min = 0
                        max = Number.POSITIVE_INFINITY
                    }else if(item.op == "+"){
                        min = 1
                        max = Number.POSITIVE_INFINITY
                    }
                    previous.repeater = item
                    previous.repeat = {min, max}
                    // mark all parents of item as no fixed length
                    var parent = item
                    while(parent){
                        parent.fixed_length = false
                        parent = parent.parent
                    }
                }
            }else{
                fail("nothing to repeat", pos)
            }
        }else if(item instanceof Or){
            if(group_stack.length > 0){
                item.group = group_stack[group_stack.length - 1]
            }else{
                item.group = false
            }
            pos = item.pos
            if(node instanceof ConditionalBackref){
                // case '(?(num)a|'
                if(node.nb_options == 1){
                    node.nb_options++
                }else{
                    fail('conditional backref with more than ' +
                       'two branches', pos)
                }
            }else if(node.items.length == 0){
                // token "|" in  "(|...)" : first option is the empty string
                var choice = new Choice(),
                    case1 = new Case()
                case1.add(new Char(pos, EmptyString))
                choice.add(case1)
                node.add(choice)
                var case2 = new Case()
                choice.add(case2)
                node = case2
            }else if(node instanceof Case){
                // node.parent is already a Choice
                var new_case = new Case()
                node.parent.add(new_case)
                node = new_case
            }else{
                // token "|" in "(ab|...)"
                var previous = node.items[node.items.length - 1]
                if(previous instanceof Case){
                    var new_case = new Case()
                    previous.add(new_case)
                    node = new_case
                }else{
                    var choice = new Choice(),
                        case1 = new Case(),
                        first_rank = node.items[0].rank
                    while(node.items.length > 0){
                        case1.add(node.items.shift())
                    }
                    case1.groups = node.$groups
                    for(var group of group_stack){
                        choice.groups.push(group)
                    }
                    choice.add(case1)
                    node.add(choice)
                    var case2 = new Case()
                    choice.add(case2)
                    node = case2
                }
            }
        }else if(item instanceof StringStart ||
                 item instanceof StringEnd){
            node.add(item)
        }else if(item instanceof SetFlags){
            if(group_stack.length == 0 && ! allow_global_flags){
                // pattern like (?x) only allowed as first in reg exp
                fail('global flags not at the start of the ' +
                        'expression', item.pos)
            }
            // copy flags, otherwise re.ASCII etc might be modified
            flags = Flag.$factory(flags.value || U.value)
            if(item.on_flags.indexOf('u') > -1){
                if(is_bytes){
                    fail("re.error: bad inline flags: cannot use 'u' flag " +
                        "with a bytes pattern", pos)
                }
                if(flags && flags.value & ASCII.value){
                    // switch to Unicode
                    flags.value ^= ASCII.value
                }
                if(group_stack.length == 0 &&
                        original_flags && original_flags.value & ASCII.value){
                    throw _b_.ValueError.$factory("ASCII and UNICODE flags " +
                        "are incompatible")
                }
                if(item.on_flags.indexOf('a') > -1){
                    throw _b_.ValueError.$factory("ASCII and UNICODE flags " +
                        "are incompatible")
                }
            }
            if(item.on_flags.indexOf('a') > -1){
                if(group_stack.length == 0 &&
                        original_flags && original_flags.value & U.value){
                    throw _b_.ValueError.$factory("ASCII and UNICODE flags " +
                        "are incompatible")
                }
                if(flags && flags.value & U.value){
                    // switch to ASCII
                    flags.value ^= U.value
                }
                if(item.on_flags.indexOf('u') > -1){
                    throw _b_.ValueError.$factory("ASCII and UNICODE flags " +
                        "are incompatible")
                }
            }
            if(flags.value === undefined){
                flags.value = 32
            }
            if(item.items.length == 0){
                if(! accept_inline_flag && group_stack.length == 0){
                    var s = from_codepoint_list(pattern)
                    warn(_b_.DeprecationWarning,
                        `Flags not at the start of the expression '${s}'`,
                        pos)
                }
                for(var on_flag of item.on_flags){
                    if(! is_bytes || on_flag !== 'a'){
                        flags.value |= inline_flags[on_flag].value
                    }
                }
                for(var off_flag of item.off_flags){
                    if(! is_bytes || off_flag !== 'a'){
                        flags.value ^= inline_flags[off_flag].value
                    }
                }
            }else{
                node.add(item)
            }
        }else{
            fail("unknown item type " + item, pos)
        }
        if(! (item instanceof SetFlags) &&
                ! (item instanceof Group && item.type == "flags")){
            accept_inline_flag = false
        }
    }
    for(ref in backrefs){
        if(groups[ref] === undefined){
            fail('invalid group name ' + ref, backrefs[ref])
        }
    }
    if(group_stack.length > 0){
        var last = group_stack[group_stack.length - 1]
        fail("missing ), unterminated subpattern", last.pos)
    }
    while(node.parent){
        node = node.parent
    }
    node.pattern = from_codepoint_list(pattern)
    node.groups = group_num
    flags = flags === no_flag ? 32 : flags
    node.flags = flags
    var res = {
        node,
        groups,
        flags,
        original_flags,
        text: from_codepoint_list(pattern),
        type, // "str" or "bytes"
        fixed_length: node.fixed_length()
    }
    if(! cache.has(original_pattern.py_obj)){
        cache.set(original_pattern.py_obj, new Map())
    }
    cache.get(original_pattern.py_obj).set(original_flags.value || 0, res)
    if(_debug.value){
        show(node)
    }
    return res
}

function show(node, indent){
    indent = indent === undefined ? 0 : indent
    if(indent == 0){
        log('root', node)
    }
    log(' '.repeat(indent) + node)
    if(node.items !== undefined){
        for(var item of node.items){
            show(item, indent + 1)
        }
    }
}

function to_codepoint_list(s){
    var items = []
    if(typeof s == "string" || $B.$isinstance(s, _b_.str)){
        if(typeof s != "string"){
            s = s.valueOf()
        }
        for(var char of s){
            items.push(char.codePointAt(0))
        }
        items.type = "unicode"
    }else if($B.$isinstance(s, [_b_.bytes, _b_.bytearray, _b_.memoryview])){
        if($B.$isinstance(s, _b_.memoryview)){
            items = s.obj.source
        }else{
            items = s.source
        }
        items.type = "bytes"
    }else{
        throw Error('invalid type ' + $B.class_name(s))
    }
    return items
}

$B.nb_from_cp = 0
function from_codepoint_list(codepoints, type){
    $B.nb_from_cp++
    // Return a string
    if(type == "bytes"){
        return _b_.bytes.$factory(codepoints)
    }
    var s = ''
    for(var cp of codepoints){
        s += _b_.chr(cp)
    }
    return $B.String(s)
}

function string2bytes(s){
    var t = []
    for(var i = 0, len = s.length; i < len; i++){
        t.push(s.charCodeAt(i))
    }
    return _b_.bytes.$factory(t)
}

function check_pattern_flags(pattern, flags){
    if(pattern.__class__ === Pattern){
        if(flags !== no_flag){
            throw _b_.ValueError.$factory(
                "cannot process flags argument with a compiled pattern")
        }
    }
    return pattern
}

function StringObj(obj){
    // A StringObj object is a bridge between a Python string or bytes-like
    // object and Javascript
    // obj is the Python object
    // this.string is a Javascript string
    this.py_obj = obj
    this.codepoints = []
    this.type = "str"
    this.is_string = typeof obj == 'string'
    if(typeof obj == "string" ||
            (obj instanceof String && ! obj.codepoints)){
        // Python object represented as a Javascript string
        this.string = obj
        // Maps a position in codepoints to position in string
        this.index_map = {}
        for(var i = 0, len = obj.length; i < len; i++){
            this.index_map[this.codepoints.length] = i
            var cp = obj.codePointAt(i)
            this.codepoints.push(cp)
            if(cp >= 0x10000){
                i++
            }
        }
        this.length = _b_.str.__len__(obj)
        if(obj instanceof String){
            // store for next use
            obj.codepoints = this.codepoints
            obj.index_map = this.index_map
        }
    }else if(obj instanceof String){
        // string with surrogate pairs
        this.string = obj.string
        this.codepoints = obj.codepoints
        this.index_map = obj.index_map
        this.length = _b_.str.__len__(obj)
    }else if($B.$isinstance(obj, _b_.str)){ // str subclass
        var so = new StringObj(_b_.str.$factory(obj))
        this.string = so.string
        this.codepoints = so.codepoints
        this.length = _b_.str.__len__(obj)
    }else if($B.$isinstance(obj, [_b_.bytes, _b_.bytearray])){
        this.string = _b_.bytes.decode(obj, 'latin1')
        this.codepoints = obj.source
        this.type = "bytes"
    }else if($B.$isinstance(obj, _b_.memoryview)){
        this.string = _b_.bytes.decode(obj.obj, 'latin1')
        this.codepoints = obj.obj.source
        this.type = "bytes"
    }else if(obj.__class__ && obj.__class__.$buffer_protocol){
        // eg array.array
        this.codepoints = _b_.list.$factory(obj)
        this.string = from_codepoint_list(this.codepoints, "bytes")
        this.type = "bytes"
    }else if(Array.isArray(obj)){
        // list of codepoints
        this.codepoints = obj
    }else{
        throw _b_.TypeError.$factory(
            `expected string or bytes-like object, got '${$B.class_name(obj)}'`)
    }
    if(this.length === undefined){
        this.length = this.codepoints.length
    }
}

StringObj.prototype.cp_at = function(pos){
    if(pos >= this.length){
        return undefined
    }
    /*
    if(typeof this.string == 'string'){
        return this.string.charCodeAt(pos)
    }
    */
    var res = this.codepoints[pos]
    if(res !== undefined){
        return res
    }
}

StringObj.prototype.substring = function(start, end){
    // Returns a string
    var s
    if(this.string && this.index_map){
        if(this.index_map[start] === undefined){
            return ''
        }
        if(end === undefined){
            return this.string.substr(this.index_map[start])
        }
        return this.string.substring(this.index_map[start],
            this.index_map[end])
    }
    var codepoints,
        res = ''
    if(end === undefined){
        codepoints = this.codepoints.slice(start)
    }else{
        codepoints = this.codepoints.slice(start, end)
    }
    return from_codepoint_list(codepoints, this.type)
}

StringObj.prototype.to_str = function(){
    if(this.hasOwnProperty('string')){
        return this.string
    }
    return from_codepoint_list(this.codepoints, this.type)
}

StringObj.from_codepoints = function(cps){
    var res = new StringObj('')
    res.codepoints = cps
    for(var cp of cps){
        res.string += _b_.chr(cp)
    }
    return res
}

function prepare(args){
    // Check that all arguments are of the same type (string or bytes-like).
    // Return an object with all attributes transformed into StringObj
    // instances
    var res = {},
        keys = Object.keys(args),
        first = keys[0]
    res[first] = new StringObj(args[first])
    res.type = res[first].type
    for(var key of keys.slice(1)){
        res[key] = new StringObj(args[key])
        if(res[key].type != res.type){
            throw _b_.TypeError.$factory(`not the same type for ${first} and ${key}`)
        }
    }
    return res
}
function subn(pattern, repl, string, count, flags){
    // string is a StringObj instance
    // pattern is either a Pattern instance or a StringObj instance
    var res = '',
        pos = 0,
        nb_sub = 0

    if(pattern instanceof StringObj){
        pattern = compile(pattern, flags)
    }
    if(typeof repl != "function"){
        var data1 = transform_repl({repl}, pattern)
        repl1 = data1.repl1
    }
    pos = 0
    var s = string.to_str()
    for(var bmo of module.finditer(Pattern.$factory(pattern), s).js_gen){
        // finditer yields instances of MatchObject
        var mo = bmo.mo // instance of MO
        res += from_codepoint_list(string.codepoints.slice(pos, mo.start))
        if(typeof repl == "function"){
            var x = $B.$call(repl)(bmo)
            if(x.__class__ === _b_.bytes){
                x = _b_.bytes.decode(x, 'latin-1')
            }
            res += x // $B.$call(repl)(bmo)
        }else{
            res += repl1
        }
        nb_sub++
        pos = mo.end
        if(count != 0 && nb_sub >= count){
            break
        }
    }
    if(string.is_string){
        res += string.string.substr(pos)
    }else{
        res += from_codepoint_list(string.codepoints.slice(pos))
    }
    if(pattern.type === "bytes"){
        res = _b_.str.encode(res, "latin-1")
    }
    return [res, nb_sub]
}

// escaped chars : '\t\n\x0b\x0c\r #$&()*+-.?[\\]^{|}~'
var escaped = [9, 10, 11, 12, 13, 32, 35, 36, 38, 40, 41, 42, 43, 45, 46, 63,
               91, 92, 93, 94, 123, 124, 125, 126]

function starts_with_string_start(pattern){
    // returns true if the pattern starts with ^ or \A
    if(pattern.node){
        pattern = pattern.node
    }
    if(pattern.items){
        if(pattern.items.length == 0){
            return false
        }
        return starts_with_string_start(pattern.items[0])
    }else if(pattern instanceof CharacterClass){
        return pattern.value == 'A'
    }else if(pattern instanceof StringStart){
        return true
    }else{
        return false
    }
}

function* iterator(pattern, string, flags, original_string, pos, endpos){
    var result = [],
        pos = pos | 0,
        cp,
        accept_one = true // used to test one position after string end
    while((cp = string.cp_at(pos)) !== undefined || accept_one){
        var mo = match(pattern, string, pos, endpos)
        if(mo){
            yield MatchObject.$factory(mo)
            if(mo.end == mo.start){
                // If match has zero with, retry at the same position but
                // with the flag no_zero_width set, to avoid infinite loops
                mo = match(pattern, string, pos, endpos, true)
                if(mo){
                    yield MatchObject.$factory(mo)
                    pos = mo.end
                }else{
                    pos++ // at least 1, else infinite loop
                }
            }else{
                pos = mo.end
            }
        }else{
            pos++
        }
        if(cp === undefined){
            accept_one = false
        }
        if (starts_with_string_start(pattern) && !(flags.value & MULTILINE.value)) {
            break
        }
    }
    delete original_string.in_iteration
}
function MO(node, pos, mo, len){
    // Match Object
    this.node = node
    this.start = pos
    this.mo = mo
    this.nb_min = mo.nb_min
    this.nb_max = mo.nb_max
    this.len = len
    this.nb = this.node.non_greedy ? mo.nb_min : mo.nb_max
    this.end = pos + len * this.nb
}

MO.prototype.backtrack = function(string, groups){
    if(this.node.possessive){
        return false
    }
    if(this.node.non_greedy && this.nb < this.nb_max){
        this.nb++
        this.end = this.start + this.len * this.nb
        return true
    }else if((! this.node.non_greedy) && this.nb > this.nb_min){
        this.nb--
        this.end = this.start + this.len * this.nb
        return true
    }else{
        return false
    }
}

function del_groups(groups, node){
    if(node.num !== undefined){
        delete groups[node.num]
        groups.$last.splice(groups.$last.indexOf(node.num), 1)
        if(node.name !== undefined){
            delete groups[node.name]
        }
    }
    for(var child of node.items){
        if(child instanceof Group){
            del_groups(groups, child)
        }
    }
}

function GroupMO(node, start, matches, string, groups, endpos){
    // Match Object for Groups
    this.node = node
    this.start = start
    this.matches = matches
    this.string = string
    this.end = matches.length > 0 ? $last(matches).end : start
    this.endpos = endpos === undefined ? this.end : endpos
    this.$groups = groups
}

GroupMO.prototype.backtrack = function(string, groups){
    if(_debug.value){
        console.log('group MO backtrack, this', this)
        alert()
    }
    // Try backtracking in the last match
    if(this.node.possessive || this.node.atomic){
        return false
    }
    if(this.matches.length > 0){
        var _match = $last(this.matches),
            mos = _match.mos,
            nb0 = mos.length
        while(mos.length > 0){
            var mo = mos.pop()
            if(mo.node instanceof Case){
                var rank = mo.node.parent.items.indexOf(mo.node)
                for(var _case of mo.node.parent.items.slice(rank + 1)){
                    var _mo = match({node: _case, text: _case.text},
                        string, mo.start)
                    if(_mo){
                        // update GroupMO object
                        mos.push(_mo)
                        this.end = _mo.end
                        if(this.$groups.$last.length > 0){
                            var ix = this.$groups.$last[this.$groups.$last.length - 1]
                            this.$groups[ix].end = _mo.end
                        }
                        return true
                    }
                }
            }
            if(mo.backtrack(string, groups)){
                mos.push(mo)
                if(this.node.num !== undefined){
                    groups[this.node.num].end = mo.end
                }
                this.end = mo.end
                return true
            }
        }
    }
    // Else, remove last match if possible
    if(this.matches.length > this.node.repeat.min &&
            this.matches.length >= 1){
        this.matches.pop()
        if(this.matches.length > 0){
            this.end = $last(this.matches).end
        }else{
            // remove this group and its children from groups
            del_groups(groups, this.node)
            this.end = this.start
        }
        return true
    }
    // Group fails; if some of its subgroups succeded, remove them from
    // groups
    if(this.node.repeat.min > 0){
        del_groups(groups, this.node)
    }
    return false
}

GroupMO.prototype.toString = function(){
    var repr = _b_.repr(this.string.substring(this.start, this.end))
    repr = repr.substring(0, 50)
    return '<re.Match object; span=(' + this.start + ', ' + this.end +
        '), match=' + repr + '>'
}

GroupMO.prototype.groups = function(_default){
    var res = [],
        groupobj = this.$groups

    for(var key in this.node.$groups){
        if(isFinite(key)){
            res[key] = groupobj[key] === undefined ? _default :
                this.string.substring(groupobj[key].start, groupobj[key].end)
        }
    }
    res.shift()
    return $B.fast_tuple(res)
}

// Brython MatchObject
var MatchObject = $B.make_class("Match",
    function(mo){
        return {
            __class__: MatchObject,
            mo
        }
    }
)

MatchObject.__copy__ = function(self){
    return self
}

MatchObject.__deepcopy__ = function(self){
    return self
}

MatchObject.__getitem__ = function(){
    var $ = $B.args("__getitem__", 2, {self: null, key: null},
                ['self', 'key'], arguments, {}, null, null),
        self = $.self,
        key = $.key
    if(Array.isArray(key)){
        throw _b_.IndexError.$factory("no such group")
    }
    if(key == 0){
        return self.mo.string.substring(self.mo.start, self.mo.end)
    }
    var match = self.mo.$groups[key]
    if(match !== undefined){
        return self.mo.string.substring(match.start, match.end)
    }else if(self.mo.node.$groups[key] !== undefined){
        return _b_.None
    }
    throw _b_.IndexError.$factory("no such group")
}

MatchObject.__repr__ = MatchObject.__str__ =  function(self){
    return self.mo.toString()
}

MatchObject.end = function(self){
    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],
                arguments, {group: 0}, null, null)
    var group = MatchObject.group(self, $.group)
    if(group === _b_.None){
        return -1
    }else if($.group == 0){
        return self.mo.end
    }else{
        return self.mo.$groups[$.group].end
    }
}

MatchObject.endpos = _b_.property.$factory(
    function(self){
        return self.mo.endpos
    }
)

MatchObject.expand = function(){
    var $ = $B.args("expand", 2, {self: null, template: null},
                ['self', 'template'], arguments, {}, null, null)
    var data = {
        repl: new StringObj($.template),
    }
    data = transform_repl(data, {groups: $.self.mo.node.$groups})
    if(typeof data.repl == "function"){
        return $B.$call(data.repl)(MatchObject.$factory($.self.mo))
    }else{
        return data.repl1
    }
}

MatchObject.group = function(self){
    var $ = $B.args("group", 1, {self: null}, ['self'], arguments,
                {}, 'args', null),
            self = $.self,
            args = $.args
    if(args.length == 0){
        args[0] = 0
    }
    var groupobj = self.mo.$groups,
        result = []
    for(var group_id of args){
        if($B.rich_comp('__eq__', group_id, 0)){
            result.push(self.mo.string.substring(self.mo.start, self.mo.end))
            continue
        }
        try{
            // Convert group_id to int if possible
            group_id = $B.PyNumber_Index(group_id) // in py_utils.js
        }catch(err){
            // group_id can be an identifier
        }
        if(self.mo.node.$groups[group_id] === undefined){
            throw _b_.IndexError.$factory("no such group")
        }
        var group = groupobj[group_id] // found in match
        result.push(group === undefined ?
            _b_.None :
            self.mo.string.substring(group.start, group.end))
    }
    if(args.length == 1){
        return result[0]
    }
    return $B.fast_tuple(result)
}

MatchObject.groupdict = function(){
    /*
    Return a dictionary containing all the named subgroups of the match, keyed
    by the subgroup name. The default argument is used for groups that did not
    participate in the match; it defaults to None.
    */
    var $ = $B.args("groupdict", 2, {self: null, default: null},
                ['self', 'default'], arguments, {default: _b_.None},
                null, null),
        self = $.self,
        groupobj = $.self.mo.$groups,
        d = $B.empty_dict()
    for(var key in $.self.mo.node.$groups){
        if(! isFinite(key)){
            var value = groupobj[key] === undefined ? $.default :
                    groupobj[key]
            if(value !== $.default){
                value = self.mo.string.substring(value.start, value.end)
            }
            _b_.dict.$setitem(d, key, value)
        }
    }
    return d
}

MatchObject.groups = function(self){
    var $ = $B.args("group", 2, {self: null, default: null},
                ['self', 'default'], arguments,
                {default: _b_.None}, null, null),
            self = $.self,
            _default = $.default
    return self.mo.groups(_default)
}

MatchObject.lastindex = _b_.property.$factory(
   function(self){
        /* The integer index of the last matched capturing group, or None if
           no group was matched at all.
        */
        var last = self.mo.$groups.$last
        if(last.length == 0){
            return _b_.None
        }
        return parseInt($last(last))
    }
)

MatchObject.lastgroup = _b_.property.$factory(
    function(self){
        /* The name of the last matched capturing group, or None if the group
           didn't have a name, or if no group was matched at all.
        */
        var lastindex = MatchObject.lastindex.fget(self)
        if(lastindex === _b_.None){
            return _b_.None
        }
        var group = self.mo.node.$groups[lastindex],
            name = group.item.name
        return name === undefined ? _b_.None : name
    }
)

MatchObject.pos = _b_.property.$factory(
    function(self){
        return self.mo.start
    }
)

MatchObject.re = _b_.property.$factory(
    function(self){
        return self.mo.node.pattern
    }
)

MatchObject.regs = _b_.property.$factory(
    function(self){
        var res = [$B.fast_tuple($B.fast_tuple([self.mo.start, self.mo.end]))]
        for(var group_num in self.mo.node.$groups){
            if(isFinite(group_num)){
                var group = self.mo.node.$groups[group_num].item
                // group.pattern includes the opening and closing brackets
                res.push($B.fast_tuple([group.pos,
                    group.pos + group.pattern.length - 2]))
            }
        }
        return $B.fast_tuple(res)
    }
)

MatchObject.span = function(){
    /*
    Match.span([group])

    For a match m, return the 2-tuple (m.start(group), m.end(group)). Note
    that if group did not contribute to the match, this is (-1, -1). group
    defaults to zero, the entire match.
    */
    var $ = $B.args("span", 2, {self: null, group: null},
                ['self', 'group'], arguments,
                {group: 0}, null, null),
            self = $.self,
            group = $.group
    if(group == 0){
        return $B.fast_tuple([self.mo.start, self.mo.end])
    }
    var span = self.mo.$groups[group]
    if(span === undefined){
        return $B.fast_tuple([-1, -1])
    }
    return $B.fast_tuple([span.start, span.end])
}

MatchObject.start = function(self){
    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],
                arguments, {group: 0}, null, null)
    var group = MatchObject.group(self, $.group)
    if(group === _b_.None){
        return -1
    }else if($.group == 0){
        return self.mo.start
    }else{
        return self.mo.$groups[$.group].start
    }
}

MatchObject.string = _b_.property.$factory(
    function(self){
        return self.mo.string.to_str()
    }
)

$B.set_func_names(MatchObject, 're')

function log(){
    if(_debug.value){
        console.log.apply(null, arguments)
    }
}

function create_fullmatch_pattern(pattern){
    // transform <pattern> into "(?:<pattern>)$"
    // use a new pattern object, otherwise if pattern is in cache the
    // value in cache would be changed
    var new_pattern = {}
    for(var key in pattern){
        if(key == 'node'){
            continue
        }
        new_pattern[key] = pattern[key]
    }

    var ncgroup = new Group() // non-capturing group
    ncgroup.pos = 0
    ncgroup.non_capturing = true
    for(var item of pattern.node.items){
        ncgroup.add(item)
    }
    var se = new StringEnd()
    se.flags = Flag.$factory(32)
    new_pattern.node = new Node()
    new_pattern.node.add(ncgroup)
    new_pattern.node.add(se)
    return new_pattern
}

function match(pattern, string, pos, endpos, no_zero_width, groups){
    // Follow the pattern tree structure
    if(_debug.value){
        console.log('match pattern', pattern.text, 'pos', pos, string.substring(pos))
        alert()
    }
    if(endpos !== undefined){
        if(endpos < pos){
            return false
        }
    }else{
        endpos = string.length
    }
    if(pattern.node instanceof Node){
        show(pattern.node)
    }
    if(groups === undefined){
        groups = {$last:[]}
    }
    if(pattern.text === undefined){
        console.log('no text', pattern)
    }
    var node = pattern.node,
        mo
    if(node.items){
        // node is either a Choice between several items, or a sequence of
        // items
        if(node instanceof Choice){
            mo = false
            for(var _case of node.items){
                mo = match({node: _case, text: _case.text}, string, pos,
                    endpos, no_zero_width, groups)
                if(mo){
                    // remove groups inside choice and before successful case
                    // that did not contribute to the match
                    var groups_succeed = groups_in(_case),
                        min_num = Math.min(Array.from(groups_succeed))
                    for(var group_num of groups_in(node)){
                        if(group_num < min_num){
                            delete groups[group_num]
                        }
                    }
                    if(_debug.value){
                        console.log('case', _case + '', 'of choice', node +
                            ' succeeds, groups', groups)
                    }
                    return mo
                }else{
                    if(_debug.value){
                        console.log('case', _case + '', 'of choice', node +
                            ' fails')
                    }
                }
            }
            return false
        }else{
            // sequence of items
            node.repeat = node.repeat === undefined ? {min: 1, max: 1} :
                node.repeat
            var start = pos,
                nb_repeat = 0,
                nb_zerolength_repeat = 0,
                matches = [],
                mos,
                match_start,
                empty_matches = {}
            // loop until we get enough repetitions
            while(true){
                if(empty_matches[pos]){
                    // no use trying again
                    return matches.length == 0 ? false :
                       new GroupMO(node, start, matches, string, groups,
                           endpos)
                }
                var initial_groups = Object.keys(groups)
                mos = []
                match_start = pos
                if(_debug.value){
                    console.log("pattern", pattern.text,
                        "loop in group match, match start", match_start)
                }
                var i = 0
                while(i < node.items.length){
                    var item = node.items[i]
                    if(_debug.value){
                        console.log('item', i, '/', node.items.length - 1,
                            'of pattern', pattern.text)
                    }
                    var mo = match({node: item, text: item + ''}, string, pos,
                        endpos, no_zero_width, groups)
                    if(mo){
                        if(item instanceof Group &&
                                item.type == "lookahead_assertion"){
                            log("lookahead assertion", item + '',
                                "succeeds, mo", mo)
                        }else{
                            mos.push(mo)
                            pos = mo.end
                        }
                        i++
                    }else if(false && item instanceof Group &&
                            item.type == "negative_lookahead_assertion"){
                        log("negative lookahead assertion", item, "fails : ok !")
                        i++
                    }else{
                        if(_debug.value){
                            console.log('item ' + item, 'of group fails, nb_repeat',
                                nb_repeat, 'node repeat', node.repeat)
                        }
                        var backtrack = false
                        while(mos.length > 0){
                            var mo = mos.pop()
                            if(mo.backtrack === undefined){
                                log('no backtrack for', mo)
                            }
                            if(_debug.value){
                                console.log('try backtrack on mo', mo)
                            }
                            if(mo.backtrack(string, groups)){
                                log('can backtrack, mo', mo)
                                mos.push(mo)
                                i = mos.length
                                log('mos', mos, 'restart at item', i)
                                pos = mo.end
                                backtrack = true
                                break
                            }
                        }
                        if(backtrack){
                            log('backtrack ok')
                            continue
                        }else{
                            if(node.type == "negative_lookahead_assertion"){
                                // If a negative lookahead assertion fails,
                                // return a match
                                var res = new GroupMO(node, start, matches,
                                    string, groups, endpos)
                                return res
                            }
                            if(nb_repeat == 0){
                                // remove the groups introduced before
                                // reaching this point
                                for(var key in groups){
                                    if(initial_groups.indexOf(key) == -1){
                                        delete groups[key]
                                    }
                                }
                            }
                            if(nb_repeat >= node.repeat.min){
                                log("enough repetitions for node", node)
                                if(node.type == "negative_lookahead_assertion"){
                                    return false
                                }
                                return new GroupMO(node, start, matches, string,
                                    groups, endpos)
                            }
                            return false
                        }
                    }
                }
                if(node.type == "negative_lookahead_assertion"){
                    // If a negative lookahead succeeds, return false
                    return false
                }
                nb_repeat++
                if(pos > match_start){
                    nb_zerolength_repeat = 0
                }else{
                    nb_zerolength_repeat++
                    empty_matches[pos] = true
                }
                matches.push({start: match_start, end: pos, mos})
                if(node.num !== undefined){
                    groups[node.num] = $last(matches)
                    if(node.name !== undefined){
                        groups[node.name] = groups[node.num]
                    }
                    if(node.num != $last(groups.$last)){
                        var ix = groups.$last.indexOf(node.num)
                        if(ix > -1){
                            groups.$last.splice(ix, 1)
                        }
                        groups.$last.push(node.num)
                    }
                }
                if(nb_repeat >= node.repeat.max){
                    var res = new GroupMO(node, start, matches, string,
                        groups, endpos)
                    if(res.start == res.end && no_zero_width){
                        // no_zero_width is set when previous match in
                        // iterator() had length 0; avoids infinite loops
                        return false
                    }
                    return res
                }
                log('loop on group', pattern.text, 'nb repeats', nb_repeat,
                    'nb zero length', nb_zerolength_repeat, 'groups', groups)
                if(nb_zerolength_repeat == 65535){
                    return matches.length == 0 ? false :
                       new GroupMO(node, start, matches, string, groups,
                           endpos)
                }
            }
        }
    }else{
        // for BackReference, Char, CharSeq, CharacterClass, CharacterSet,
        // ConditionalBackref, Lookbehind, StringStart, StringEnd
        var mo = node.match(string, pos, endpos, groups)
        if(_debug.value){
            console.log(node + '', "mo", mo)
        }
        if(mo){
            var len = mo.group_len === undefined ? 1 : mo.group_len,
                ix = node.non_greedy ? mo.nb_min : mo.nb_max,
                end = pos + len * ix
            return new MO(node, pos, mo, len)
        }else{
            return false
        }
    }
}

// expose re module API
var module = {
    cache: cache,
    compile: function(){
        var $ = $B.args("compile", 2, {pattern: null, flags: null},
                    ['pattern', 'flags'], arguments, {flags: no_flag},
                    null, null)
        if($.pattern && $.pattern.__class__ === Pattern){
            if($.flags !== no_flag){
                throw _b_.ValueError.$factory(
                    "cannot process flags argument with a compiled pattern")
            }
            return $.pattern
        }
        $.pattern = check_pattern_flags($.pattern, $.flags)
        var data = prepare({pattern: $.pattern})
        if(typeof $.flags == "number"){
            $.flags = Flag.$factory($.flags)
        }
        var jspat = compile(data.pattern, $.flags)
        return Pattern.$factory(jspat)
    },
    error: error,
    escape: function(){
        var $ = $B.args("escape", 1, {pattern: null}, ['pattern'], arguments,
                    {}, null, null),
            data = prepare({pattern: $.pattern}),
            pattern = data.pattern,
            res = []
        for(var cp of pattern.codepoints){
            if(escaped.indexOf(cp) > -1){
                res.push(BACKSLASH)
            }
            res.push(cp)
        }
        res = from_codepoint_list(res, data.type)
        if(data.type == "bytes" && $B.$isinstance(res, _b_.str)){
            res = _b_.str.encode(res, 'latin1')
        }
        return res
    },
    findall: function(){
        /* Return all non-overlapping matches of pattern in string, as a list
           of strings. The string is scanned left-to-right, and matches are
           returned in the order found. If one or more groups are present in
           the pattern, return a list of groups; this will be a list of tuples
           if the pattern has more than one group. Empty matches are included
           in the result.
        */
        var $ = $B.args("findall", 3,
                    {pattern: null, string: null, flags: null},
                    ['pattern', 'string', 'flags'], arguments,
                    {flags: no_flag}, null, null),
                pattern = $.pattern,
                string = $.string,
                flags = $.flags,
                data
        pattern = check_pattern_flags(pattern, flags)
        if(pattern.__class__ === Pattern){
            data = prepare({string})
        }else{
            data = prepare({string, pattern})
            pattern = Pattern.$factory(compile(data.pattern, flags))
        }
        if(data.type === "str"){
            function conv(s){
                return s === EmptyString ? '' : s
            }
        }else{
            function conv(s){
                return string2bytes(s)
            }
        }

        var iter = module.finditer.apply(null, arguments).js_gen,
            res = []
        while(true){
            var next = iter.next()
            if(next.done){
                return res
            }
            var bmo = next.value,
                mo = bmo.mo,
                groups = MatchObject.groups(bmo)

            // replace None by the empty string
            for(var i = 0, len = groups.length; i < len; i++){
                groups[i] = groups[i] === _b_.None ? "" : groups[i]
            }
            if(groups.length > 0){
                if(groups.length == 1){
                    res.push(groups[0])
                }else{
                    res.push($B.fast_tuple(groups))
                }
            }else{
                res.push(mo.string.substring(mo.start, mo.end))
            }
        }
        console.log("end findall")
    },
    finditer: function(){
        var $ = $B.args("finditer", 3,
                    {pattern: null, string: null, flags: null},
                    ['pattern', 'string', 'flags'], arguments,
                    {flags: no_flag}, null, null),
                pattern = $.pattern,
                string = $.string,
                flags = $.flags
        if($B.$isinstance(string, [_b_.bytearray, _b_.memoryview])){
            string.in_iteration = true
        }
        var original_string = string,
            data
        pattern = check_pattern_flags(pattern, flags)
        if(pattern.__class__ === Pattern){
            data = prepare({string})
            flags = pattern.flags
        }else{
            data = prepare({string, pattern})
            pattern = Pattern.$factory(compile(data.pattern, flags))
        }
        if(pattern.__class__ !== Pattern){
            throw Error("pattern not a Python object")
        }
        return $B.generator.$factory(iterator)(pattern.$pattern, data.string,
            flags, original_string)
    },
    fullmatch: function(){
        var $ = $B.args("fullmatch", 3, {pattern: null, string: null, flags: null},
                    ['pattern', 'string', 'flags'], arguments,
                    {flags: no_flag}, null, null),
                pattern = $.pattern,
                string = $.string,
                flags = $.flags
        pattern = check_pattern_flags(pattern, flags)
        var data
        if(pattern.__class__ === Pattern){
            data = prepare({string})
            pattern = pattern.$pattern
        }else{
            data = prepare({pattern, string})
            pattern = compile(data.pattern, flags)
        }

        var new_pattern = create_fullmatch_pattern(pattern)

        // match transformed RE
        var res = match(new_pattern, data.string, 0)
        var bmo = res === false ? _b_.None : MatchObject.$factory(res)
        if(bmo !== _b_.None){
            if(bmo.mo.string.codepoints.length != bmo.mo.end - bmo.mo.start){
                return _b_.None
            }else{
                return bmo
            }
        }
        return _b_.None
    },
    Match: MatchObject,
    match: function(){
        var $ = $B.args("match", 3, {pattern: null, string: null, flags: null},
                    ['pattern', 'string', 'flags'], arguments,
                    {flags: no_flag}, null, null),
                pattern = $.pattern,
                string = $.string,
                flags = $.flags
        pattern = check_pattern_flags(pattern, flags)
        var data
        if(pattern.__class__ === Pattern){
            data = prepare({string})
            pattern = pattern.$pattern
        }else{
            data = prepare({pattern, string})
            pattern = compile(data.pattern, flags)
        }
        var res = match(pattern, data.string, 0)
        return res === false ? _b_.None : MatchObject.$factory(res)
    },
    Pattern,
    purge: function(){
        var $ = $B.args("purge", 0, {}, [], arguments, {}, null, null)
        cache.clear()
        return _b_.None
    },
    _reconstructor,
    Scanner,
    search: function(){
        var $ = $B.args("search", 3, {pattern: null, string: null, flags: null},
                    ['pattern', 'string', 'flags'], arguments,
                    {flags: no_flag}, null, null),
                pattern = $.pattern,
                string = $.string,
                flags = $.flags,
                data
        pattern = check_pattern_flags(pattern, flags)
        if(pattern.__class__ === Pattern){
            data = prepare({string})
        }else{
            data = prepare({string, pattern})
            pattern = Pattern.$factory(compile(data.pattern, flags))
        }
        data.pattern = pattern
        // optimizations
        if(pattern.pattern.startsWith('\\A') ||
                pattern.pattern.startsWith('^')){
            if(! (pattern.$pattern.node.items[0] instanceof Choice)){
                var mo = match(data.pattern.$pattern, data.string, 0)
                if(mo){
                    return MatchObject.$factory(mo)
                }else if(pattern.flags.value & MULTILINE.value){
                    var pos = 0,
                        cp
                    while((cp = data.string.cp_at(pos)) !== undefined){
                        if(cp == LINEFEED){
                            mo = match(data.pattern.$pattern, data.string, pos + 1)
                            if(mo){
                                return MatchObject.$factory(mo)
                            }
                        }
                        pos++
                    }
                }else{
                    return _b_.None
                }
            }
        }
        if(pattern.$pattern.fixed_length !== false &&
                isFinite(pattern.$pattern.fixed_length) &&
                pattern.pattern.endsWith('$') &&
                ! (pattern.flags.value & MULTILINE.value)){
            var mo = match(data.pattern.$pattern, data.string,
                data.string.length - pattern.$pattern.fixed_length)
            if(mo){
                return MatchObject.$factory(mo)
            }
            return _b_.None
        }
        var pos = 0
        if(data.string.codepoints.length == 0){
            mo = match(data.pattern.$pattern, data.string, 0)
            if(mo){
                mo.start = mo.end = 0
            }
            return mo ? MatchObject.$factory(mo) : _b_.None
        }
        while(pos < data.string.codepoints.length){
            var mo = match(data.pattern.$pattern, data.string, pos)
            if(mo){
                return MatchObject.$factory(mo)
            }else{
                pos++
            }
        }
        return _b_.None
    },
    set_debug: function(value){
        _debug.value = value
    },
    split: function(){
        var $ = $B.args("split", 4,
                    {pattern: null, string: null, maxsplit: null, flags: null},
                    ['pattern', 'string', 'maxsplit', 'flags'],
                    arguments, {maxsplit: 0, flags: no_flag}, null, null)
        var res = [],
            pattern = $.pattern,
            string = $.string,
            flags = $.flags,
            pos = 0,
            nb_split = 0,
            data
        if(pattern.__class__ !== Pattern){
            data = prepare({pattern, string})
            var comp = compile(data.pattern, flags)
            pattern = Pattern.$factory(comp)
        }else{
            data = {pattern, string}
        }
        for(var bmo of module.finditer(pattern, $.string).js_gen){
            var mo = bmo.mo, // finditer returns instances of MatchObject
                groupobj = mo.$groups
            res.push(data.string.substring(pos, mo.start))
            for(var key in mo.node.$groups){
                if(isFinite(key)){
                    if(groupobj[key] !== undefined){
                        res.push(data.string.substring(groupobj[key].start,
                            groupobj[key].end))
                    }else{
                        res.push(_b_.None)
                    }
                }
            }
            nb_split++
            pos = mo.end
            if(pos >= $.string.length){
                break
            }
            if($.maxsplit != 0 && nb_split >= $.maxsplit){
                break
            }
        }
        res.push(data.string.substring(pos))
        if(data.type === "bytes"){
            res = res.map(
                function(x){
                    return $B.$isinstance(x, _b_.bytes) ?
                               x :
                               _b_.str.encode(x, "latin-1")
                }
            )
        }
        return res
    },
    sub: function(){
        var $ = $B.args("sub", 5,
                {pattern: null, repl: null, string: null, count: null, flags: null},
                ['pattern', 'repl', 'string', 'count', 'flags'],
                arguments, {count: 0, flags: no_flag}, null, null),
            pattern = $.pattern,
            repl = $.repl,
            string = $.string,
            count = $.count,
            flags = $.flags,
            data
        check_pattern_flags(pattern, flags)
        if(typeof repl != "function"){
            if(pattern.__class__ != Pattern){
                data = prepare({pattern, string, repl})
                pattern = compile(data.pattern, flags)
            }else{
                data = prepare({string, repl})
                flags = pattern.flags
                pattern = pattern.$pattern
            }
            data = transform_repl(data, pattern)
        }else{
            if(pattern.__class__ != Pattern){
                data = prepare({pattern, string})
                pattern = compile(data.pattern, flags)
            }else{
                data = prepare({string})
                flags = pattern.flags
                pattern = pattern.$pattern
            }
            data.repl = repl
        }
        return subn(pattern, data.repl, data.string, count, flags)[0]
    },
    subn: function(){
        var $ = $B.args("sub", 5,
                {pattern: null, repl: null, string: null, count: null, flags: null},
                ['pattern', 'repl', 'string', 'count', 'flags'],
                arguments, {count: 0, flags: no_flag}, null, null),
            pattern = $.pattern,
            repl = $.repl,
            string = $.string,
            count = $.count,
            flags = $.flags,
            data
        if(pattern.__class__ != Pattern){
            data = prepare({pattern, repl, string})
        }else{
            data = prepare({repl, string})
            data.pattern = pattern.$pattern
        }
        return $B.fast_tuple(subn(data.pattern, data.repl, data.string, count,
            flags))
    }

}

var ASCII = module.A = module.ASCII = Flag.$factory(256)
var IGNORECASE = module.I = module.IGNORECASE = Flag.$factory(2)
var LOCALE = module.L = module.LOCALE = Flag.$factory(4)
var MULTILINE = module.M = module.MULTILINE = Flag.$factory(8)
var DOTALL = module.S = module.DOTALL = Flag.$factory(16)
var U = module.U = module.UNICODE = Flag.$factory(32)
var VERBOSE = module.X = module.VERBOSE = Flag.$factory(64)
module.cache = cache
module._compile = module.compile
var inline_flags = {
    i: IGNORECASE,
    L: LOCALE,
    m: MULTILINE,
    s: DOTALL,
    u: U,
    x: VERBOSE,
    a: ASCII
}

var flag_names = {
    i: 'IGNORECASE',
    L: 'LOCALE',
    m: 'MULTILINE',
    s: 'DOTALL',
    u: 'U',
    x: 'VERBOSE',
    a: 'ASCII'
}

$B.addToImported('python_re', module)

})(__BRYTHON__)====python_re.js(file) end====

====re.py(module) start====
from python_re import *

import python_re
_compile=python_re._compile
_reconstructor=python_re._reconstructor

python_re._reconstructor.__module__='re'
====re.py(module) end====

====stat.py(module) start====
''
ST_MODE=0
ST_INO=1
ST_DEV=2
ST_NLINK=3
ST_UID=4
ST_GID=5
ST_SIZE=6
ST_ATIME=7
ST_MTIME=8
ST_CTIME=9
def S_IMODE(mode):
 ''
 return mode&0o7777
def S_IFMT(mode):
 ''
 return mode&0o170000
S_IFDIR=0o040000
S_IFCHR=0o020000
S_IFBLK=0o060000
S_IFREG=0o100000
S_IFIFO=0o010000
S_IFLNK=0o120000
S_IFSOCK=0o140000

S_IFDOOR=0
S_IFPORT=0
S_IFWHT=0
def S_ISDIR(mode):
 ''
 return S_IFMT(mode)==S_IFDIR
def S_ISCHR(mode):
 ''
 return S_IFMT(mode)==S_IFCHR
def S_ISBLK(mode):
 ''
 return S_IFMT(mode)==S_IFBLK
def S_ISREG(mode):
 ''
 return S_IFMT(mode)==S_IFREG
def S_ISFIFO(mode):
 ''
 return S_IFMT(mode)==S_IFIFO
def S_ISLNK(mode):
 ''
 return S_IFMT(mode)==S_IFLNK
def S_ISSOCK(mode):
 ''
 return S_IFMT(mode)==S_IFSOCK
def S_ISDOOR(mode):
 ''
 return False
def S_ISPORT(mode):
 ''
 return False
def S_ISWHT(mode):
 ''
 return False
S_ISUID=0o4000
S_ISGID=0o2000
S_ENFMT=S_ISGID
S_ISVTX=0o1000
S_IREAD=0o0400
S_IWRITE=0o0200
S_IEXEC=0o0100
S_IRWXU=0o0700
S_IRUSR=0o0400
S_IWUSR=0o0200
S_IXUSR=0o0100
S_IRWXG=0o0070
S_IRGRP=0o0040
S_IWGRP=0o0020
S_IXGRP=0o0010
S_IRWXO=0o0007
S_IROTH=0o0004
S_IWOTH=0o0002
S_IXOTH=0o0001
UF_NODUMP=0x00000001
UF_IMMUTABLE=0x00000002
UF_APPEND=0x00000004
UF_OPAQUE=0x00000008
UF_NOUNLINK=0x00000010
UF_COMPRESSED=0x00000020
UF_HIDDEN=0x00008000
SF_ARCHIVED=0x00010000
SF_IMMUTABLE=0x00020000
SF_APPEND=0x00040000
SF_NOUNLINK=0x00100000
SF_SNAPSHOT=0x00200000
_filemode_table=(
((S_IFLNK,"l"),
(S_IFSOCK,"s"),
(S_IFREG,"-"),
(S_IFBLK,"b"),
(S_IFDIR,"d"),
(S_IFCHR,"c"),
(S_IFIFO,"p")),

((S_IRUSR,"r"),),
((S_IWUSR,"w"),),
((S_IXUSR |S_ISUID,"s"),
(S_ISUID,"S"),
(S_IXUSR,"x")),

((S_IRGRP,"r"),),
((S_IWGRP,"w"),),
((S_IXGRP |S_ISGID,"s"),
(S_ISGID,"S"),
(S_IXGRP,"x")),

((S_IROTH,"r"),),
((S_IWOTH,"w"),),
((S_IXOTH |S_ISVTX,"t"),
(S_ISVTX,"T"),
(S_IXOTH,"x"))
)

def filemode(mode):
 ''
 perm=[]
 for table in _filemode_table:
  for bit,char in table:
   if mode&bit ==bit:
    perm.append(char)
    break
  else:
   perm.append("-")
 return "".join(perm)
FILE_ATTRIBUTE_ARCHIVE=32
FILE_ATTRIBUTE_COMPRESSED=2048
FILE_ATTRIBUTE_DEVICE=64
FILE_ATTRIBUTE_DIRECTORY=16
FILE_ATTRIBUTE_ENCRYPTED=16384
FILE_ATTRIBUTE_HIDDEN=2
FILE_ATTRIBUTE_INTEGRITY_STREAM=32768
FILE_ATTRIBUTE_NORMAL=128
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED=8192
FILE_ATTRIBUTE_NO_SCRUB_DATA=131072
FILE_ATTRIBUTE_OFFLINE=4096
FILE_ATTRIBUTE_READONLY=1
FILE_ATTRIBUTE_REPARSE_POINT=1024
FILE_ATTRIBUTE_SPARSE_FILE=512
FILE_ATTRIBUTE_SYSTEM=4
FILE_ATTRIBUTE_TEMPORARY=256
FILE_ATTRIBUTE_VIRTUAL=65536
try:
 from _stat import *
except ImportError:
 pass
====stat.py(module) end====

====sys.py(module) start====

from _sys import *
import _sys

_getframe=_sys._getframe

class _dataclass(tuple):

 def __init__(self,**kwargs):
  self.keys=list(kwargs)
  self.__dict__.update(kwargs)
 def __getitem__(self,key):
  if isinstance(key,int)and 0 <=key <=len(self.keys):
   return self.__dict__[self.keys[key]]
  raise KeyError(key)
 def __iter__(self):
  return(self.__dict__[key]for key in self.keys)
 def __len__(self):
  return len(self.keys)
 def __repr__(self):
  s=', '.join(f'{k}={self.__dict__[k]!r}'for k in self.keys)
  return f'sys.{self.__class__.__name__}({s})'
def make_dataclass(name,bases=None):
 bases=[_dataclass]if bases is None else[*bases,_dataclass]
 cls=type(name,bases,{})
 return cls
__breakpointhook__=breakpointhook

abiflags=0

def audit(event,*args):
 ''
 pass
brython_debug_mode=__BRYTHON__.get_option('debug')

base_exec_prefix=__BRYTHON__.brython_path

base_prefix=__BRYTHON__.brython_path

builtin_module_names=__BRYTHON__.builtin_module_names

byteorder='little'

copyright="""Copyright (c) 2001-2023 Python Software Foundation.
All Rights Reserved.

Copyright (c) 2000 BeOpen.com.
All Rights Reserved.

Copyright (c) 1995-2001 Corporation for National Research Initiatives.
All Rights Reserved.

Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
All Rights Reserved."""

dont_write_bytecode=True

exec_prefix=__BRYTHON__.brython_path

argv=orig_argv=[__BRYTHON__.script_path]+list(__BRYTHON__.get_option('args'))

def displayhook(value):
 if value is not None:
  stdout.write(repr(value))
__displayhook__=displayhook

def exit(i=None):
 raise SystemExit('')
flags=make_dataclass('flags')(
debug=0,
inspect=0,
interactive=0,
optimize=0,
dont_write_bytecode=0,
no_user_site=0,
no_site=0,
ignore_environment=0,
verbose=0,
bytes_warning=0,
quiet=0,
hash_randomization=1,
isolated=0,
dev_mode=False,
utf8_mode=0,
warn_default_encoding=0
)

def getfilesystemencoding(*args,**kw):
 ''
 return 'utf-8'
def getfilesystemencodeerrors():
 return "utf-8"
def intern(string):
 return string
int_info=make_dataclass('int_info')(
bits_per_digit=30,
sizeof_digit=4,
default_max_str_digits=__BRYTHON__.int_max_str_digits,
str_digits_check_threshold=__BRYTHON__.str_digits_check_threshold)

def get_int_max_str_digits():
 return __BRYTHON__.int_max_str_digits
def set_int_max_str_digits(value):
 try:
  value=int(value)
 except:
  raise ValueError(f"'{value.__class__.__name__}' object "
  "cannot be interpreted as an integer")
 if value !=0 and value <int_info.str_digits_check_threshold:
  raise ValueError('maxdigits must be 0 or larger than 640')
 __BRYTHON__.int_max_str_digits=value
maxsize=__BRYTHON__.max_array_size

maxunicode=1114111

platform="brython"

platlibdir=__BRYTHON__.brython_path+'Lib'

prefix=__BRYTHON__.brython_path

pycache_prefix=None

stdlib_module_names=frozenset(__BRYTHON__.stdlib_module_names)

def unraisablehook(unraisable,/):
 pass
__unraisablehook__=unraisablehook

version='.'.join(str(x)for x in __BRYTHON__.version_info[:3])
version +=" (default, %s) \n[Javascript 1.5] on Brython"\
%__BRYTHON__.compiled_date

class _comparable:

 def __eq__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)==other
  return NotImplemented
 def __ge__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)>=other
  return NotImplemented
 def __gt__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)>other
  return NotImplemented
 def __le__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)<=other
  return NotImplemented
 def __lt__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)<other
  return NotImplemented
 def __ne__(self,other):
  if isinstance(other,tuple):
   return(self.major,self.minor,self.micro)!=other
  return NotImplemented
version_info=make_dataclass('version_info',[_comparable])(
major=__BRYTHON__.version_info[0],
minor=__BRYTHON__.version_info[1],
micro=__BRYTHON__.version_info[2],
releaselevel=__BRYTHON__.version_info[3],
serial=__BRYTHON__.version_info[4])
class SimpleNamespace:

 def __init__(self,/,**kwargs):
  self.keys=list(kwargs)
  self.__dict__.update(kwargs)
 def __getitem__(self,key):
  if isinstance(key,int)and 0 <=key <=len(self.keys):
   return getattr(self,self.keys[key])
  raise KeyError(key)
 def __iter__(self):
  return iter(self.__dict__.values())
 def __repr__(self):
  items=(f"{k}={v !r}"for k,v in self.__dict__.items()
  if k in self.keys)
  return f"namespace({', '.join(items)})"
 def __eq__(self,other):
  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):
   return self.__dict__ ==other.__dict__
  return NotImplemented
SimpleNamespace.__module__="types"

hexversion=((__BRYTHON__.version_info[0]<<24)+
(__BRYTHON__.version_info[1]<<16)+
(__BRYTHON__.version_info[2]<<8))

_implementation_info=make_dataclass('version_info',[_comparable])(
major=__BRYTHON__.implementation[0],
minor=__BRYTHON__.implementation[1],
micro=__BRYTHON__.implementation[2],
releaselevel=__BRYTHON__.implementation[3],
serial=__BRYTHON__.implementation[4])

implementation=SimpleNamespace(
name='Brython',
cache_tag=None,
version=_implementation_info,
hexversion=hexversion
)

hash_info=make_dataclass('hash_info')(
width=32,
modulus=2147483647,
inf=314159,
nan=0,
imag=1000003,
algorithm='siphash24',
hash_bits=64,
seed_bits=128,
cutoff=0
)

float_info=make_dataclass('float_info')(
dig=15,
epsilon=2 **-52,
mant_dig=53,
max=__BRYTHON__.MAX_VALUE,
max_exp=2 **10,
max_10_exp=308,
min=__BRYTHON__.MIN_VALUE,
min_exp=-1021,
min_10_exp=-307,
radix=2,
rounds=1
)

warnoptions=[]

def getfilesystemencoding():
 return 'utf-8'
__stdout__=stdout
__stderr__=stderr
__stdin__=stdin

__excepthook__=excepthook
====sys.py(module) end====

====types.py(module) start====
''
import sys
def _f():pass
FunctionType=type(_f)
LambdaType=type(lambda:None)
CodeType=type(_f.__code__)
MappingProxyType=type(type.__dict__)
SimpleNamespace=type(sys.implementation)

def _cell_factory():
 a=1
 def f():
  nonlocal a
 return f.__closure__[0]
CellType=type(_cell_factory())

def _g():
 yield 1
GeneratorType=type(_g())

async def _c():pass
_c=_c()
CoroutineType=type(_c)
_c.close()

async def _ag():
 yield
_ag=_ag()
AsyncGeneratorType=type(_ag)

class _C:
 def _m(self):pass
MethodType=type(_C()._m)

BuiltinFunctionType=type(len)
BuiltinMethodType=type([].append)

WrapperDescriptorType=type(object.__init__)
MethodWrapperType=type(object().__str__)
MethodDescriptorType=type(str.join)
ClassMethodDescriptorType=type(dict.__dict__['fromkeys'])

ModuleType=type(sys)

try:
 raise TypeError
except TypeError as exc:
 TracebackType=type(exc.__traceback__)
 FrameType=type(exc.__traceback__.tb_frame)
GetSetDescriptorType=type(FunctionType.__code__)
MemberDescriptorType=type(FunctionType.__globals__)

del sys,_f,_g,_C,_c,_ag,_cell_factory
def new_class(name,bases=(),kwds=None,exec_body=None):
 ''
 resolved_bases=resolve_bases(bases)
 meta,ns,kwds=prepare_class(name,resolved_bases,kwds)
 if exec_body is not None:
  exec_body(ns)
 if resolved_bases is not bases:
  ns['__orig_bases__']=bases
 return meta(name,resolved_bases,ns,**kwds)
def resolve_bases(bases):
 ''
 new_bases=list(bases)
 updated=False
 shift=0
 for i,base in enumerate(bases):
  if isinstance(base,type):
   continue
  if not hasattr(base,"__mro_entries__"):
   continue
  new_base=base.__mro_entries__(bases)
  updated=True
  if not isinstance(new_base,tuple):
   raise TypeError("__mro_entries__ must return a tuple")
  else:
   new_bases[i+shift:i+shift+1]=new_base
   shift +=len(new_base)-1
 if not updated:
  return bases
 return tuple(new_bases)
def prepare_class(name,bases=(),kwds=None):
 ''
 if kwds is None:
  kwds={}
 else:
  kwds=dict(kwds)
 if 'metaclass'in kwds:
  meta=kwds.pop('metaclass')
 else:
  if bases:
   meta=type(bases[0])
  else:
   meta=type
 if isinstance(meta,type):
  meta=_calculate_meta(meta,bases)
 if hasattr(meta,'__prepare__'):
  ns=meta.__prepare__(name,bases,**kwds)
 else:
  ns={}
 return meta,ns,kwds
def _calculate_meta(meta,bases):
 ''
 winner=meta
 for base in bases:
  base_meta=type(base)
  if issubclass(winner,base_meta):
   continue
  if issubclass(base_meta,winner):
   winner=base_meta
   continue
  raise TypeError("metaclass conflict: "
  "the metaclass of a derived class "
  "must be a (non-strict) subclass "
  "of the metaclasses of all its bases")
 return winner
def get_original_bases(cls,/):
 ''
 try:
  return cls.__dict__.get("__orig_bases__",cls.__bases__)
 except AttributeError:
  raise TypeError(
  f"Expected an instance of type, not {type(cls).__name__ !r}"
  )from None
class DynamicClassAttribute:
 ''
 def __init__(self,fget=None,fset=None,fdel=None,doc=None):
  self.fget=fget
  self.fset=fset
  self.fdel=fdel
  self.__doc__=doc or fget.__doc__
  self.overwrite_doc=doc is None
  self.__isabstractmethod__=bool(getattr(fget,'__isabstractmethod__',False))
 def __get__(self,instance,ownerclass=None):
  if instance is None:
   if self.__isabstractmethod__:
    return self
   raise AttributeError()
  elif self.fget is None:
   raise AttributeError("unreadable attribute")
  return self.fget(instance)
 def __set__(self,instance,value):
  if self.fset is None:
   raise AttributeError("can't set attribute")
  self.fset(instance,value)
 def __delete__(self,instance):
  if self.fdel is None:
   raise AttributeError("can't delete attribute")
  self.fdel(instance)
 def getter(self,fget):
  fdoc=fget.__doc__ if self.overwrite_doc else None
  result=type(self)(fget,self.fset,self.fdel,fdoc or self.__doc__)
  result.overwrite_doc=self.overwrite_doc
  return result
 def setter(self,fset):
  result=type(self)(self.fget,fset,self.fdel,self.__doc__)
  result.overwrite_doc=self.overwrite_doc
  return result
 def deleter(self,fdel):
  result=type(self)(self.fget,self.fset,fdel,self.__doc__)
  result.overwrite_doc=self.overwrite_doc
  return result
class _GeneratorWrapper:

 def __init__(self,gen):
  self.__wrapped=gen
  self.__isgen=gen.__class__ is GeneratorType
  self.__name__=getattr(gen,'__name__',None)
  self.__qualname__=getattr(gen,'__qualname__',None)
 def send(self,val):
  return self.__wrapped.send(val)
 def throw(self,tp,*rest):
  return self.__wrapped.throw(tp,*rest)
 def close(self):
  return self.__wrapped.close()
 @property
 def gi_code(self):
  return self.__wrapped.gi_code
 @property
 def gi_frame(self):
  return self.__wrapped.gi_frame
 @property
 def gi_running(self):
  return self.__wrapped.gi_running
 @property
 def gi_yieldfrom(self):
  return self.__wrapped.gi_yieldfrom
 cr_code=gi_code
 cr_frame=gi_frame
 cr_running=gi_running
 cr_await=gi_yieldfrom
 def __next__(self):
  return next(self.__wrapped)
 def __iter__(self):
  if self.__isgen:
   return self.__wrapped
  return self
 __await__=__iter__
def coroutine(func):
 ''
 if not callable(func):
  raise TypeError('types.coroutine() expects a callable')
 if(func.__class__ is FunctionType and
 getattr(func,'__code__',None).__class__ is CodeType):
  co_flags=func.__code__.co_flags
  if co_flags&0x180:
   return func
  if co_flags&0x20:
   co=func.__code__
   func.__code__=co.replace(co_flags=co.co_flags |0x100)
   return func
 import functools
 import _collections_abc
 @functools.wraps(func)
 def wrapped(*args,**kwargs):
  coro=func(*args,**kwargs)
  if(coro.__class__ is CoroutineType or
  coro.__class__ is GeneratorType and coro.gi_code.co_flags&0x100):
   return coro
  if(isinstance(coro,_collections_abc.Generator)and
  not isinstance(coro,_collections_abc.Coroutine)):
   return _GeneratorWrapper(coro)
  return coro
 return wrapped
GenericAlias=type(list[int])
UnionType=type(int |str)

EllipsisType=type(Ellipsis)
NoneType=type(None)
NotImplementedType=type(NotImplemented)

__all__=[n for n in globals()if n[:1]!='_']
====types.py(module) end====

