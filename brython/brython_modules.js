__BRYTHON__.use_VFS = true
__BRYTHON__.VFS = {"browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "_ajax": [".js", "// ajax\n__BRYTHON__.imported._ajax = (function($B){\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if($B.$isinstance(val, _b_.list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key, _b_.str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(req.charset_user_defined){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else if(typeof xhr.response == \"string\"){\n        if(req.mode == 'binary'){\n            return _b_.str.encode(xhr.response, req.encoding || 'utf-8')\n        }\n        return xhr.response\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.jsobj2pyobj(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction stringify(d){\n    var items = []\n    for(var entry of _b_.dict.$iter_items(d)){\n        items.push(encodeURIComponent(entry.key) + \"=\" +\n                   encodeURIComponent(entry.value))\n    }\n    return items.join(\"&\")\n}\n\nfunction handle_kwargs(self, kw, method){\n    // kw was created with $B.obj_dict(), its keys/values are in kw.$jsobj\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {},\n        rawdata\n\n    for(var item of _b_.dict.$iter_items(kw)){\n        var key = item.key\n        if(key == \"data\"){\n            var rawdata = item.value\n            if(typeof rawdata == \"string\" || rawdata instanceof FormData){\n                data = rawdata\n            }else if(rawdata.__class__ === _b_.dict){\n                data = stringify(rawdata)\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(rawdata))\n            }\n        }else if(key == \"encoding\"){\n            encoding = item.value\n        }else if(key == \"headers\"){\n            var value = item.value\n            if(! $B.$isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(var subitem of _b_.dict.$iter_items(value)){\n                headers[subitem.key.toLowerCase()] = subitem.value\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = item.value\n            }else{\n                var f = item.value\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = item.value\n        }else if(key == \"timeout\"){\n            timeout.seconds = item.value\n        }else if(key == \"cache\"){\n            cache = item.value\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n\n    return {cache, data, rawdata, encoding, headers, mode, timeout}\n}\n\nvar ajax = $B.make_class('ajax')\n\najax.__repr__ = function(self){\n    return '<object Ajax>'\n}\n\najax.__getattribute__ = function(self, attr){\n    if(ajax[attr] !== undefined){\n        return function(){\n            return ajax[attr].call(null, self, ...arguments)\n        }\n    }else if(attr == \"text\"){\n        return _read(self)\n    }else if(attr == \"json\"){\n        if(self.js.responseType == \"json\"){\n            return _read(self)\n        }else{\n            var resp = _read(self)\n            try{\n                return $B.structuredclone2pyobj(JSON.parse(resp))\n            }catch(err){\n                console.log('attr json, invalid resp', resp)\n                throw err\n            }\n        }\n    }else if(self.js[attr] !== undefined){\n        if(typeof self.js[attr] == \"function\"){\n            return function(){\n                if(attr == \"setRequestHeader\"){\n                    ajax.set_header.call(null, self, ...arguments)\n                }else{\n                    if(attr == 'overrideMimeType'){\n                        console.log('override mime type')\n                        self.hasMimeType = true\n                    }\n                    return self.js[attr](...arguments)\n                }\n            }\n        }else{\n            return self.js[attr]\n        }\n    }else if(attr == \"xml\"){\n        return $B.jsobj2pyobj(self.js.responseXML)\n    }\n}\n\najax.bind = function(self, evt, func){\n    // req.bind(evt,func) is the same as req.onevt = func\n    self.js['on' + evt] = function(){\n        try{\n            return func.apply(null, arguments)\n        }catch(err){\n            $B.handle_error(err)\n        }\n    }\n    return _b_.None\n}\n\najax.open = function(){\n    var $ = $B.args('open', 4,\n            {self: null, method: null, url: null, async: null},\n            ['self', 'method', 'url', 'async'], arguments,\n            {async: true}, null, null),\n        self = $.self,\n        method = $.method,\n        url = $.url,\n        async = $.async\n    if(typeof method !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument method should be string, got ' +\n            $B.class_name(method))\n    }\n    if(typeof url !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument url should be string, got ' +\n            $B.class_name(url))\n    }\n    self.$method = method\n    self.blocking = ! self.async\n    self.js.open(method, url, async)\n}\n\najax.read = function(self){\n    return _read(self)\n}\n\najax.send = function(self, params){\n    // params can be Python dictionary or string\n    var content_type\n    for(var key in self.headers){\n        var value = self.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if((self.encoding || self.blocking) && ! self.hasMimeType){\n        // On blocking mode, or if an encoding has been specified,\n        // override Mime type so that bytes are not processed\n        // (unless the Mime type has been explicitely set)\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    var res = ''\n    if(! params){\n        self.js.send()\n        return _b_.None\n    }\n    if($B.$isinstance(params, _b_.str)){\n        res = params\n    }else if($B.$isinstance(params, _b_.dict)){\n        if(content_type == 'multipart/form-data'){\n            // The FormData object serializes the data in the 'multipart/form-data'\n            // content-type so we may as well override that header if it was set\n            // by the user.\n            res = new FormData()\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                add_to_res(res, _b_.str.$factory(items[i][0]), items[i][1])\n            }\n        }else{\n            if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                    ! content_type){\n                // Set default Content-Type for POST requests\n                self.js.setRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded\")\n            }\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                var key = encodeURIComponent(_b_.str.$factory(items[i][0]));\n                if($B.$isinstance(items[i][1], _b_.list)){\n                    for (j = 0; j < items[i][1].length; j++) {\n                        res += key +'=' +\n                            encodeURIComponent(_b_.str.$factory(items[i][1][j])) + '&'\n                    }\n                }else{\n                    res += key + '=' +\n                        encodeURIComponent(_b_.str.$factory(items[i][1])) + '&'\n                }\n            }\n            res = res.substr(0, res.length - 1)\n        }\n    }else if(params instanceof FormData){\n        res = params\n    }else{\n        throw _b_.TypeError.$factory(\n            \"send() argument must be string or dictionary, not '\" +\n            _b_.str.$factory(params.__class__) + \"'\")\n    }\n    self.js.send(res)\n    return _b_.None\n}\n\najax.responseType = _b_.property.$factory(\n    function(_self){\n        return _self.responseType\n    },\n    function(_self, value){\n        console.log('set response type', value)\n        _self.js.responseType = value\n    }\n)\n\najax.set_header = function(self, key, value){\n    self.headers[key.toLowerCase()] = value\n}\n\najax.set_timeout = function(self, seconds, func){\n    self.js.$requestTimer = setTimeout(\n        function() {\n            self.js.abort()\n            func()\n        },\n        seconds * 1000)\n}\n\najax.$factory = function(){\n\n    var xmlhttp = new XMLHttpRequest()\n\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                globalThis.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding,\n        qs = items.data\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    for(var key in items.headers){\n        self.js.setRequestHeader(key, items.headers[key])\n    }\n    var timeout = items.timeout\n    if(timeout.seconds){\n        ajax.set_timeout(self, timeout.seconds, timeout.func)\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method), // common with browser.aio\n        data = items.data\n\n    if($B.$isinstance(data, _b_.dict)){\n        data = stringify(data)\n    }\n    for(var key in items.headers){\n        var value = items.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction form_data(form){\n    var missing = {},\n        $ = $B.args('form_data', 1, {form: null}, ['form'], arguments,\n            {form: missing}, null, null)\n    if($.form === missing){\n        return new FormData()\n    }else{\n        return new FormData($.form)\n    }\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory()\n\n    var items = handle_kwargs(self, kw, method),\n        rawdata = items.rawdata,\n        headers = items.headers\n\n    for(var key in headers){\n        var value = headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n\n    var timeout = items.timeout\n    if(timeout.seconds){\n        ajax.set_timeout(self, timeout.seconds, timeout.func)\n    }\n\n    var method = _b_.dict.$get_string(kw, 'method', 'POST'),\n        field_name = _b_.dict.$get_string(kw, 'field_name', 'filetosave')\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    if(rawdata){\n        if(rawdata instanceof FormData){\n            // append additional data\n            for(var d of rawdata){\n                formdata.append(d[0], d[1])\n            }\n        }else if($B.$isinstance(rawdata, _b_.dict)){\n            for(var item of _b_.dict.$iter_items(rawdata)){\n                formdata.append(item.key, item.value)\n            }\n        }else{\n            throw _b_.ValueError.$factory(\n                'data value must be a dict of form_data')\n        }\n    }\n\n    self.js.open(method, url, _b_.True)\n    self.js.send(formdata)\n\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    connect,\n    form_data,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"], "math": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nconst INF = $B.fast_float(Number.POSITIVE_INFINITY),\n      NINF = $B.fast_float(Number.NEGATIVE_INFINITY),\n      ZERO = $B.fast_float(0),\n      NAN = $B.fast_float(Number.NaN)\n\nvar float_check = function(x) {\n    // Returns a Javascript number\n    if(x.__class__ === $B.long_int){\n        var res = parseInt(x.value)\n        if(! isFinite(res)){\n            throw _b_.OverflowError.$factory('int too big for float')\n        }\n        return res\n    }else if(x.__class__ === _b_.float){\n        return x.value\n    }\n    try{\n        return _b_.float.$factory(x).value\n    }catch(err){\n        throw _b_.TypeError.$factory('must be real number, not ' +\n            $B.class_name(x))\n    }\n}\n\nfunction check_int(x){\n    if(! $B.$isinstance(x, _b_.int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return ($B.$isinstance(x, _b_.float) && Number.isInteger(x.value)) ||\n            $B.$isinstance(x, _b_.int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nfunction overflow(){\n    throw _b_.OverflowError.$factory(\"math range error\")\n}\n\nfunction value_error(){\n    throw _b_.ValueError.$factory(\"math range error\")\n}\n\nvar EPSILON = Math.pow(2, -52),\n    MAX_VALUE = (2 - EPSILON) * Math.pow(2, 1023),\n    MIN_VALUE = Math.pow(2, -1022),\n    Py_HUGE_VAL = Number.POSITIVE_INFINITY,\n    logpi = 1.144729885849400174143427351353058711647,\n    sqrtpi = 1.772453850905516027298167483341145182798\n\nfunction nextUp(x){\n    if(x !== x){ // NaN\n        return x\n    }\n    if(_b_.float.$funcs.isinf(x)){\n        if(_b_.float.$funcs.isninf(x)){\n            return -MAX_VALUE\n        }\n        return _mod.inf\n    }\n    if($B.$isinstance(x, $B.long_int)){\n        x = Number(x.value)\n    }else if($B.$isinstance(x, _b_.float)){\n        x = x.value\n    }\n\n    if(x == +MAX_VALUE){\n        return +1 / 0\n    }\n    if(typeof x == \"number\"){\n        var y = x * (x < 0 ? 1 - EPSILON / 2 : 1 + EPSILON)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ? x + MIN_VALUE * EPSILON : x + MIN_VALUE\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var b = x + (y - x) / 2\n        if(x < b && b < y){\n            y = b;\n        }\n        var c = (y + x) / 2\n        if(x < c && c < y){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }else{\n        var factor = $B.rich_comp('__lt__', x, 0) ? 1 - EPSILON / 2 :\n                                                   1 + EPSILON\n        var y = $B.rich_op(\"__mul__\", x , factor)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ?\n                    $B.rich_op('__add__', x, MIN_VALUE * EPSILON) :\n                    $B.rich_op('__add__', x, MIN_VALUE)\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var y_minus_x = $B.rich_op('__sub__', y, x)\n        var z = $B.rich_op('__truediv__', y_minus_x, 2) // (y - x) / 2\n\n        var b = $B.rich_op('__add__', x, z)\n        if($B.rich_comp('__lt__', x, b) && $B.rich_comp('__lt__', b, y)){\n            y = b;\n        }\n        var c = $B.rich_op('__truediv__', $B.rich_op('__add__', y, x), 2)\n        if($B.rich_comp('__lt__', x, c) && $B.rich_comp('__lt__', c, y)){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }\n}\n\nfunction gcd2(a, b){\n    // GCD of 2 factors\n    if($B.rich_comp(\"__gt__\", b, a)){\n        var temp = a\n        a = b\n        b = temp\n    }\n    while(true){\n        if(b == 0){\n            return a\n        }\n        a = $B.rich_op(\"__mod__\", a, b)\n        if(a == 0){\n            return b\n        }\n        b = $B.rich_op(\"__mod__\", b, a)\n    }\n}\n\nconst LANCZOS_N = 13,\n      lanczos_g = 6.024680040776729583740234375,\n      lanczos_g_minus_half = 5.524680040776729583740234375,\n      lanczos_num_coeffs = [\n    23531376880.410759688572007674451636754734846804940,\n    42919803642.649098768957899047001988850926355848959,\n    35711959237.355668049440185451547166705960488635843,\n    17921034426.037209699919755754458931112671403265390,\n    6039542586.3520280050642916443072979210699388420708,\n    1439720407.3117216736632230727949123939715485786772,\n    248874557.86205415651146038641322942321632125127801,\n    31426415.585400194380614231628318205362874684987640,\n    2876370.6289353724412254090516208496135991145378768,\n    186056.26539522349504029498971604569928220784236328,\n    8071.6720023658162106380029022722506138218516325024,\n    210.82427775157934587250973392071336271166969580291,\n    2.5066282746310002701649081771338373386264310793408\n    ],\n    /* denominator is x*(x+1)*...*(x+LANCZOS_N-2) */\n    lanczos_den_coeffs = [\n    0.0, 39916800.0, 120543840.0, 150917976.0, 105258076.0, 45995730.0,\n    13339535.0, 2637558.0, 357423.0, 32670.0, 1925.0, 66.0, 1.0],\n    /* gamma values for small positive integers, 1 though NGAMMA_INTEGRAL */\n    NGAMMA_INTEGRAL = 23,\n    gamma_integral = [\n    1.0, 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0, 40320.0, 362880.0,\n    3628800.0, 39916800.0, 479001600.0, 6227020800.0, 87178291200.0,\n    1307674368000.0, 20922789888000.0, 355687428096000.0,\n    6402373705728000.0, 121645100408832000.0, 2432902008176640000.0,\n    51090942171709440000.0, 1124000727777607680000.0]\n\n/* Lanczos' sum L_g(x), for positive x */\nfunction lanczos_sum(x){\n    var num = 0.0,\n        den = 0.0,\n        i\n    /* evaluate the rational function lanczos_sum(x).  For large\n       x, the obvious algorithm risks overflow, so we instead\n       rescale the denominator and numerator of the rational\n       function by x**(1-LANCZOS_N) and treat this as a\n       rational function in 1/x.  This also reduces the error for\n       larger x values.  The choice of cutoff point (5.0 below) is\n       somewhat arbitrary; in tests, smaller cutoff values than\n       this resulted in lower accuracy. */\n    if (x < 5.0) {\n        for (i = LANCZOS_N; --i >= 0; ) {\n            num = num * x + lanczos_num_coeffs[i];\n            den = den * x + lanczos_den_coeffs[i];\n        }\n    }else{\n        for (i = 0; i < LANCZOS_N; i++) {\n            num = num / x + lanczos_num_coeffs[i];\n            den = den / x + lanczos_den_coeffs[i];\n        }\n    }\n    return num/den;\n}\n\nfunction m_sinpi(x){\n    // x is float\n    // returns a float\n    var r,\n        y = fmod(fabs(x), 2.0), // float\n        n = _b_.round($B.fast_float(2.0 * y.value)) // int\n    switch(n){\n        case 0:\n            r = sin(pi.value * y.value);\n            break;\n        case 1:\n            r = cos(pi.value * (y.value - 0.5));\n            break;\n        case 2:\n            /* N.B. -sin(pi*(y-1.0)) is *not* equivalent: it would give\n               -0.0 instead of 0.0 when y == 1.0. */\n            r = sin(pi.value * (1.0 - y.value));\n            break;\n        case 3:\n            r = _b_.float.__neg__(cos(pi.value *(y.value - 1.5)))\n            break;\n        case 4:\n            r = sin(pi.value * (y.value - 2.0));\n            break;\n        }\n    return $B.fast_float(copysign(1.0, x).value * r.value);\n}\n\n/*\n   lgamma:  natural log of the absolute value of the Gamma function.\n   For large arguments, Lanczos' formula works extremely well here.\n*/\nfunction m_lgamma(x){\n    var r,\n        absx\n\n    /* special cases */\n    if(! isfinite(x)){\n        if(isnan(x)){\n            return x;  /* lgamma(nan) = nan */\n        }else{\n            return $B.fast_float(Number.POSITIVE_INFINITY); /* lgamma(+-inf) = +inf */\n        }\n    }\n\n    /* integer arguments */\n    var x1 = float_check(x)\n    if(Number.isInteger(x1) && x1 <= 2.0){\n        if(x1 <= 0.0){\n            value_error()\n        }else{\n            return $B.fast_float(0.0); /* lgamma(1) = lgamma(2) = 0.0 */\n        }\n    }\n\n    absx = fabs(x)\n    /* tiny arguments: lgamma(x) ~ -log(fabs(x)) for small x */\n    if (absx.value < 1e-20){\n        return  $B.fast_float(-log(absx).value);\n    }\n    /* Lanczos' formula.  We could save a fraction of a ulp in accuracy by\n       having a second set of numerator coefficients for lanczos_sum that\n       absorbed the exp(-lanczos_g) term, and throwing out the lanczos_g\n       subtraction below; it's probably not worth it. */\n    var lsum = $B.fast_float(lanczos_sum(absx.value))\n    r = log(lsum).value - lanczos_g;\n    r += (absx.value - 0.5) *\n        (log($B.fast_float(absx.value + lanczos_g - 0.5)).value - 1)\n    if (x1 < 0.0){\n        /* Use reflection formula to get value for negative x. */\n        r = logpi - log(fabs(m_sinpi(absx))).value - log(absx).value - r\n    }\n    r = $B.fast_float(r)\n    if(isinf(r)){\n        overflow()\n    }\n    return r;\n}\n\nfunction acos(x){\n    $B.check_nb_args('acos', 1, arguments)\n    $B.check_no_kw('acos', x)\n    if(_mod.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }else{\n        x = float_check(x)\n        if(x > 1 || x < -1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _b_.float.$factory(Math.acos(x))\n    }\n}\n\nfunction acosh(x){\n    $B.check_nb_args('acosh', 1, arguments)\n    $B.check_no_kw('acosh', x)\n\n    if(_b_.float.$funcs.isinf(x)){\n        if(_b_.float.$funcs.isninf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _mod.inf\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }\n    var y = float_check(x)\n    if(y <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(y > Math.pow(2, 28)){ // issue 1590\n        return _b_.float.$factory(_mod.log(y).value + _mod.log(2).value)\n    }\n    return _b_.float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n}\n\nfunction asin(x){\n    $B.check_nb_args('asin', 1, arguments)\n    $B.check_no_kw('asin', x)\n    if(_mod.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }else{\n        x = float_check(x)\n        if(x > 1 || x < -1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _b_.float.$factory(Math.asin(x))\n    }\n}\n\nfunction asinh(x){\n    $B.check_nb_args('asinh', 1, arguments)\n    $B.check_no_kw('asinh', x)\n\n    var y = float_check(x)\n    if(_b_.float.$funcs.isninf(x)){\n        return NINF\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    if(y == 0 && 1 / y === -Infinity){\n        return $B.fast_float(-0.0)\n    }\n    return _b_.float.$factory(Math.asinh(y))\n}\n\nfunction atan(x){\n    $B.check_nb_args('atan', 1, arguments)\n    $B.check_no_kw('atan', x)\n\n    if(_b_.float.$funcs.isninf(x)){return _b_.float.$factory(-Math.PI / 2)}\n    if(_b_.float.$funcs.isinf(x)){return _b_.float.$factory(Math.PI / 2)}\n    return _b_.float.$factory(Math.atan(float_check(x)))\n}\n\nfunction atan2(x, y){\n    $B.check_nb_args('atan2', 2, arguments)\n    $B.check_no_kw('atan2', x, y)\n\n    return _b_.float.$factory(Math.atan2(float_check(x), float_check(y)))\n}\n\nfunction atanh(x){\n    $B.check_nb_args('atanh', 1, arguments)\n    $B.check_no_kw('atanh', x)\n    if(_b_.float.$funcs.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    var y = float_check(x)\n    if(y == 0){\n        return 0\n    }else if(y <= -1 || y >= 1){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return _b_.float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n}\n\nfunction cbrt(x){\n    // Cubic root\n    $B.check_nb_args('cbrt ', 1, arguments)\n    $B.check_no_kw('cbrt ', x)\n\n    var y = float_check(x)\n    if(_b_.float.$funcs.isninf(x)){\n        return NINF\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    var _r = $B.fast_float(Math.cbrt(y))\n    if(_b_.float.$funcs.isinf(_r)){\n        throw _b_.OverflowError.$factory(\"math range error\")\n    }\n    return _r\n}\n\nfunction ceil(x){\n    $B.check_nb_args('ceil', 1, arguments)\n    $B.check_no_kw('ceil', x)\n\n    var res\n\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            throw _b_.OverflowError.$factory(\n                \"cannot convert float infinity to integer\")\n        }else if(_mod.isnan(x)){\n            throw _b_.OverflowError.$factory(\n                \"cannot convert float NaN to integer\")\n        }\n    }\n\n    var klass = x.__class__ || $B.get_class(x)\n\n    try{\n        // Use attribute of the object's class, not of the object\n        // itself (special method)\n        return $B.$call($B.$getattr(klass, '__ceil__'))(x)\n    }catch(err){\n        if(! $B.is_exc(err, [_b_.AttributeError])){\n            throw err\n        }\n    }\n\n    try{\n        x = $B.$call($B.$getattr(klass, '__float__'))(x)\n    }catch(err){\n        if(! $B.is_exc(err, [_b_.AttributeError])){\n            throw err\n        }else{\n            throw _b_.TypeError.$factory(\"must be real number, not \" +\n               $B.class_name(x))\n        }\n    }\n    return _mod.ceil(x)\n}\n\nconst ULLONG_MAX = 2n ** 64n - 1n,\n      LONG_MAX = 2147483647,\n      LONG_MIN = -2147483647,\n      LLONG_MAX = 9223372036854775807n,\n      LLONG_MIN = -9223372036854775807n,\n      p2_64 = 2n ** 64n\n\nconst reduced_factorial_odd_part = [\n    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0x0000000000000003n,\n    0x0000000000000003n, 0x000000000000000fn, 0x000000000000002dn, 0x000000000000013bn,\n    0x000000000000013bn, 0x0000000000000b13n, 0x000000000000375fn, 0x0000000000026115n,\n    0x000000000007233fn, 0x00000000005cca33n, 0x0000000002898765n, 0x00000000260eeeebn,\n    0x00000000260eeeebn, 0x0000000286fddd9bn, 0x00000016beecca73n, 0x000001b02b930689n,\n    0x00000870d9df20adn, 0x0000b141df4dae31n, 0x00079dd498567c1bn, 0x00af2e19afc5266dn,\n    0x020d8a4d0f4f7347n, 0x335281867ec241efn, 0x9b3093d46fdd5923n, 0x5e1f9767cc5866b1n,\n    0x92dd23d6966aced7n, 0xa30d0f4f0a196e5bn, 0x8dc3e5a1977d7755n, 0x2ab8ce915831734bn,\n    0x2ab8ce915831734bn, 0x81d2a0bc5e5fdcabn, 0x9efcac82445da75bn, 0xbc8b95cf58cde171n,\n    0xa0e8444a1f3cecf9n, 0x4191deb683ce3ffdn, 0xddd3878bc84ebfc7n, 0xcb39a64b83ff3751n,\n    0xf8203f7993fc1495n, 0xbd2a2a78b35f4bddn, 0x84757be6b6d13921n, 0x3fbbcfc0b524988bn,\n    0xbd11ed47c8928df9n, 0x3c26b59e41c2f4c5n, 0x677a5137e883fdb3n, 0xff74e943b03b93ddn,\n    0xfe5ebbcb10b2bb97n, 0xb021f1de3235e7e7n, 0x33509eb2e743a58fn, 0x390f9da41279fb7dn,\n    0xe5cb0154f031c559n, 0x93074695ba4ddb6dn, 0x81c471caa636247fn, 0xe1347289b5a1d749n,\n    0x286f21c3f76ce2ffn, 0x00be84a2173e8ac7n, 0x1595065ca215b88bn, 0xf95877595b018809n,\n    0x9c2efe3c5516f887n, 0x373294604679382bn, 0xaf1ff7a888adcd35n, 0x18ddf279a2c5800bn,\n    0x18ddf279a2c5800bn, 0x505a90e2542582cbn, 0x5bacad2cd8d5dc2bn, 0xfe3152bcbff89f41n,\n    0xe1467e88bf829351n, 0xb8001adb9e31b4d5n, 0x2803ac06a0cbb91fn, 0x1904b5d698805799n,\n    0xe12a648b5c831461n, 0x3516abbd6160cfa9n, 0xac46d25f12fe036dn, 0x78bfa1da906b00efn,\n    0xf6390338b7f111bdn, 0x0f25f80f538255d9n, 0x4ec8ca55b8db140fn, 0x4ff670740b9b30a1n,\n    0x8fd032443a07f325n, 0x80dfe7965c83eeb5n, 0xa3dc1714d1213afdn, 0x205b7bbfcdc62007n,\n    0xa78126bbe140a093n, 0x9de1dc61ca7550cfn, 0x84f0046d01b492c5n, 0x2d91810b945de0f3n,\n    0xf5408b7f6008aa71n, 0x43707f4863034149n, 0xdac65fb9679279d5n, 0xc48406e7d1114eb7n,\n    0xa7dc9ed3c88e1271n, 0xfb25b2efdb9cb30dn, 0x1bebda0951c4df63n, 0x5c85e975580ee5bdn,\n    0x1591bc60082cb137n, 0x2c38606318ef25d7n, 0x76ca72f7c5c63e27n, 0xf04a75d17baa0915n,\n    0x77458175139ae30dn, 0x0e6c1330bc1b9421n, 0xdf87d2b5797e8293n, 0xefa5c703e1e68925n,\n    0x2b6b1b3278b4f6e1n, 0xceee27b382394249n, 0xd74e3829f5dab91dn, 0xfdb17989c26b5f1fn,\n    0xc1b7d18781530845n, 0x7b4436b2105a8561n, 0x7ba7c0418372a7d7n, 0x9dbc5c67feb6c639n,\n    0x502686d7f6ff6b8fn, 0x6101855406be7a1fn, 0x9956afb5806930e7n, 0xe1f0ee88af40f7c5n,\n    0x984b057bda5c1151n, 0x9a49819acc13ea05n, 0x8ef0dead0896ef27n, 0x71f7826efe292b21n,\n    0xad80a480e46986efn, 0x01cdc0ebf5e0c6f7n, 0x6e06f839968f68dbn, 0xdd5943ab56e76139n,\n    0xcdcf31bf8604c5e7n, 0x7e2b4a847054a1cbn, 0x0ca75697a4d3d0f5n, 0x4703f53ac514a98bn,\n];\n\nconst inverted_factorial_odd_part = [\n    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0xaaaaaaaaaaaaaaabn,\n    0xaaaaaaaaaaaaaaabn, 0xeeeeeeeeeeeeeeefn, 0x4fa4fa4fa4fa4fa5n, 0x2ff2ff2ff2ff2ff3n,\n    0x2ff2ff2ff2ff2ff3n, 0x938cc70553e3771bn, 0xb71c27cddd93e49fn, 0xb38e3229fcdee63dn,\n    0xe684bb63544a4cbfn, 0xc2f684917ca340fbn, 0xf747c9cba417526dn, 0xbb26eb51d7bd49c3n,\n    0xbb26eb51d7bd49c3n, 0xb0a7efb985294093n, 0xbe4b8c69f259eabbn, 0x6854d17ed6dc4fb9n,\n    0xe1aa904c915f4325n, 0x3b8206df131cead1n, 0x79c6009fea76fe13n, 0xd8c5d381633cd365n,\n    0x4841f12b21144677n, 0x4a91ff68200b0d0fn, 0x8f9513a58c4f9e8bn, 0x2b3e690621a42251n,\n    0x4f520f00e03c04e7n, 0x2edf84ee600211d3n, 0xadcaa2764aaacdfdn, 0x161f4f9033f4fe63n,\n    0x161f4f9033f4fe63n, 0xbada2932ea4d3e03n, 0xcec189f3efaa30d3n, 0xf7475bb68330bf91n,\n    0x37eb7bf7d5b01549n, 0x46b35660a4e91555n, 0xa567c12d81f151f7n, 0x4c724007bb2071b1n,\n    0x0f4a0cce58a016bdn, 0xfa21068e66106475n, 0x244ab72b5a318ae1n, 0x366ce67e080d0f23n,\n    0xd666fdae5dd2a449n, 0xd740ddd0acc06a0dn, 0xb050bbbb28e6f97bn, 0x70b003fe890a5c75n,\n    0xd03aabff83037427n, 0x13ec4ca72c783bd7n, 0x90282c06afdbd96fn, 0x4414ddb9db4a95d5n,\n    0xa2c68735ae6832e9n, 0xbf72d71455676665n, 0xa8469fab6b759b7fn, 0xc1e55b56e606caf9n,\n    0x40455630fc4a1cffn, 0x0120a7b0046d16f7n, 0xa7c3553b08faef23n, 0x9f0bfd1b08d48639n,\n    0xa433ffce9a304d37n, 0xa22ad1d53915c683n, 0xcb6cbc723ba5dd1dn, 0x547fb1b8ab9d0ba3n,\n    0x547fb1b8ab9d0ba3n, 0x8f15a826498852e3n, 0x32e1a03f38880283n, 0x3de4cce63283f0c1n,\n    0x5dfe6667e4da95b1n, 0xfda6eeeef479e47dn, 0xf14de991cc7882dfn, 0xe68db79247630ca9n,\n    0xa7d6db8207ee8fa1n, 0x255e1f0fcf034499n, 0xc9a8990e43dd7e65n, 0x3279b6f289702e0fn,\n    0xe7b5905d9b71b195n, 0x03025ba41ff0da69n, 0xb7df3d6d3be55aefn, 0xf89b212ebff2b361n,\n    0xfe856d095996f0adn, 0xd6e533e9fdf20f9dn, 0xf8c0e84a63da3255n, 0xa677876cd91b4db7n,\n    0x07ed4f97780d7d9bn, 0x90a8705f258db62fn, 0xa41bbb2be31b1c0dn, 0x6ec28690b038383bn,\n    0xdb860c3bb2edd691n, 0x0838286838a980f9n, 0x558417a74b36f77dn, 0x71779afc3646ef07n,\n    0x743cda377ccb6e91n, 0x7fdf9f3fe89153c5n, 0xdc97d25df49b9a4bn, 0x76321a778eb37d95n,\n    0x7cbb5e27da3bd487n, 0x9cff4ade1a009de7n, 0x70eb166d05c15197n, 0xdcf0460b71d5fe3dn,\n    0x5ac1ee5260b6a3c5n, 0xc922dedfdd78efe1n, 0xe5d381dc3b8eeb9bn, 0xd57e5347bafc6aadn,\n    0x86939040983acd21n, 0x395b9d69740a4ff9n, 0x1467299c8e43d135n, 0x5fe440fcad975cdfn,\n    0xcaa9a39794a6ca8dn, 0xf61dbd640868dea1n, 0xac09d98d74843be7n, 0x2b103b9e1a6b4809n,\n    0x2ab92d16960f536fn, 0x6653323d5e3681dfn, 0xefd48c1c0624e2d7n, 0xa496fefe04816f0dn,\n    0x1754a7b07bbdd7b1n, 0x23353c829a3852cdn, 0xbf831261abd59097n, 0x57a8e656df0618e1n,\n    0x16e9206c3100680fn, 0xadad4c6ee921dac7n, 0x635f2b3860265353n, 0xdd6d0059f44b3d09n,\n    0xac4dd6b894447dd7n, 0x42ea183eeaa87be3n, 0x15612d1550ee5b5dn, 0x226fa19d656cb623n,\n]\n\nconst factorial_trailing_zeros = [\n     0,  0,  1,  1,  3,  3,  4,  4,  7,  7,  8,  8, 10, 10, 11, 11,  //  0-15\n    15, 15, 16, 16, 18, 18, 19, 19, 22, 22, 23, 23, 25, 25, 26, 26,  // 16-31\n    31, 31, 32, 32, 34, 34, 35, 35, 38, 38, 39, 39, 41, 41, 42, 42,  // 32-47\n    46, 46, 47, 47, 49, 49, 50, 50, 53, 53, 54, 54, 56, 56, 57, 57,  // 48-63\n    63, 63, 64, 64, 66, 66, 67, 67, 70, 70, 71, 71, 73, 73, 74, 74,  // 64-79\n    78, 78, 79, 79, 81, 81, 82, 82, 85, 85, 86, 86, 88, 88, 89, 89,  // 80-95\n    94, 94, 95, 95, 97, 97, 98, 98, 101, 101, 102, 102, 104, 104, 105, 105,  // 96-111\n    109, 109, 110, 110, 112, 112, 113, 113, 116, 116, 117, 117, 119, 119, 120, 120,  // 112-127\n].map(BigInt)\n\nconst NULL = undefined\n\n/* Calculate C(n, k) for n in the 63-bit range. */\n\nfunction perm_comb_small(n, k, iscomb){\n    if(k == 0){\n        return 1n\n    }\n\n    /* For small enough n and k the result fits in the 64-bit range and can\n     * be calculated without allocating intermediate PyLong objects. */\n    if(iscomb){\n        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)\n         * fits into a uint64_t.  Exclude k = 1, because the second fast\n         * path is faster for this case.*/\n        var fast_comb_limits1 = [\n            0, 0, 127, 127, 127, 127, 127, 127,  // 0-7\n            127, 127, 127, 127, 127, 127, 127, 127,  // 8-15\n            116, 105, 97, 91, 86, 82, 78, 76,  // 16-23\n            74, 72, 71, 70, 69, 68, 68, 67,  // 24-31\n            67, 67, 67  // 32-34\n        ];\n        if(k < fast_comb_limits1.length && n <= fast_comb_limits1[k]){\n            /*\n                comb(n, k) fits into a uint64_t. We compute it as\n                    comb_odd_part << shift\n                where 2**shift is the largest power of two dividing comb(n, k)\n                and comb_odd_part is comb(n, k) >> shift. comb_odd_part can be\n                calculated efficiently via arithmetic modulo 2**64, using three\n                lookups and two uint64_t multiplications.\n            */\n            var comb_odd_part = reduced_factorial_odd_part[n]\n                                   * inverted_factorial_odd_part[k]\n                                   * inverted_factorial_odd_part[n - k];\n            comb_odd_part %= p2_64\n            var shift = factorial_trailing_zeros[n]\n                      - factorial_trailing_zeros[k]\n                      - factorial_trailing_zeros[n - k];\n            return comb_odd_part << shift;\n        }\n\n        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)*k\n         * fits into a long long (which is at least 64 bit).  Only contains\n         * items larger than in fast_comb_limits1. */\n        var fast_comb_limits2 = [\n            0, ULLONG_MAX, 4294967296, 3329022, 102570, 13467, 3612, 1449,  // 0-7\n            746, 453, 308, 227, 178, 147  // 8-13\n        ];\n        if (k < fast_comb_limits2.length && n <= fast_comb_limits2[k]) {\n            /* C(n, k) = C(n, k-1) * (n-k+1) / k */\n            var result = n,\n                i = 1n;\n            while(i < k){\n                result *= --n;\n                result /= ++i;\n            }\n            return result;\n        }\n    }else{\n        /* Maps k to the maximal n so that k <= n and P(n, k)\n         * fits into a long long (which is at least 64 bit). */\n        var fast_perm_limits = [\n            0, ULLONG_MAX, 4294967296, 2642246, 65537, 7133, 1627, 568,  // 0-7\n            259, 142, 88, 61, 45, 36, 30, 26,  // 8-15\n            24, 22, 21, 20, 20  // 16-20\n        ];\n        if (k < fast_perm_limits.length && n <= fast_perm_limits[k]) {\n            if(n <= 127){\n                /* P(n, k) fits into a uint64_t. */\n                var perm_odd_part = reduced_factorial_odd_part[n]\n                                       * inverted_factorial_odd_part[n - k];\n                perm_odd_part %= p2_64\n                var shift = factorial_trailing_zeros[n]\n                          - factorial_trailing_zeros[n - k];\n                var res = perm_odd_part << shift\n\n                return res;\n            }\n\n            /* P(n, k) = P(n, k-1) * (n-k+1) */\n            var result = n;\n            for (var i = 1; i < k; i++) {\n                result *= --n;\n            }\n            return result\n        }\n    }\n\n    /* For larger n use recursive formulas:\n     *\n     *   P(n, k) = P(n, j) * P(n-j, k-j)\n     *   C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j)\n     */\n    var j = k / 2n;\n    var a = perm_comb_small(n, j, iscomb);\n    var b = perm_comb_small(n - j, k - j, iscomb);\n    a = a * b;\n    if(iscomb){\n        b = perm_comb_small(k, j, 1);\n        a = a / b;\n    }\n    return a;\n}\n\n/* Calculate P(n, k) or C(n, k) using recursive formulas.\n * It is more efficient than sequential multiplication thanks to\n * Karatsuba multiplication.\n */\nfunction perm_comb(n, k, iscomb){\n    if(k == 0){\n        return 1;\n    }\n    if(k == 1){\n        return n;\n    }\n\n    /* P(n, k) = P(n, j) * P(n-j, k-j) */\n    /* C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j) */\n    var j = k / 2n\n    var a = perm_comb(n, j, iscomb);\n    //var t = j\n    //n = n - t;\n    var b = perm_comb(n - j, k - j, iscomb);\n    a = a * b;\n    if(iscomb){\n        b = perm_comb_small(k, j, 1);\n        a = a / b;\n    }\n    return a;\n}\n\nfunction comb(n, k){\n    var $ = $B.args('comb', 2, {n: null, k: null}, ['n', 'k'],\n            arguments, {}, null, null),\n        n = $.n,\n        k = $.k\n\n    var result = NULL,\n        temp,\n        overflow, cmp;\n\n    // accept integers or objects with __index__\n    n = $B.PyNumber_Index(n)\n    k = $B.PyNumber_Index(k)\n\n    n = _b_.int.$to_bigint(n);\n    k = _b_.int.$to_bigint(k);\n\n    if(n < 0){\n        throw _b_.ValueError.$factory(\n                        \"n must be a non-negative integer\");\n    }\n    if(k < 0){\n        throw _b_.ValueError.$factory(\n                        \"k must be a non-negative integer\");\n    }\n\n    overflow = n > LLONG_MAX || n < LLONG_MIN\n    if(! overflow){\n        overflow = k > LLONG_MAX || k < LLONG_MIN\n        if (overflow || k > n) {\n            result = 0n;\n        }else{\n            if(n - k < k){\n                k = n - k\n            }\n            if (k > 1) {\n                result = perm_comb_small(n, k, 1);\n            }\n        }\n        /* For k == 1 just return the original n in perm_comb(). */\n    }else{\n        /* k = min(k, n - k) */\n        temp = n - k\n        if(temp < 0) {\n            result = 0n;\n        }\n        if (temp < k) {\n            k = temp\n        }\n\n        overflow = k > LLONG_MAX || k < LLONG_MIN\n        if (overflow) {\n            throw _b_.OverflowError.$factory(\n                         \"min(n - k, k) must not exceed \" +\n                         LLONG_MAX);\n        }\n    }\n    if(result === undefined){\n        result = perm_comb(n, k, 1);\n    }\n\n    return _b_.int.$int_or_long(result)\n}\nfunction copysign(x, y){\n    $B.check_nb_args_no_kw('copysign', 2, arguments)\n\n    var x1 = Math.abs(float_check(x))\n    var y1 = float_check(y)\n    var sign = Math.sign(y1)\n    sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n    return _b_.float.$factory(x1 * sign)\n}\n\nfunction cos(x){\n    $B.check_nb_args('cos ', 1, arguments)\n    $B.check_no_kw('cos ', x)\n    return _b_.float.$factory(Math.cos(float_check(x)))\n}\n\nfunction cosh(x){\n    $B.check_nb_args('cosh', 1, arguments)\n    $B.check_no_kw('cosh', x)\n\n    if(_b_.float.$funcs.isinf(x)){return INF}\n    var y = float_check(x)\n    if(Math.cosh !== undefined){return _b_.float.$factory(Math.cosh(y))}\n    return _b_.float.$factory((Math.pow(Math.E, y) +\n        Math.pow(Math.E, -y)) / 2)\n}\n\nfunction degrees(x){\n    $B.check_nb_args('degrees', 1, arguments)\n    $B.check_no_kw('degrees', x)\n    return _b_.float.$factory(float_check(x) * 180 / Math.PI)\n}\n\nfunction dist(p, q){\n    $B.check_nb_args_no_kw('dist', 2, arguments)\n\n    function test(x){\n        if(typeof x === \"number\"){\n            return x\n        }else if(x.__class__ === _b_.float){\n            return x.value\n        }\n        var y = $B.$getattr(x, '__float__', null)\n        if(y === null){\n            throw _b_.TypeError.$factory('not a float')\n        }\n        return $B.$call(y)().value\n    }\n\n    // build list of differences (as floats) between coordinates of p and q\n    var diffs = [],\n        diff\n\n    if(Array.isArray(p) && Array.isArray(q)){\n        // simple case : p and q are lists of tuples\n        if(p.length != q.length){\n            throw _b_.ValueError.$factory(\"both points must have \" +\n                \"the same number of dimensions\")\n        }\n        p = p.map(test)\n        q = q.map(test)\n        for(var i = 0, len = p.length; i < len; i++){\n            var next_p = p[i],\n                next_q = q[i]\n            var diff = Math.abs(next_p - next_q)\n            diffs.push(diff)\n        }\n    }else{\n        var itp = _b_.iter(p),\n            itq = _b_.iter(q),\n            res = 0\n\n        while(true){\n            try{\n                var next_p = _b_.next(itp)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    // check that the other iterator is also exhausted\n                    try{\n                        var next_q = _b_.next(itq)\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }catch(err){\n                        if(err.__class__ === _b_.StopIteration){\n                            break\n                        }\n                        throw err\n                    }\n                }\n                throw err\n            }\n            next_p = test(next_p)\n            try{\n                var next_q = _b_.next(itq)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    throw _b_.ValueError.$factory(\"both points must have \" +\n                        \"the same number of dimensions\")\n                }\n                throw err\n            }\n            next_q = test(next_q)\n            diff = Math.abs(next_p - next_q)\n            diffs.push(diff)\n        }\n    }\n    for(var diff of diffs){\n        if(! isFinite(diff) && ! isNaN(diff)){\n            return _mod.inf\n        }\n    }\n    for(var diff of diffs){\n        if(isNaN(diff)){\n            return _mod.nan\n        }\n    }\n\n    var res = 0,\n        scale = 1,\n        max_diff = Math.max(...diffs),\n        min_diff = Math.min(...diffs)\n        max_value = Math.sqrt(Number.MAX_VALUE) / p.length,\n        min_value = Math.sqrt(Number.MIN_VALUE) * p.length\n    if(max_diff > max_value){\n        var nb = 0\n        while(max_diff > max_value){\n            scale *= 2\n            max_diff /= 2\n            nb++\n        }\n        for(var diff of diffs){\n            diff = diff / scale\n            res += diff * diff\n        }\n        return $B.fast_float(scale * Math.sqrt(res))\n    }else if(min_diff !== 0 && min_diff < min_value){\n        while(min_diff < min_value){\n            scale *= 2\n            min_diff *= 2\n        }\n        for(var diff of diffs){\n            diff = diff * scale\n            res += diff * diff\n        }\n        return $B.fast_float(Math.sqrt(res) / scale)\n    }else{\n        for(var diff of diffs){\n            res += Math.pow(diff, 2)\n        }\n        return $B.fast_float(Math.sqrt(res))\n    }\n}\n\nconst e = _b_.float.$factory(Math.E)\n\nconst ERF_SERIES_CUTOFF = 1.5,\n      ERF_SERIES_TERMS = 25,\n      ERFC_CONTFRAC_CUTOFF = 30.0,\n      ERFC_CONTFRAC_TERMS = 50\n\n/*\n   Error function, via power series.\n   Given a finite float x, return an approximation to erf(x).\n   Converges reasonably fast for small x.\n*/\n\nfunction m_erf_series(x){\n    var x2, acc, fk, result\n    var i\n\n    x2 = x * x\n    acc = 0.0\n    fk = ERF_SERIES_TERMS + 0.5\n    for(i = 0; i < ERF_SERIES_TERMS; i++){\n        acc = 2.0 + x2 * acc / fk\n        fk -= 1.0\n    }\n    result = acc * x * exp(-x2).value / sqrtpi\n    return result\n}\n\nfunction m_erfc_contfrac(x){\n    var x2, a, da, p, p_last, q, q_last, b, result;\n    var i\n\n    if(x >= ERFC_CONTFRAC_CUTOFF){\n        return 0.0\n    }\n\n    x2 = x * x\n    a = 0.0\n    da = 0.5\n    p = 1.0\n    p_last = 0.0\n    q = da + x2\n    q_last = 1.0\n    for(i = 0; i < ERFC_CONTFRAC_TERMS; i++){\n        var temp\n        a += da\n        da += 2.0\n        b = da + x2\n        temp = p; p = b * p - a * p_last; p_last = temp\n        temp = q; q = b * q - a * q_last; q_last = temp\n    }\n    result = p / q * x * exp(-x2).value / sqrtpi\n    return result\n}\nfunction erf(x){\n    var absx,\n        cf\n    var x1 = float_check(x)\n    if(isNaN(x1)){\n        return x\n    }\n    absx = fabs(x)\n    if(absx.value < ERF_SERIES_CUTOFF){\n        return $B.fast_float(m_erf_series(x1))\n    }else{\n        cf = m_erfc_contfrac(absx.value)\n        return $B.fast_float(x1 > 0.0 ? 1.0 - cf : cf - 1.0)\n    }\n}\n\nfunction erfc(x){\n\n    // inspired from\n    // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n    var y = float_check(x)\n    var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n    var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                 t * ( 1.00002368 +\n                 t * ( 0.37409196 +\n                 t * ( 0.09678418 +\n                 t * (-0.18628806 +\n                 t * ( 0.27886807 +\n                 t * (-1.13520398 +\n                 t * ( 1.48851587 +\n                 t * (-0.82215223 +\n                 t * 0.17087277)))))))))\n    if(y >= 0.0){return 1 - ans}\n    return 1 + ans\n}\n\nfunction erfc(x){\n    $B.check_nb_args_no_kw('erfc', 1, arguments)\n    var absx, cf;\n\n    var x1 = float_check(x)\n    if(isNaN(x1)){\n        return x\n    }\n    absx = fabs(x);\n    if(absx.value < ERF_SERIES_CUTOFF){\n        return $B.fast_float(1.0 - m_erf_series(x1))\n    }else{\n        cf = m_erfc_contfrac(absx.value)\n        return $B.fast_float(x1 > 0.0 ? cf : 2.0 - cf)\n    }\n}\n\nfunction exp(x){\n    $B.check_nb_args('exp', 1, arguments)\n    $B.check_no_kw('exp', x)\n\n     if(_b_.float.$funcs.isninf(x)){\n         return _b_.float.$factory(0)\n     }\n     if(_b_.float.$funcs.isinf(x)){\n         return INF\n     }\n     var _r = Math.exp(float_check(x))\n     if(! isNaN(_r) && ! isFinite(_r)){\n         throw _b_.OverflowError.$factory(\"math range error\")\n     }\n     return _b_.float.$factory(_r)\n}\n\nfunction exp2(x){\n    return pow(2, x)\n}\n\nfunction expm1(x){\n    $B.check_nb_args('expm1', 1, arguments)\n    $B.check_no_kw('expm1', x)\n\n     if(_b_.float.$funcs.isninf(x)){\n         return $B.fast_float(-1)\n     }else if(_b_.float.$funcs.isinf(x)){\n         return INF\n     }\n     var _r = Math.expm1(float_check(x))\n     if((! isNaN(_r)) && ! isFinite(_r)){\n         overflow()\n     }\n     return $B.fast_float(_r)\n}\n\nfunction fabs(x){\n    $B.check_nb_args_no_kw('fabs', 1, arguments)\n    return _b_.float.$funcs.fabs(float_check(x)) // located in py_float.js\n}\n\n// factorial implementation, adapted from CPython's mathmodule.c\n\nconst SmallFactorials = [\n    1n, 1n, 2n, 6n, 24n, 120n, 720n, 5040n, 40320n,\n    362880n, 3628800n, 39916800n, 479001600n,\n    6227020800n, 87178291200n, 1307674368000n,\n    20922789888000n, 355687428096000n, 6402373705728000n,\n    121645100408832000n, 2432902008176640000n\n    ]\n\nconst SIZEOF_LONG = 4\n\nfunction _Py_bit_length(x){\n    const BIT_LENGTH_TABLE = [\n        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n    ]\n    var msb = 0;\n    while(x >= 32n){\n        msb += 6;\n        x >>= 6n;\n    }\n    msb += BIT_LENGTH_TABLE[parseInt(x)];\n    return msb\n}\nfunction count_set_bits(n){\n    var count = 0n;\n    while(n != 0){\n        ++count;\n        n &= n - 1n; /* clear least significant bit */\n    }\n    return count;\n}\n\nfunction factorial_partial_product(start, stop, max_bits){\n    var midpoint,\n        num_operands,\n        left,\n        right,\n        result\n\n    /* If the return value will fit an unsigned long, then we can\n     * multiply in a tight, fast loop where each multiply is O(1).\n     * Compute an upper bound on the number of bits required to store\n     * the answer.\n     *\n     * Storing some integer z requires floor(lg(z))+1 bits, which is\n     * conveniently the value returned by bit_length(z).  The\n     * product x*y will require at most\n     * bit_length(x) + bit_length(y) bits to store, based\n     * on the idea that lg product = lg x + lg y.\n     *\n     * We know that stop - 2 is the largest number to be multiplied.  From\n     * there, we have: bit_length(answer) <= num_operands *\n     * bit_length(stop - 2)\n     */\n\n    num_operands = (stop - start) / 2n;\n    max_bits = BigInt(max_bits)\n    /* The \"num_operands <= 8 * SIZEOF_LONG\" check guards against the\n     * unlikely case of an overflow in num_operands * max_bits. */\n    if(num_operands <= 8 * SIZEOF_LONG &&\n        num_operands * max_bits <= 8 * SIZEOF_LONG) {\n        var j,\n            total;\n        for (total = start, j = start + 2n; j < stop; j += 2n){\n            total *= j;\n        }\n        return total\n    }\n\n    /* find midpoint of range(start, stop), rounded up to next odd number. */\n    midpoint = (start + num_operands) | 1n;\n    left = factorial_partial_product(start, midpoint,\n                                     _Py_bit_length(midpoint - 2n));\n    right = factorial_partial_product(midpoint, stop, max_bits);\n    result = left * right\n    return result;\n}\nfunction factorial_odd_part(n){\n    var i,\n        v, lower, upper,\n        partial, tmp, inner, outer;\n\n    inner = 1n\n    outer = inner;\n    upper = 3n;\n    for (i = BigInt(_Py_bit_length(n)) - 2n; i >= 0; i--) {\n        v = n >> i;\n        if (v <= 2){\n            continue\n        }\n        lower = upper;\n        /* (v + 1) | 1 = least odd integer strictly larger than n / 2**i */\n        upper = (v + 1n) | 1n;\n        /* Here inner is the product of all odd integers j in the range (0,\n           n/2**(i+1)].  The factorial_partial_product call below gives the\n           product of all odd integers j in the range (n/2**(i+1), n/2**i]. */\n        partial = factorial_partial_product(lower, upper,\n                                            _Py_bit_length(upper-2n));\n        /* inner *= partial */\n        tmp = inner * partial\n        inner = tmp;\n        /* Now inner is the product of all odd integers j in the range (0,\n           n/2**i], giving the inner product in the formula above. */\n\n        /* outer *= inner; */\n        tmp = outer * inner\n        outer = tmp;\n    }\n    return outer;\n}\n\nfunction factorial(arg){\n    var x,\n        two_valuation,\n        overflow,\n        result,\n        odd_part;\n    // Check that arg can be converted to an integer, and transform it to\n    // a bigint\n    x = _b_.int.$to_bigint($B.PyNumber_Index(arg))\n    overflow = x > LONG_MAX || x < LONG_MIN\n    if(x > LONG_MAX) {\n        throw _b_.OverflowError.$factory(\n                     \"factorial() argument should not exceed \" +\n                     LONG_MAX)\n    }else if(x < 0) {\n        throw _b_.ValueError.$factory(\n                        \"factorial() not defined for negative values\");\n    }\n\n    /* use lookup table if x is small */\n    if (x < SmallFactorials.length){\n        return _b_.int.$int_or_long(SmallFactorials[x]);\n    }\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part << two_valuation. */\n    odd_part = factorial_odd_part(x);\n    two_valuation = x - count_set_bits(x);\n    return _b_.int.$int_or_long(odd_part << two_valuation);\n}\n\nfunction floor(x){\n    $B.check_nb_args_no_kw('floor', 1, arguments)\n\n    if(typeof x == \"number\" || x.__class__ === _b_.float){\n        return Math.floor(float_check(x))\n    }\n    var klass = $B.get_class(x)\n    try{\n        return $B.$call($B.$getattr(klass, \"__floor__\"))(x)\n    }catch(err){\n        if($B.is_exc(err, [_b_.AttributeError])){\n            try{\n                var float = $B.$call($B.$getattr(klass, \"__float__\"))(x)\n                return floor(float)\n            }catch(err){\n                if($B.is_exc(err, [_b_.AttributeError])){\n                    throw _b_.TypeError.$factory(\"no __float__\")\n                }\n                throw err\n            }\n        }\n    }\n}\n\nfunction fmod(x, y){\n    $B.check_nb_args_no_kw('fmod', 2, arguments)\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n    }\n    y = float_check(y)\n    if(y == 0){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    return _b_.float.$factory(float_check(x) % float_check(y))\n}\n\nfunction frexp(x){\n    $B.check_nb_args_no_kw('frexp', 1, arguments)\n\n    var _l = _b_.float.$funcs.frexp(x)\n    return _b_.tuple.$factory([_b_.float.$factory(_l[0]), _l[1]])\n}\n\nfunction fsum(x){\n    $B.check_nb_args_no_kw('fsum', 1, arguments)\n\n    /* Translation into Javascript of the function msum in an Active\n       State Cookbook recipe : https://code.activestate.com/recipes/393090/\n       by Raymond Hettinger\n    */\n    var partials = [],\n        res = new Number(),\n        _it = _b_.iter(x)\n    while(true){\n        try{\n            var x = _b_.next(_it),\n                i = 0\n            x = float_check(x)\n            for(var j = 0, len = partials.length; j < len; j++){\n                var y = float_check(partials[j])\n                if(Math.abs(x) < Math.abs(y)){\n                    var z = x\n                    x = y\n                    y = z\n                }\n                var hi = x + y,\n                    lo = y - (hi - x)\n                if(lo){\n                    partials[i] = lo\n                    i++\n                }\n                x = hi\n            }\n            partials = partials.slice(0, i).concat([x])\n        }catch(err){\n            if($B.$isinstance(err, _b_.StopIteration)){break}\n            throw err\n        }\n    }\n    var res = 0\n    for(var i = 0; i < partials.length; i++){\n        res += partials[i]\n    }\n    return $B.fast_float(res)\n}\n\nfunction gamma(x){\n    $B.check_nb_args('gamma', 1, arguments)\n    $B.check_no_kw('gamma', x)\n    var x_as_number = x,\n        r,\n        y,\n        z,\n        sqrtpow\n\n    /* special cases */\n    if($B.$isinstance(x, _b_.float)){\n        x_as_number = x.value\n    }else if(! $B.$isinstance(x, _b_.int)){\n        throw _b_.TypeError.$factory(\"must be real number, not \" +\n            $B.class_name(x))\n    }\n    if(x_as_number === Number.POSITIVE_INFINITY || isNaN(x_as_number)){\n        return x\n    }else if(x_as_number === Number.NEGATIVE_INFINITY || x_as_number == 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n\n    /* integer arguments */\n    if(Number.isInteger(x_as_number)){\n        if($B.rich_comp('__lt__', x, 0.0)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if($B.rich_comp('__le__', x, NGAMMA_INTEGRAL)){\n            return $B.fast_float(gamma_integral[x_as_number - 1])\n        }\n    }\n    var absx = fabs(x)\n\n    /* tiny arguments:  tgamma(x) ~ 1/x for x near 0 */\n    if(absx.value < 1e-20){\n        r = 1.0 / x_as_number\n        if(r === Infinity || r === -Infinity){\n            overflow()\n        }\n        return $B.fast_float(r)\n    }\n\n    /* large arguments: assuming IEEE 754 doubles, tgamma(x) overflows for\n       x > 200, and underflows to +-0.0 for x < -200, not a negative\n       integer. */\n    if(absx.value > 200.0){\n        if(x_as_number < 0.0){\n            return $B.fast_float(0.0 / m_sinpi(x).value);\n        }else{\n            overflow()\n        }\n    }\n\n    y = absx.value + lanczos_g_minus_half;\n    /* compute error in sum */\n    if (absx.value > lanczos_g_minus_half) {\n        /* note: the correction can be foiled by an optimizing\n           compiler that (incorrectly) thinks that an expression like\n           a + b - a - b can be optimized to 0.0.  This shouldn't\n           happen in a standards-conforming compiler. */\n        var q = y - absx.value;\n        z = q - lanczos_g_minus_half;\n    }else{\n        var q = y - lanczos_g_minus_half;\n        z = q - absx.value;\n    }\n    z = z * lanczos_g / y;\n    if (x_as_number < 0.0) {\n        r = -pi.value / m_sinpi(absx).value /\n                absx.value * _mod.exp(y).value /\n                lanczos_sum(absx.value);\n        r -= z * r;\n        if(absx.value < 140.0){\n            r /= pow(y, absx.value - 0.5).value;\n        }else{\n            sqrtpow = pow(y, absx.value / 2.0 - 0.25);\n            r /= sqrtpow.value;\n            r /= sqrtpow.value;\n        }\n    }else{\n        r = lanczos_sum(absx.value) / exp(y).value;\n        r += z * r;\n        if(absx.value < 140.0){\n            r *= pow(y, absx.value - 0.5).value;\n        }else{\n            sqrtpow = pow(y, absx.value / 2.0 - 0.25);\n            r *= sqrtpow.value;\n            r *= sqrtpow.value;\n        }\n    }\n    if(r === Number.POSITIVE_INFINITY){\n        overflow()\n    }\n    return $B.fast_float(r);\n}\n// GCD algorithm. Javascript adaptation of Python script at\n// https://gist.github.com/cmpute/baa545f0c2b6be8b628e9ded3c19f6c1\n// by Jacob Zhong\nfunction bit_length(x){\n    return x.toString(2).length\n}\n\n$B.nb_simple_gcd = 0\n\nfunction simple_gcd(a, b){\n    /* a fits into a long, so b must too */\n    $B.nb_simple_gcd++\n    var x = a >= 0 ? a : -a,\n        y = b >= 0 ? b : -b\n\n    /* usual Euclidean algorithm for longs */\n    while (y != 0) {\n        t = y;\n        y = x % y;\n        x = t;\n    }\n    return x\n}\n\nfunction lgcd(x, y){\n    var a, b, c, d\n    if(x < y){\n        return lgcd(y, x)\n    }\n    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),\n                    Math.floor(bit_length(y) / 64))),\n        xbar = x >> (shift * 64n),\n        ybar = y >> (shift * 64n)\n    while(y > p2_64){\n        [a, b, c, d] = [1n, 0n, 0n, 1n]\n        while(ybar + c != 0 && ybar + d != 0){\n            q = (xbar + a) / (ybar + c)\n            p = (xbar + b) / (ybar + d)\n            if(q != p){\n                break\n            }\n            [a, c] = [c, a - q * c]\n            [b, d] = [d, b - q * d]\n            [xbar, ybar] = [ybar, xbar - q * ybar]\n        }\n        if(b == 0){\n            [x, y] = [y, x % y]\n        }else{\n            [x, y] = [a * x + b * y, c * x + d * y]\n        }\n    }\n    return simple_gcd(x, y)\n}\n\nfunction xgcd(x, y){\n    var xneg = x < 0 ? -1n : 1n,\n        yneg = y < 0 ? -1n : 1n,\n        last_r,\n        last_s,\n        last_t,\n        q, r, s, t;\n\n    [x, y] = [x >= 0 ? x : -x, y >= 0 ? y : -y];\n\n    // it's maintained that r = s * x + t * y, last_r = last_s * x + last_t * y\n    [last_r, r] = [x, y];\n    [last_s, s] = [1n, 0n];\n    [last_t, t] = [0n, 1n];\n\n    while(r > 0){\n        q = last_r / r;\n        [last_r, r] = [r, last_r - q * r];\n        [last_s, s] = [s, last_s - q * s];\n        [last_t, t] = [t, last_t - q * t];\n    }\n    return [last_r, last_s * xneg, last_t * yneg]\n}\n\nfunction lxgcd(x, y){\n    var g, cy, cx,\n        s, last_s,\n        t, last_t,\n        a, b, c, d\n    x = x >= 0 ? x : -x\n    y = y >= 0 ? y : -y\n\n    if(x < y){\n        [g, cy, cx] = xgcd(y, x)\n        return [g, cx, cy]\n    }\n\n    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),\n                Math.floor(bit_length(y) / 64))),\n        xbar = x >> (shift * 64n),\n        ybar = y >> (shift * 64n);\n\n    [last_s, s] = [1n, 0n];\n    [last_t, t] = [0n, 1n];\n\n    while(y > p2_64){\n        [a, b, c, d] = [1n, 0n, 0n, 1n]\n        while(ybar + c != 0 && ybar + d != 0){\n            q = (xbar + a) / (ybar + c)\n            p = (xbar + b) / (ybar + d)\n            if(q != p){\n                break\n            };\n            [a, c = c], [a - q * c];\n            [b, d = d], [b - q * d];\n            [xbar, ybar] = [ybar, xbar - q * ybar];\n        }\n        if(b == 0){\n            q = x / y;\n            [x, y] = [y, x % y];\n            [last_s, s] = [s, last_s - q * s];\n            [last_t, t] = [t, last_t - q * t];\n        }else{\n            [x, y] = [a * x + b * y, c * x + d * y];\n            [last_s, s] = [a * last_s + b * s, c * last_s + d * s];\n            [last_t, t] = [a * last_t + b * t, c * last_t + d * t];\n        }\n    }\n    // notice that here x, y could be negative\n    [g, cx, cy] = xgcd(x, y)\n\n    return [g, cx * last_s + cy * s, cx * last_t + cy * t]\n}\n\nfunction gcd(x, y){\n    var $ = $B.args(\"gcd\", 0, {}, [], arguments, {}, 'args', null)\n    var args = $.args.map($B.PyNumber_Index)\n    if(args.length == 0){\n        return 0\n    }else if(args.length == 1){\n        return _b_.abs(args[0])\n    }\n    x = _b_.int.$to_bigint(args[0])\n    y = _b_.int.$to_bigint(args[1])\n    var res = lxgcd(x, y)[0],\n        i = 2\n    while(i < args.length){\n        res = lxgcd(res, _b_.int.$to_bigint(args[i]))[0]\n        i++\n    }\n    return _b_.int.$int_or_long(res)\n}\nfunction hypot(x, y){\n    var $ = $B.args(\"hypot\", 0, {}, [],\n                arguments, {}, \"args\", null)\n    var args = []\n    for(var arg of $.args){\n        try{\n            args.push(float_check(arg))\n        }catch(err){\n            if($B.is_exc(err, [_b_.ValueError])){\n                throw _b_.TypeError.$factory('must be real number, not ' +\n                    $B.class_name(arg))\n            }\n            throw err\n        }\n    }\n    return $B.fast_float(Math.hypot(...args))\n}\n\nvar inf = INF\n\nfunction isclose(){\n    var $ = $B.args(\"isclose\",\n                      4,\n                      {a: null, b: null, rel_tol: null, abs_tol: null},\n                      ['a', 'b', 'rel_tol', 'abs_tol'],\n                      arguments,\n                      {rel_tol: $B.fast_float(1e-09),\n                       abs_tol: $B.fast_float(0.0)},\n                      '*',\n                      null)\n    var a = float_check($.a),\n        b = float_check($.b),\n        rel_tol = float_check($.rel_tol),\n        abs_tol = float_check($.abs_tol)\n\n    if(rel_tol < 0.0 || abs_tol < 0.0){\n        throw _b_.ValueError.$factory('tolerances must be non-negative')\n    }\n\n    if(a == b){\n        return _b_.True\n    }\n    if(_b_.float.$funcs.isinf(a) || _b_.float.$funcs.isinf(b)){\n        return a === b\n    }\n    // isclose(a, b, rel_tol, abs_tol) is the same as\n    // abs_diff = abs(a - b)\n    // max_ab = max(abs(a), abs(b))\n    // abs_diff <= abs_tol or abs_diff / max_ab <= rel_tol\n    // This is more correct than in Python docs:\n    // \"abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\"\n    // because this fails for Decimal instances, which do not support\n    // multiplication by floats\n\n    var diff = b - a,\n        abs_diff = Math.abs(diff)\n    if(abs_diff <= abs_tol){\n        return true\n    }\n    var abs_a = Math.abs(a),\n        abs_b = Math.abs(b),\n        max_ab = Math.max(abs_a, abs_b)\n    return abs_diff / max_ab <= rel_tol\n}\n\nfunction isfinite(x){\n    $B.check_nb_args('isfinite', 1, arguments)\n    $B.check_no_kw('isfinite', x)\n    return isFinite(float_check(x))\n}\n\nfunction isinf(x){\n    $B.check_nb_args('isinf', 1, arguments)\n    $B.check_no_kw('isinf', x)\n    return _b_.float.$funcs.isinf(x)\n}\n\nfunction isnan(x){\n    $B.check_nb_args('isnan', 1, arguments)\n    $B.check_no_kw('isnan', x)\n    return isNaN(float_check(x))\n}\n\nfunction isqrt(x){\n    $B.check_nb_args_no_kw('isqrt', 1, arguments)\n\n    x = $B.PyNumber_Index(x)\n    if($B.rich_comp(\"__lt__\", x, 0)){\n        throw _b_.ValueError.$factory(\n            \"isqrt() argument must be nonnegative\")\n    }\n    if(typeof x == \"number\"){\n        return Math.floor(Math.sqrt(x))\n    }else{ // big integer\n        // adapted from code in mathmodule.c\n        var n = x.value,\n            bit_length = n.toString(2).length,\n            c = BigInt(Math.floor((bit_length - 1) / 2)),\n            c_bit_length = c.toString(2).length,\n            a = 1n,\n            d = 0n,\n            e\n\n        for(var s = BigInt(c_bit_length - 1); s >= 0; s--){\n            // Loop invariant: (a-1)**2 < (n >> 2*(c - d)) < (a+1)**2\n            e = d\n            d = c >> s\n            a = (a << d - e - 1n) + (n >> 2n*c - e - d + 1n) / a\n        }\n        return _b_.int.$int_or_long(a - (a * a > n ? 1n : 0n))\n    }\n}\n\nfunction lcm(){\n    var $ = $B.args(\"lcm\", 0, {}, [], arguments, {}, 'args', null),\n        product = 1\n\n    var args = $.args.map($B.PyNumber_Index)\n    if(args.length == 0){\n        return 1\n    }else if(args.length == 1){\n        return _b_.abs(args[0])\n    }\n    var a = _b_.abs(args[0]),\n        b,\n        product, gcd\n    for(var i = 0, len = args.length; i < len; i++){\n        b = _b_.abs(args[i])\n        if(b == 0){\n            return 0\n        }\n        gcd = gcd2(a, b)\n        product = $B.rich_op('__mul__', a, b)\n        a = $B.$getattr(product, \"__floordiv__\")(gcd)\n    }\n    return a\n}\n\nfunction ldexp(x, i){\n    $B.check_nb_args('ldexp', 2, arguments)\n    $B.check_no_kw('ldexp', x, i)\n    return _b_.float.$funcs.ldexp(x, i)   // in py_float.js\n}\n\nfunction lgamma(x){\n    $B.check_nb_args('lgamma', 1, arguments)\n    $B.check_no_kw('lgamma', x)\n\n    return m_lgamma(x)\n}\n\nfunction longint_mant_exp(long_int){\n    // Returns mantissa and exponent of a long integer\n    var value = long_int.value,\n        exp = value.toString(2).length,\n        exp1 = exp,\n        nb = 0n\n    // 2 ** exp is infinite if n > 1023\n    var nb = Math.floor(exp / 1023),\n        exp1 = BigInt(exp - 1023 * nb)\n    nb = BigInt(nb)\n    var reduced_value = long_int.value / 2n ** (nb * 1023n)\n    var mant = Number(reduced_value) / Number(2n ** exp1)\n    return [mant, exp]\n}\n\nvar log10_func = Math.log10 || (x => Math.log(x) / Math.log(10)),\n    log2_func = Math.log2 || (x => Math.log(x) / Math.log(2))\n\nfunction log(x, base){\n    var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n        arguments, {base: _b_.None}, null, null),\n        x = $.x,\n        base = $.base\n    if(base == 10){\n        return log10(x)\n    }else if(base == 2){\n        return log2(x)\n    }\n    var log\n    if($B.$isinstance(x, $B.long_int)){\n        if(x.value <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        var mant_exp = longint_mant_exp(x)\n        log = Math.log(mant_exp[0]) + Math.log(2) * mant_exp[1]\n    }else if($B.$isinstance(x, _b_.int)){\n        x = _b_.int.$int_value(x)\n        if(x <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        log = Math.log(x)\n    }else{\n        var x1 = float_check(x)\n        if(x1 <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        log = Math.log(x1)\n    }\n    if(x1 <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(base === _b_.None){\n        return $B.fast_float(log)\n    }\n    var denom = _mod.log(base).value\n    if(denom == 0){\n        throw _b_.ZeroDivisionError.$factory('float division by zero')\n    }\n    return $B.fast_float(log / denom)\n}\n\nfunction log1p(x){\n    $B.check_nb_args('log1p', 1, arguments)\n    $B.check_no_kw('log1p', x)\n    if($B.$isinstance(x, $B.long_int)){\n        if($B.long_int.bit_length(x) > 1024){\n            throw _b_.OverflowError.$factory(\n                \"int too large to convert to float\")\n        }\n        x = $B.long_int.$log2($B.fast_long_int(x.value + 1n))\n        return $B.fast_float(Number(x.value) * Math.LN2)\n    }\n    x = float_check(x)\n    if(x + 1 <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return $B.fast_float(Math.log1p(x))\n}\n\nfunction log2(x){\n    $B.check_nb_args('log2', 1, arguments)\n    $B.check_no_kw('log2', x)\n    var log2_func = Math.log2 || (x => Math.log(x) / Math.LN2)\n    if($B.$isinstance(x, $B.long_int)){\n        if(x.value <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        var mant_exp = longint_mant_exp(x)\n        return $B.fast_float(log2_func(mant_exp[0]) + mant_exp[1])\n    }\n    if(_b_.float.$funcs.isninf(x)){\n        throw _b_.ValueError.$factory('')\n    }\n    x = float_check(x)\n    if(x == 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(isNaN(x)){\n        return _b_.float.$factory('nan')\n    }\n    if(x < 0.0){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    return $B.fast_float(log2_func(x))\n}\n\nfunction log10(x){\n    $B.check_nb_args('log10', 1, arguments)\n    $B.check_no_kw('log10', x)\n    if($B.$isinstance(x, $B.long_int)){\n        return $B.fast_float($B.long_int.$log10(x).value)\n    }\n    x = float_check(x)\n    if(x <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return $B.fast_float(Math.log10(x))\n}\n\nfunction modf(x){\n    $B.check_nb_args('modf', 1, arguments)\n    $B.check_no_kw('modf', x)\n\n    if(_b_.float.$funcs.isninf(x)){\n        return _b_.tuple.$factory([0.0, NINF])\n    }\n    if(_b_.float.$funcs.isinf(x)){\n        return _b_.tuple.$factory([0.0, INF])\n    }\n    var x1 = float_check(x)\n\n    if(isNaN(x1)){\n        return _b_.tuple.$factory([_b_.float.$factory('nan'),\n            _b_.float.$factory('nan')])\n    }\n\n    if(x1 > 0){\n       var i = _b_.float.$factory(x1 - Math.floor(x1))\n       return _b_.tuple.$factory([i, _b_.float.$factory(x1 - i.value)])\n    }\n\n    var x2 = Math.ceil(x1)\n    var i = _b_.float.$factory(x1 - x2)\n    return _b_.tuple.$factory([i, _b_.float.$factory(x2)])\n}\n\nvar nan = _b_.float.$factory('nan')\n\nfunction _nextafter(x, y){\n    // always returns a Javascript number\n    if($B.rich_comp('__lt__', y, x)){\n        var nu = nextUp($B.rich_op('__mul__', -1, x))\n        return -nu\n    }else if($B.rich_comp('__gt__', y, x)){\n        return nextUp(x)\n    }else{\n        var res = x !== x ? x : y\n        res = typeof res == 'number' ? res : res.value\n        return res\n    }\n}\n\nfunction make_float(x){\n    return typeof x == 'number' ? $B.fast_float(x) : x\n}\n\nfunction make_number(x){\n    return typeof x == 'number' ? x : x.value\n}\n\nfunction doubleToByteArray(number) {\n    // adapted from https://stackoverflow.com/questions/\n    // 25942516/double-to-byte-array-conversion-in-javascript\n    var buffer = new ArrayBuffer(8);         // JS numbers are 8 bytes long, or 64 bits\n    var longNum = new Float64Array(buffer);  // so equivalent to Float64\n\n    longNum[0] = number;\n\n    return Array.from(new Uint8Array(buffer)).reverse();  // reverse to get little endian\n}\n\nfunction byteArrayToDouble(bytearray) {\n    // adapted from https://stackoverflow.com/questions/\n    // 42699162/javascript-convert-array-of-4-bytes-into-a-float-value-from-modbustcp-read\n    // Create a buffer\n    var buf = new ArrayBuffer(8);\n    // Create a data view of it\n    var view = new DataView(buf);\n\n    // set bytes\n    bytearray.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    // Read the bits as a float\n    var num = view.getFloat64(0);\n    // Done\n    return num\n}\n\nfunction addSteps(array, steps){\n    // convert to BigInt, avoids issue when steps >= 2 ** 32\n    if(steps.__class__ == $B.long_int){\n        steps = steps.value\n    }else{\n        steps = BigInt(steps)\n    }\n    var positive = steps > 0n\n    if(steps < 0n){\n        steps = -steps\n    }\n    var x1 = steps >> 32n,\n        x2 = steps - x1 * 2n ** 32n\n    var buffer = new ArrayBuffer(8)\n    var longStep = new BigInt64Array(buffer)\n    longStep[0] = steps\n    var stepArray = Array.from(new Uint8Array(buffer)).reverse()\n    if(positive){\n        var carry = 0\n        for(var i = 7; i >= 0; i--){\n            array[i] += stepArray[i] + carry\n            if(array[i] > 255){\n                carry = 1\n                array[i] -= 256\n            }else{\n                carry = 0\n            }\n        }\n    }else{\n        var carry = 0\n        for(var i = 7; i >= 0; i--){\n            array[i] -= stepArray[i] - carry\n            if(array[i] < 0){\n                carry = -1\n                array[i] += 256\n            }else{\n                carry = 0\n            }\n        }\n    }\n}\n\nfunction nextafter(){\n    var $ = $B.args(\"nextafter\", 3, {x: null, y: null, steps: null},\n                ['x', 'y', 'steps'], arguments, {steps: _b_.None}, null, null),\n        x = $.x,\n        y = $.y,\n        steps = $.steps\n    if(! $B.$isinstance(x, [_b_.int, _b_.float])){\n        throw _b_.TypeError.$factory('must be a real number, not ' +\n            $B.class_name(x))\n    }\n    if(! $B.$isinstance(y, [_b_.int, _b_.float])){\n        throw _b_.TypeError.$factory('must be a real number, not ' +\n            $B.class_name(y))\n    }\n    if(isnan(x)){\n        return make_float(x)\n    }\n    if(isnan(y)){\n        return make_float(y)\n    }\n    if(steps === _b_.None){\n        return $B.fast_float(_nextafter(x, y))\n    }\n    steps = $B.PyNumber_Index(steps);\n    if(steps < 0) {\n        throw _b_.ValueError.$factory(\n                        \"steps must be a non-negative integer\");\n    }\n    if(steps == 0){\n        return make_float(x)\n    }\n    if(isnan(x)){\n        return make_float(x)\n    }\n    if(isnan(y)){\n        return make_float(y)\n    }\n    var x1 = make_number(x),\n        y1 = make_number(y)\n\n    if(y1 == x1){\n        return make_float(y)\n    }else if(y1 > x1){\n        var x_uint64 = doubleToByteArray(x1)\n        addSteps(x_uint64, steps)\n        var res = byteArrayToDouble(x_uint64)\n        return res >= y1 ? y : make_float(res)\n    }else{\n        var x_uint64 = doubleToByteArray(x1)\n        addSteps(x_uint64, -steps)\n        var res = byteArrayToDouble(x_uint64)\n        return res <= y1 ? y : make_float(res)\n    }\n}\n\nfunction perm(n, k){\n    var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                    arguments, {k: _b_.None}, null, null),\n        n = $.n,\n        k = $.k\n\n    if(k === _b_.None){\n        check_int(n)\n        return _mod.factorial(n)\n    }\n    // raise TypeError if n or k is not an integer\n    n = $B.PyNumber_Index(n)\n    k = $B.PyNumber_Index(k)\n\n    // transform to Javascript BigInt\n    var n1 = _b_.int.$to_bigint(n),\n        k1 = _b_.int.$to_bigint(k);\n\n    if(k1 < 0){\n        throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n    }\n    if(n1 < 0){\n        throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n    }\n    if(k1 == 0){\n        return 1\n    }\n    if(k1 == 1){\n        return n\n    }\n    if(k1 == 2){\n        return _b_.int.$int_or_long(n1 * (n1 - 1n))\n    }\n    if(k1 > n1){\n        return 0\n    }\n    // Evaluates to n! / (n - k)!\n    var fn = _mod.factorial(n),\n        fn_k = _mod.factorial(n - k)\n    return $B.rich_op('__floordiv__', fn, fn_k)\n}\n\nconst pi = $B.fast_float(Math.PI)\n\nfunction pow(){\n    var $ = $B.args(\"pow\", 2, {base: null, exp: null}, ['base', 'exp'],\n                arguments, {}, null, null),\n        x = $.base,\n        y = $.exp\n\n    var x1 = float_check(x)\n    var y1 = float_check(y)\n\n    if(y1 == 0){\n        return _b_.float.$factory(1)\n    }\n    if(x1 == 0 && y1 < 0){\n        if(y1 === -Infinity){\n            return INF\n        }\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    if(isFinite(x1) && x1 < 0 && isFinite(y1) && ! Number.isInteger(y1)){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n\n    if(isNaN(y1)){\n        if(x1 == 1){return _b_.float.$factory(1)}\n        return NAN\n    }\n    if(x1 == 0){\n        return ZERO\n    }\n\n    if(_b_.float.$funcs.isninf(y)){\n        if(_b_.float.$funcs.isinf(x)){ // pow(INF, NINF) = 0.0\n            return ZERO\n        }else if(_b_.float.$funcs.isninf(x)){ // pow(NINF, NINF) = 0.0\n            return ZERO\n        }\n        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n        if(x1 < 1 && x1 > -1){return INF}\n        return ZERO\n    }\n    if(_b_.float.$funcs.isinf(y)){\n        if(_b_.float.$funcs.isinf(x)){ // pow(INF, INF)\n            return INF\n        }\n        if(_b_.float.$funcs.isninf(x)){\n            return INF\n        }\n        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n        if(x1 < 1 && x1 > -1){return ZERO}\n        return INF\n    }\n\n    if(isNaN(x1)){return _b_.float.$factory('nan')}\n    if(_b_.float.$funcs.isninf(x)){\n        if(y1 > 0 && isOdd(y1)){return NINF}\n        if(y1 > 0){return INF}  // this is even or a float\n        if(y1 < 0){return ZERO}\n        if(_b_.float.$float.isinf(y)){return INF}\n        return _b_.float.$factory(1)\n    }\n\n    if(_b_.float.$funcs.isinf(x)){\n        if(y1 > 0){return INF}\n        if(y1 < 0){return ZERO}\n        return _b_.float.$factory(1)\n    }\n\n    var r = Math.pow(x1, y1)\n    if(isNaN(r)){\n        return NAN\n    }\n    if(! isFinite(r)){\n        overflow()\n    }\n    return _b_.float.$factory(r)\n}\n\nfunction prod(){\n    var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                    [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                    null),\n        iterable = $.iterable,\n        start = $.start\n    var res = start,\n        it = _b_.iter(iterable),\n        x\n    while(true){\n        try{\n            x = _b_.next(it)\n            if(x == 0){\n                return 0\n            }\n            res = $B.rich_op('__mul__', res, x)\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return res\n            }\n            throw err\n        }\n    }\n}\n\nfunction radians(x){\n    $B.check_nb_args('radians', 1, arguments)\n    $B.check_no_kw('radians', x)\n\n    return _b_.float.$factory(float_check(x) * Math.PI / 180)\n}\n\nfunction is_finite(x){\n    return typeof x == \"number\" ||\n               (x.__class__ === _b_.floar && isFinite(x.value)) ||\n               $B.$isinstance(x, _b_.int) ||\n               ($B.$isinstance(x, _b_.float) && isFinite(x.value))\n}\n\nfunction remainder(x, y){\n    $B.check_nb_args_no_kw('remainder', 2, arguments)\n    float_check(x) // might raise TypeError\n    /* Deal with most common case first. */\n    if(is_finite(x) && is_finite(y)){\n        var absx,\n            absy,\n            c,\n            m,\n            r;\n\n        if(float_check(y) == 0.0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n\n        absx = fabs(x);\n        absy = fabs(y);\n        m = fmod(absx, absy);\n\n        c = absy.value - m.value\n        if(m.value < c){\n            r = m.value\n        }else if(m.value > c){\n            r = -c\n        }else{\n            r = m.value -\n                    2.0 * fmod($B.fast_float(0.5 * (absx.value - m.value)), absy).value;\n        }\n        return $B.fast_float(copysign(1.0, x).value * r);\n    }\n\n    /* Special values. */\n    if(float_check(y) == 0){\n        if(isnan(x)){\n            return x\n        }\n    }\n    if(isinf(x)){\n        if(isnan(y)){\n            return y\n        }\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(isnan(y)){\n        return y;\n    }\n    return x;\n}\n\nfunction sin(x){\n    $B.check_nb_args('sin ', 1, arguments)\n    $B.check_no_kw('sin ', x)\n    return _b_.float.$factory(Math.sin(float_check(x)))\n}\n\nfunction sinh(x) {\n    $B.check_nb_args('sinh', 1, arguments)\n    $B.check_no_kw('sinh', x)\n\n    var y = float_check(x)\n    if(Math.sinh !== undefined){\n        return _b_.float.$factory(Math.sinh(y))\n    }\n    return _b_.float.$factory(\n        (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n}\n\nfunction sqrt(x){\n    $B.check_nb_args('sqrt ', 1, arguments)\n    $B.check_no_kw('sqrt ', x)\n\n    if(_b_.float.$funcs.isninf(x)){\n        value_error()\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    var y = float_check(x)\n    if(y < 0){\n        value_error()\n    }\n    var _r = $B.fast_float(Math.sqrt(y))\n    if(_b_.float.$funcs.isinf(_r)){\n        overflow()\n    }\n    return _r\n}\n\n/*[clinic input]\nmath.sumprod\n\n    p: object\n    q: object\n    /\n\nReturn the sum of products of values from two iterables p and q.\n\nRoughly equivalent to:\n\n    sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))\n\nFor float and mixed int/float inputs, the intermediate products\nand sums are computed with extended precision.\n[clinic start generated code]*/\n\nconst tl_zero = {hi: 0, lo: 0, tiny: 0}\n\nfunction _check_long_mult_overflow(a, b) {\n\n    /* From Python2's int_mul code:\n\n    Integer overflow checking for * is painful:  Python tried a couple ways, but\n    they didn't work on all platforms, or failed in endcases (a product of\n    -sys.maxint-1 has been a particular pain).\n\n    Here's another way:\n\n    The native long product x*y is either exactly right or *way* off, being\n    just the last n bits of the true product, where n is the number of bits\n    in a long (the delivered product is the true product plus i*2**n for\n    some integer i).\n\n    The native double product (double)x * (double)y is subject to three\n    rounding errors:  on a sizeof(long)==8 box, each cast to double can lose\n    info, and even on a sizeof(long)==4 box, the multiplication can lose info.\n    But, unlike the native long product, it's not in *range* trouble:  even\n    if sizeof(long)==32 (256-bit longs), the product easily fits in the\n    dynamic range of a double.  So the leading 50 (or so) bits of the double\n    product are correct.\n\n    We check these two ways against each other, and declare victory if they're\n    approximately the same.  Else, because the native long product is the only\n    one that can lose catastrophic amounts of information, it's the native long\n    product that must have overflowed.\n\n    */\n\n    /*\n\n    var longprod = (long)((unsigned long)a * b);\n    double doubleprod = (double)a * (double)b;\n    double doubled_longprod = (double)longprod;\n\n    if (doubled_longprod == doubleprod) {\n        return 0;\n    }\n\n    const double diff = doubled_longprod - doubleprod;\n    const double absdiff = diff >= 0.0 ? diff : -diff;\n    const double absprod = doubleprod >= 0.0 ? doubleprod : -doubleprod;\n\n    if (32.0 * absdiff <= absprod) {\n        return 0;\n    }\n\n    return 1;\n    */\n    return 0\n}\n\nfunction long_add_would_overflow(a, b){\n    return (a > 0n) ? (b > BigInt(LONG_MAX) - a) : (b < BigInt(LONG_MIN) - a);\n}\n\nfunction PyLong_CheckExact(n){\n    return typeof n == 'number' || n.__class__ === $B.long_int\n}\n\n/*\n   The default implementation of dl_mul() depends on the C math library\n   having an accurate fma() function as required by \u00a7 7.12.13.1 of the\n   C99 standard.\n\n   The UNRELIABLE_FMA option is provided as a slower but accurate\n   alternative for builds where the fma() function is found wanting.\n   The speed penalty may be modest (17% slower on an Apple M1 Max),\n   so don't hesitate to enable this build option.\n\n   The algorithms are from the T. J. Dekker paper:\n   A Floating-Point Technique for Extending the Available Precision\n   https://csclub.uwaterloo.ca/~pbarfuss/dekker1971.pdf\n*/\n\nfunction dl_split(x) {\n    // Dekker (5.5) and (5.6).\n    var t = x * 134217729.0;  // Veltkamp constant = 2.0 ** 27 + 1\n    var hi = t - (t - x);\n    var lo = x - hi;\n    return {hi, lo};\n}\n\nfunction dl_mul(x, y){\n    // Dekker (5.12) and mul12()\n    var xx = dl_split(x);\n    var yy = dl_split(y);\n    var p = xx.hi * yy.hi;\n    var q = xx.hi * yy.lo + xx.lo * yy.hi;\n    var z = p + q;\n    var zz = p - z + q + xx.lo * yy.lo;\n    return {hi: z, lo:  zz};\n}\n\nfunction dl_sum(a, b){\n    /* Algorithm 3.1 Error-free transformation of the sum */\n    var x = a + b;\n    var z = x - a;\n    var y = (a - (x - z)) + (b - z);\n    return {hi: x, lo: y};\n}\n\nfunction tl_fma(x, y, total){\n    /* Algorithm 5.10 with SumKVert for K=3 */\n    var pr = dl_mul(x, y);\n    var sm = dl_sum(total.hi, pr.hi);\n    var r1 = dl_sum(total.lo, pr.lo);\n    var r2 = dl_sum(r1.hi, sm.lo);\n    return {hi: sm.hi, lo: r2.hi, tiny: total.tiny + r1.lo + r2.lo}\n}\n\nfunction tl_to_d(total){\n    var last = dl_sum(total.lo, total.hi);\n    return total.tiny + last.lo + last.hi;\n}\n\nfunction sumprod(p, q){\n    var $ = $B.args('sumprod', 2, {p: null, q: null}, ['p', 'q'],\n            arguments, {}, null, null)\n    var p_i = NULL,\n        q_i = NULL,\n        term_i = NULL,\n        new_total = NULL;\n    var p_it, q_it, total;\n    var p_next, q_next;\n    var p_stopped = false, q_stopped = false;\n    var int_path_enabled = true,\n        int_total_in_use = false;\n    var flt_path_enabled = true,\n        flt_total_in_use = false;\n    var int_total = 0n;\n    var flt_total = tl_zero;\n\n    p_it = $B.make_js_iterator(p);\n    q_it = $B.make_js_iterator(q);\n    total = 0\n    p_next = p_it.next\n    q_next = q_it.next\n    while (1) {\n        var finished;\n        p_i = p_it.next()\n        if (p_i.done) {\n            /*\n            if (PyErr_Occurred()) {\n                if (!PyErr_ExceptionMatches(PyExc_StopIteration)) {\n                    goto err_exit;\n                }\n                PyErr_Clear();\n            }\n            */\n            p_stopped = true;\n        }else{\n            p_i = p_i.value\n        }\n        q_i = q_it.next()\n        if (q_i.done) {\n            /*\n            if (PyErr_Occurred()) {\n                if (!PyErr_ExceptionMatches(PyExc_StopIteration)) {\n                    goto err_exit;\n                }\n                PyErr_Clear();\n            }\n            */\n            q_stopped = true;\n        }else{\n            q_i = q_i.value\n        }\n        if (p_stopped != q_stopped) {\n            throw _b_.ValueError.$factory(\"Inputs are not the same length\");\n        }\n\n        finished = p_stopped & q_stopped;\n\n        if (int_path_enabled) {\n\n            if (! finished && PyLong_CheckExact(p_i) & PyLong_CheckExact(q_i)) {\n                var overflow;\n                var int_p, int_q, int_prod;\n\n                int_p = _b_.int.$to_bigint($B.PyNumber_Index(p_i))\n                overflow = int_p > LONG_MAX || int_p < LONG_MIN\n\n                if (overflow) {\n                    finalize_int_path()\n                }\n                int_q = _b_.int.$to_bigint($B.PyNumber_Index(q_i));\n                overflow = int_q > LONG_MAX || int_q < LONG_MIN\n                if (overflow) {\n                    finalize_int_path()\n                }\n                if (_check_long_mult_overflow(int_p, int_q)) {\n                    finalize_int_path()\n                }\n                int_prod = int_p * int_q;\n                if (long_add_would_overflow(int_total, int_prod)) {\n                    finalize_int_path()\n                }\n                if(int_path_enabled){\n                    int_total = int_total + int_prod;\n                    int_total_in_use = true;\n                    continue;\n                }\n            }\n\n            if(finished){\n                finalize_int_path()\n            }\n\n          function finalize_int_path(){\n            // We're finished, overflowed, or have a non-int\n            int_path_enabled = false;\n            if (int_total_in_use) {\n                term_i = _b_.int.$int_or_long(int_total);\n                new_total = $B.rich_op('__add__', total, term_i);\n                total = new_total\n                new_total = NULL;\n                int_total = 0;   // An ounce of prevention, ...\n                int_total_in_use = false;\n            }\n          }\n        }\n\n        if (flt_path_enabled) {\n\n            if (!finished) {\n                var flt_p, flt_q;\n                var p_type_float = p_i.__class__ === _b_.float;\n                var q_type_float = q_i.__class__ === _b_.float\n                if(p_type_float && q_type_float) {\n                    flt_p = p_i;\n                    flt_q = q_i;\n                }else if (p_type_float && (PyLong_CheckExact(q_i) ||\n                                           typeof q_i == 'boolean')){\n                    /* We care about float/int pairs and int/float pairs because\n                       they arise naturally in several use cases such as price\n                       times quantity, measurements with integer weights, or\n                       data selected by a vector of bools. */\n                    flt_p = p_i\n                    flt_q = _b_.int.$int_value(q_i)\n                }else if(q_type_float && (PyLong_CheckExact(p_i) ||\n                                          typeof p_i == 'boolean')) {\n                    flt_q = q_i\n                    flt_p = _b_.int.$int_value(p_i)\n                }else{\n                    finalize_flt_path()\n                }\n                if(flt_path_enabled){\n                    var new_flt_total = tl_fma(flt_p.value, flt_q.value, flt_total);\n                    if (isfinite(new_flt_total.hi)) {\n                        flt_total = new_flt_total;\n                        flt_total_in_use = true;\n                        continue;\n                    }\n                }\n            }\n            if(finished){\n                finalize_flt_path()\n            }\n\n          function finalize_flt_path(){\n            // We're finished, overflowed, have a non-float, or got a non-finite value\n            flt_path_enabled = false;\n            if(flt_total_in_use){\n                term_i = $B.fast_float(tl_to_d(flt_total));\n                if (term_i == NULL) {\n                    err_exit()\n                }\n                new_total = $B.rich_op('__add__', total, term_i);\n                total = new_total\n                new_total = NULL\n                flt_total = tl_zero;\n                flt_total_in_use = false;\n            }\n          }\n        }\n\n        if (finished) {\n            return total\n        }\n        term_i = $B.rich_op('__mul__', p_i, q_i);\n        new_total = $B.rich_op('__add__', total, term_i);\n        total = new_total\n        new_total = NULL;\n    }\n\n}\nfunction tan(x) {\n    $B.check_nb_args('tan', 1, arguments)\n    $B.check_no_kw('tan', x)\n\n    var y = float_check(x)\n    return _b_.float.$factory(Math.tan(y))\n}\n\nfunction tanh(x) {\n    $B.check_nb_args('tanh', 1, arguments)\n    $B.check_no_kw('tanh', x)\n\n    var y = float_check(x)\n    if(Math.tanh !== undefined){return _b_.float.$factory(Math.tanh(y))}\n    return _b_.float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n         (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n}\n\nconst tau = $B.fast_float(2 * Math.PI)\n\nfunction trunc(x) {\n    $B.check_nb_args('trunc', 1, arguments)\n    $B.check_no_kw('trunc', x)\n\n   try{return $B.$getattr(x, '__trunc__')()}catch(err){}\n   var x1 = float_check(x)\n   if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n      if(Math.trunc !== undefined){return _b_.int.$factory(Math.trunc(x1))}\n      if(x1 > 0){return _b_.int.$factory(Math.floor(x1))}\n      return _b_.int.$factory(Math.ceil(x1))  // x1 < 0\n   }\n   throw _b_.ValueError.$factory(\n       'object is not a number and does not contain __trunc__')\n}\n\nfunction ulp(){\n    var $ = $B.args(\"ulp\", 1, {x: null}, ['x'], arguments, {}, null, null),\n        x = $.x\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            return _mod.inf\n        }else if(_b_.float.$funcs.isnan(x)){\n            return _mod.nan\n        }\n    }\n    if(typeof x == \"number\"){\n        return x >= 0 ? $B.fast_float(nextUp(x) - x) :\n                       $B.fast_float(x - (-nextUp(-x)))\n    }else if($B.$isinstance(x, $B.long_int)){\n        x = Number(_b_.int.$to_bigint(x))\n        return x > 0 ? $B.fast_float(nextUp(x) - x) :\n                       $B.fast_float(x - (-nextUp(-x)))\n    }else{\n        if($B.rich_comp('__ge__', x, 0)){\n            return $B.rich_op('__sub__', $B.fast_float(nextUp(x.value)), x)\n        }else{\n            var neg_x = $B.$call($B.$getattr(x, \"__neg__\"))()\n            return $B.rich_op('__sub__', x,\n                $B.$call($B.$getattr($B.fast_float(nextUp(neg_x.value)), '__neg__'))())\n        }\n    }\n}\n\nvar _mod = {\n    acos,\n    acosh,\n    asin,\n    asinh,\n    atan,\n    atan2,\n    atanh,\n    cbrt,\n    ceil,\n    comb,\n    copysign,\n    cos,\n    cosh,\n    degrees,\n    dist,\n    e,\n    erf,\n    erfc,\n    exp,\n    exp2,\n    expm1,\n    fabs,\n    factorial,\n    floor,\n    fmod,\n    frexp,\n    fsum,\n    gamma,\n    gcd,\n    hypot,\n    inf,\n    isclose,\n    isfinite,\n    isinf,\n    isnan,\n    isqrt,\n    lcm,\n    ldexp,\n    lgamma,\n    log,\n    log1p,\n    log2,\n    log10,\n    modf,\n    nan,\n    nextafter,\n    perm,\n    pi,\n    pow,\n    prod,\n    radians,\n    remainder,\n    sin,\n    sinh,\n    sqrt,\n    sumprod,\n    tan,\n    tanh,\n    tau,\n    trunc,\n    ulp\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__class__ = $B.builtin_function_or_method\n    }\n}\n\n$B.addToImported('math', _mod)\n\n})(__BRYTHON__)\n"], "json": [".py", "''\n__version__='2.0.9'\n__all__=[\n'dump','dumps','load','loads',\n'JSONDecoder','JSONDecodeError','JSONEncoder',\n]\n\n__author__='Bob Ippolito <bob@redivi.com>'\nclass codecs:\n\n BOM_UTF8=b'\\xef\\xbb\\xbf'\n BOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\n BOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\n BOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\n BOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\nimport _json\nfrom.encoder import JSONEncoder\n\nJSONDecoder=_json.JSONDecoder\n\nclass decoder:\n JSONDecoder=_json.JSONDecoder\nclass JSONDecodeError(ValueError):\n ''\n def __init__(self,msg,doc,pos):\n  lineno=doc.count('\\n',0,pos)+1\n  colno=pos -doc.rfind('\\n',0,pos)\n  errmsg='%s: line %d column %d (char %d)'%(msg,lineno,colno,pos)\n  ValueError.__init__(self,errmsg)\n  self.msg=msg\n  self.doc=doc\n  self.pos=pos\n  self.lineno=lineno\n  self.colno=colno\n def __reduce__(self):\n  return self.__class__,(self.msg,self.doc,self.pos)\ndef dump(obj,fp,**kw):\n fp.write(dumps(obj,**kw))\ndef dumps(obj,*,skipkeys=False,ensure_ascii=True,check_circular=True,\nallow_nan=True,cls=None,indent=None,separators=None,\ndefault=None,sort_keys=False,**kw):\n ''\n if cls is None:\n  return _json.dumps(obj,1,\n  skipkeys=skipkeys,ensure_ascii=ensure_ascii,\n  check_circular=check_circular,allow_nan=allow_nan,indent=indent,\n  separators=separators,default=default,sort_keys=sort_keys,\n  **kw)\n return cls(\n skipkeys=skipkeys,ensure_ascii=ensure_ascii,\n check_circular=check_circular,allow_nan=allow_nan,indent=indent,\n separators=separators,default=default,sort_keys=sort_keys,\n **kw).encode(obj)\ndef detect_encoding(b):\n bstartswith=b.startswith\n if bstartswith((codecs.BOM_UTF32_BE,codecs.BOM_UTF32_LE)):\n  return 'utf-32'\n if bstartswith((codecs.BOM_UTF16_BE,codecs.BOM_UTF16_LE)):\n  return 'utf-16'\n if bstartswith(codecs.BOM_UTF8):\n  return 'utf-8-sig'\n if len(b)>=4:\n  if not b[0]:\n   return 'utf-16-be'if b[1]else 'utf-32-be'\n  if not b[1]:\n   return 'utf-16-le'if b[2]or b[3]else 'utf-32-le'\n elif len(b)==2:\n  if not b[0]:\n   return 'utf-16-be'\n  if not b[1]:\n   return 'utf-16-le'\n return 'utf-8'\ndef load(fp,*,cls=None,object_hook=None,parse_float=None,\nparse_int=None,parse_constant=None,object_pairs_hook=None,**kw):\n ''\n return loads(fp.read(),\n cls=cls,object_hook=object_hook,\n parse_float=parse_float,parse_int=parse_int,\n parse_constant=parse_constant,object_pairs_hook=object_pairs_hook,**kw)\ndef loads(s,*,cls=None,**kw):\n ''\n if isinstance(s,str):\n  if s.startswith('\\ufeff'):\n   raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n   s,0)\n else:\n  if not isinstance(s,(bytes,bytearray)):\n   raise TypeError(f'the JSON object must be str, bytes or bytearray, '\n   f'not {s.__class__.__name__}')\n  s=s.decode(detect_encoding(s),'surrogatepass')\n if \"encoding\"in kw:\n  import warnings\n  warnings.warn(\n  \"'encoding' is ignored and deprecated. It will be removed in Python 3.9\",\n  DeprecationWarning,\n  stacklevel=2\n  )\n  del kw['encoding']\n if cls is None:\n  return _json.loads(s,**kw)\n if object_hook is not None:\n  kw['object_hook']=object_hook\n if object_pairs_hook is not None:\n  kw['object_pairs_hook']=object_pairs_hook\n if parse_float is not None:\n  kw['parse_float']=parse_float\n if parse_int is not None:\n  kw['parse_int']=parse_int\n if parse_constant is not None:\n  kw['parse_constant']=parse_constant\n return cls(**kw).decode(s)\n", ["_json", "json.encoder", "warnings"], 1], "_json": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nfunction simple(obj){\n    switch(typeof obj){\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return true\n    }\n    if(obj instanceof Number ||\n            Array.isArray(obj) ||\n            $B.$isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){\n        return true\n    }\n    return false\n}\n\nfunction to_json(obj, level){\n    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,\n            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,\n            indent:_b_.None, separators:_b_.None, \"default\":_b_.None,\n            sort_keys:_b_.False},\n        $ = $B.args(\"to_json\", 2, {obj: null, level: null}, ['obj', 'level'],\n                    arguments, {level: 1}, null, \"kw\")\n\n    var kw = _b_.dict.$to_obj($.kw)\n    for(var key in $defaults){\n        if(! kw.hasOwnProperty(key)){\n            kw[key] = $defaults[key]\n        }\n    }\n\n    var indent = kw.indent,\n        ensure_ascii = kw.ensure_ascii,\n        separators = kw.separators === _b_.None ?\n             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :\n            kw.separators,\n        skipkeys = kw.skipkeys,\n        _default = kw.default,\n        sort_keys = kw.sort_keys,\n        allow_nan = kw.allow_nan,\n        check_circular = kw.check_circular\n\n    var item_separator = separators[0],\n        key_separator = separators[1]\n    if(indent !== _b_.None){\n        var indent_str\n        if(typeof indent == \"string\"){\n            indent_str = indent\n        }else if(typeof indent == \"number\" && indent >= 1){\n            indent_str = \" \".repeat(indent)\n        }else{\n            throw _b_.ValueError.$factory(\"invalid indent: \" +\n                _b_.str.$factory(indent))\n        }\n    }\n    var kwarg = {$kw: [{}]}\n    for(var key in kw){\n        kwarg.$kw[0][key] = kw[key]\n    }\n\n    switch(typeof obj){\n        case 'string':\n            var res = JSON.stringify(obj)\n            if(ensure_ascii){\n                var escaped = ''\n                for(var i = 0, len = res.length; i < len; i++){\n                    var u = res.codePointAt(i)\n                    if(u > 127){\n                        u = u.toString(16)\n                        while(u.length < 4){\n                            u = \"0\" + u\n                        }\n                        escaped += '\\\\u' + u\n                    }else{\n                        escaped += res.charAt(i)\n                    }\n                }\n                return escaped\n            }\n            return res\n        case 'boolean':\n            return obj.toString()\n        case 'number':\n            if([Infinity, -Infinity].indexOf(obj) > -1 ||\n                    isNaN(obj)){\n                if(! allow_nan){\n                    throw _b_.ValueError.$factory(\n                        'Out of range float values are not JSON compliant')\n                }\n            }\n            return obj.toString()\n    }\n    if(obj instanceof String){\n        if(! ensure_ascii){\n            return $B.String(obj)\n        }\n        // string with surrogate pairs. cf. issue #1903.\n        var res = ''\n        if(obj.surrogates){\n            var s_ix = 0,\n                s_pos = obj.surrogates[s_ix]\n            for(var i = 0, len = obj.length; i < len; i++){\n                if(i == s_pos){\n                    var code = obj.codePointAt(i) - 0x10000\n                    res += '\\\\u' + (0xD800 | (code >> 10)).toString(16) +\n                           '\\\\u' + (0xDC00 | (code & 0x3FF)).toString(16)\n                    i++\n                    s_ix++\n                    s_pos = obj.surrogates[s_ix]\n                }else{\n                    var code = obj.charCodeAt(i)\n                    if(code < 127){\n                        var x = _b_.repr(obj[i])\n                        res += x.substr(1, x.length - 2)\n                    }else{\n                        var x = code.toString(16)\n                        while(x.length < 4){\n                            x = '0' + x\n                        }\n                        res += '\\\\u' + x\n                    }\n                }\n            }\n        }\n        return '\"' + res.replace(new RegExp('\"', \"g\"), '\\\\\"') + '\"'\n    }\n\n    if($B.$isinstance(obj, _b_.list)){\n        var res = []\n        var sep = item_separator,\n            first = '[',\n            last = ']'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '[' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + ']'\n            level++\n        }\n        for(var i = 0, len = obj.length; i < len; i++){\n            res.push(to_json(obj[i], level, kwarg))\n        }\n        return first + res.join(sep) + last\n    }else if($B.$isinstance(obj, _b_.float)){\n        return obj.value\n    }else if(obj.__class__ === $B.long_int){\n        return obj.value.toString()\n    }else if(obj === _b_.None){\n        return \"null\"\n    }else if($B.$isinstance(obj, _b_.dict)){\n        var res = [],\n            items = Array.from($B.make_js_iterator(_b_.dict.items(obj)))\n        if(sort_keys){\n            // Sort keys by alphabetical order\n            items.sort()\n        }\n        var sep = item_separator,\n            first = '{',\n            last = '}'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '{' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + '}'\n            level++\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            var item = items[i]\n            if(! simple(item[0])){\n                if(! skipkeys){\n                    throw _b_.TypeError.$factory(\"keys must be str, int, \" +\n                        \"float, bool or None, not \" + $B.class_name(obj))\n                }\n            }else{\n                // In the result, key must be a string\n                var key = _b_.str.$factory(item[0])\n                // Check circular reference\n                if(check_circular && $B.repr.enter(item[1])){\n                    throw _b_.ValueError.$factory(\"Circular reference detected\")\n                }\n                res.push(\n                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].\n                    join(key_separator))\n                if(check_circular){\n                    $B.repr.leave(item[1])\n                }\n            }\n        }\n        return first + res.join(sep) + last\n    }\n    // For other types, use function default if provided\n    if(_default == _b_.None){\n        throw _b_.TypeError.$factory(\"Object of type \" + $B.class_name(obj) +\n            \" is not JSON serializable\")\n    }else{\n        return to_json($B.$call(_default)(obj), level, kwarg)\n    }\n}\n\nfunction loads(s){\n    var args = []\n    for(var i = 1, len = arguments.length; i < len; i++){\n        args.push(arguments[i])\n    }\n    var decoder = JSONDecoder.$factory.apply(null, args)\n    return JSONDecoder.decode(decoder, s)\n}\n\nfunction to_py(obj, kw){\n    // Conversion to Python objects\n    // kw are the keyword arguments to loads()\n    var res\n    if(obj instanceof List){\n        return obj.items.map(x => to_py(x, kw))\n    }else if(obj instanceof Dict){\n        if(kw.object_pairs_hook !== _b_.None){\n            var pairs = []\n            for(var i = 0, len = obj.keys.length; i < len; i++){\n                pairs.push($B.fast_tuple([obj.keys[i],\n                    to_py(obj.values[i], kw)]))\n            }\n            return $B.$call(kw.object_pairs_hook)(pairs)\n        }else{\n            var dict = $B.empty_dict()\n            for(var i = 0, len = obj.keys.length; i < len; i++){\n                _b_.dict.$setitem(dict, obj.keys[i], to_py(obj.values[i], kw))\n            }\n            return kw.object_hook === _b_.None ? dict :\n                $B.$call(kw.object_hook)(dict)\n        }\n    }else if(obj.type == 'str'){\n        return obj.value\n    }else if(obj.type == 'num'){\n        if(obj.value.search(/[.eE]/) > -1){\n            // float\n            if(kw.parse_float !== _b_.None){\n                return $B.$call(kw.parse_float)(obj.value)\n            }\n            return $B.fast_float(parseFloat(obj.value))\n        }else{\n            // integer\n            if(kw.parse_int !== _b_.None){\n                return $B.$call(kw.parse_int)(obj.value)\n            }\n            var int = parseInt(obj.value)\n            if(Math.abs(int) < $B.max_int){\n                return int\n            }else{\n                return $B.fast_long_int(BigInt(obj.value))\n            }\n        }\n    }else{\n        if(obj instanceof Number && kw.parse_float !== _b_.None){\n            return $B.$call(kw.parse_float)(obj)\n        }else if(kw.parse_int !== _b_.None &&\n                (typeof obj == 'number' || obj.__class__ === $B.long_int)){\n            return $B.$call(kw.parse_int)(obj)\n        }else if(kw.parse_constant !== _b_.None && ! isFinite(obj)){\n            return kw.parse_constant(obj)\n        }\n        return obj\n    }\n}\n\nvar escapes = {'n': '\\n',\n               't': '\\t',\n               'b': '\\b',\n               'r': '\\r',\n               'f': '\\f',\n               '\\\\': '\\\\',\n               '\"': '\\\"',\n               \"'\": \"\\\\'\",\n               '/': '/'\n               }\n\nfunction string_at(s, i){\n    var error = $B.$call($B.imported[\"json\"].JSONDecodeError)\n\n    var j = i + 1,\n        escaped = false,\n        len = s.length,\n        value = ''\n    while(j < len){\n        if(s[j] == '\"' && ! escaped){\n            return [{type: 'str', value}, j + 1]\n        }else if(! escaped && s[j] == '\\\\'){\n            escaped = ! escaped\n            j++\n        }else if(escaped){\n            var esc = escapes[s[j]]\n            if(esc){\n                value += esc\n                j++\n                escaped = false\n            }else if(s[j] == 'u' &&\n                    s.substr(j + 1, 4).match(/[0-9a-fA-f]{4}/)){\n                // unicode escape\n                value += String.fromCharCode(parseInt(s.substr(j + 1, 4), 16))\n                j += 5\n                escaped = ! escaped\n            }else{\n                throw error('invalid escape \"' + s[j] + '\"', s, j)\n            }\n        }else{\n            value += s[j]\n            j++\n        }\n    }\n}\n\nfunction to_num(num_string, nb_dots, exp){\n    // convert to correct Brython type\n    if(exp || nb_dots){\n        return new Number(num_string)\n    }else{\n        var int = parseInt(num_string)\n        if(Math.abs(int) < $B.max_int){\n            return int\n        }else{\n            if(num_string.startsWith('-')){\n                return $B.fast_long_int(num_string.substr(1), false)\n            }else{\n                return $B.fast_long_int(num_string, true)\n            }\n        }\n    }\n}\n\nfunction num_at(s, i){\n  var res = s[i],\n      j = i + 1,\n      nb_dots = 0,\n      exp = false,\n      len = s.length\n  while(j < len){\n      if(s[j].match(/\\d/)){\n        j++\n      }else if(s[j] == '.' && nb_dots == 0){\n        nb_dots++\n        j++\n      }else if('eE'.indexOf(s[j]) > -1 && ! exp){\n        exp = ! exp\n        j++\n      }else if(s[j] == '-' && 'eE'.includes(s[j-1])){\n        j++\n      }else{\n        return [{type: 'num', value: s.substring(i, j)}, j]\n      }\n  }\n  return [{type: 'num', value: s.substring(i, j)}, j]\n}\n\nvar JSONError = $B.make_class('json.decoder.JSONError')\nJSONError.__bases__ = [_b_.Exception]\nJSONError.__mro__ = _b_.type.mro(JSONError)\nfunction* tokenize(s){\n  var i = 0,\n      len = s.length,\n      line_num = 1,\n      column_start = 0,\n      value,\n      end\n  while(i < len){\n    if(s[i] == \" \" || s[i] == '\\r' || s[i] == '\\n' || s[i] == '\\t'){\n      i++\n      line_num++\n      column_start = i\n    }else if('[]{}:,'.indexOf(s[i]) > -1){\n      yield [s[i], i]\n      i++\n    }else if(s.substr(i, 4) == 'null'){\n      yield [_b_.None , i]\n      i += 4\n    }else if(s.substr(i, 4) == 'true'){\n      yield [true, i]\n      i += 4\n    }else if(s.substr(i, 5) == 'false'){\n      yield [false, i]\n      i += 5\n    }else if(s.substr(i, 8) == 'Infinity'){\n      yield [{type: 'num', value: 'Infinity'}, i]\n      i += 8\n    }else if(s.substr(i, 9) == '-Infinity'){\n      yield [{type: 'num', value: '-Infinity'}, i]\n      i += 9\n    }else if(s.substr(i, 3) == 'NaN'){\n      yield [{type: 'num', value: 'NaN'}, i]\n      i += 3\n    }else if(s[i] == '\"'){\n      value = string_at(s, i)\n      yield value\n      i = value[1]\n    }else if(s[i].match(/\\d/) || s[i] == '-'){\n      value = num_at(s, i)\n      yield value\n      i = value[1]\n    }else{\n      throw $B.$call(JSONError)('Extra data: ' +\n          `line ${line_num} column ${1 + i - column_start}`)\n    }\n  }\n}\n\nfunction Node(parent){\n    this.parent = parent\n    if(parent instanceof List){\n        this.list = parent.items\n    }else if(parent instanceof Dict){\n        this.list = parent.values\n    }else if(parent === undefined){\n        this.list = []\n    }\n}\n\nNode.prototype.transition = function(token){\n    if([true, false, _b_.None].includes(token) ||\n            ['str', 'num'].includes(token.type)){\n        if(this.parent === undefined &&\n                (this.list.length > 0 || this.content)){\n            throw Error('Extra data')\n        }\n        this.list.push(token)\n        return this.parent ? this.parent : this\n    }else if(token == '{'){\n        if(this.parent === undefined){\n          this.content = new Dict(this)\n          return this.content\n        }\n        return new Dict(this.parent)\n    }else if(token == '['){\n        if(this.parent === undefined){\n            this.content = new List(this)\n            return this.content\n        }\n        return new List(this.parent)\n    }else{\n        throw Error('unexpected item:' + token)\n    }\n}\n\nfunction Dict(parent){\n    this.parent = parent\n    this.keys = []\n    this.values = []\n    this.expect = 'key'\n    if(parent instanceof List){\n        parent.items.push(this)\n    }else if(parent instanceof Dict){\n        parent.values.push(this)\n    }\n}\n\nDict.prototype.transition = function(token){\n    if(this.expect == 'key'){\n        if(token.type == 'str'){\n            this.keys.push(token.value)\n            this.expect = ':'\n            return this\n        }else if(token == '}' && this.keys.length == 0){\n            return this.parent\n        }else{\n            throw Error('expected str')\n        }\n    }else if(this.expect == ':'){\n        if(token == ':'){\n          this.expect = '}'\n          return new Node(this)\n        }else{\n          throw Error('expected :')\n        }\n    }else if(this.expect == '}'){\n        if(token == '}'){\n            return this.parent\n        }else if(token == ','){\n            this.expect = 'key'\n            return this\n        }\n        throw Error('expected }')\n    }\n}\n\nfunction List(parent){\n    if(parent instanceof List){\n        parent.items.push(this)\n    }\n    this.parent = parent\n    this.items = []\n    this.expect = 'item'\n}\n\nList.prototype.transition = function(token){\n    if(this.expect == 'item'){\n        this.expect = ','\n        if([true, false, _b_.None].indexOf(token) > -1){\n            this.items.push(token)\n            return this\n        }else if(token.type == 'num' || token.type == 'str'){\n            this.items.push(token)\n            return this\n        }else if(token == '{'){\n            return new Dict(this)\n        }else if(token == '['){\n            return new List(this)\n        }else if(token == ']'){\n            if(this.items.length == 0){\n                if(this.parent instanceof Dict){\n                    this.parent.values.push(this)\n                }\n                return this.parent\n            }\n            throw Error('unexpected ]')\n        }else{\n            console.log('token', token)\n            throw Error('unexpected item:' + token)\n        }\n\n    }else if(this.expect == ','){\n        this.expect = 'item'\n        if(token == ','){\n          return this\n        }else if(token == ']'){\n          if(this.parent instanceof Dict){\n              this.parent.values.push(this)\n          }\n          return this.parent\n        }else{\n          throw Error('expected :')\n        }\n    }\n}\n\nfunction parse(s){\n  var res,\n      state,\n      node = new Node(),\n      root = node,\n      token\n  for(var item of tokenize(s)){\n      token = item[0]\n      try{\n          node = node.transition(token)\n      }catch(err){\n          console.log('error, item', item)\n          console.log(err, err.message)\n          console.log('node', node)\n          if(err.__class__){\n              throw err\n          }else{\n              var error = $B.$call($B.imported[\"json\"].JSONDecodeError)\n              throw error(err.message, s, item[1])\n          }\n      }\n  }\n  return root.content ? root.content : root.list[0]\n}\n\nvar JSONDecoder = $B.make_class(\"JSONDecoder\",\n    function(){\n        var $defaults = {cls: _b_.None, object_hook: _b_.None,\n                parse_float: _b_.None, parse_int: _b_.None,\n                parse_constant: _b_.None, object_pairs_hook: _b_.None},\n            $ = $B.args(\"decode\", 0, {}, [], arguments, {}, null, \"kw\")\n        var kw = _b_.dict.$to_obj($.kw)\n        for(var key in $defaults){\n            if(kw[key] === undefined){\n                kw[key] = $defaults[key]\n            }\n        }\n        return {\n            __class__: JSONDecoder,\n            object_hook: kw.object_hook,\n            parse_float: kw.parse_float,\n            parse_int: kw.parse_int,\n            parse_constant: kw.parse_constant,\n            object_pairs_hook: kw.object_pairs_hook,\n            memo: $B.empty_dict()\n        }\n    }\n)\n\nJSONDecoder.decode = function(self, s){\n    return to_py(parse(s), self)\n}\n\n$B.imported._json = {\n    dumps: function(){\n        return _b_.str.$factory(to_json.apply(null, arguments))\n    },\n    loads,\n    JSONDecoder\n}\n\n})(__BRYTHON__)"], "json.encoder": [".py", "''\n\nimport re\n\ntry:\n from _json import encode_basestring_ascii as c_encode_basestring_ascii\nexcept ImportError:\n c_encode_basestring_ascii=None\ntry:\n from _json import encode_basestring as c_encode_basestring\nexcept ImportError:\n c_encode_basestring=None\ntry:\n from _json import make_encoder as c_make_encoder\nexcept ImportError:\n c_make_encoder=None\nESCAPE=re.compile(r'[\\x00-\\x1f\\\\\"\\b\\f\\n\\r\\t]')\nESCAPE_ASCII=re.compile(r'([\\\\\"]|[^\\ -~])')\nHAS_UTF8=re.compile(b'[\\x80-\\xff]')\nESCAPE_DCT={\n'\\\\':'\\\\\\\\',\n'\"':'\\\\\"',\n'\\b':'\\\\b',\n'\\f':'\\\\f',\n'\\n':'\\\\n',\n'\\r':'\\\\r',\n'\\t':'\\\\t',\n}\nfor i in range(0x20):\n ESCAPE_DCT.setdefault(chr(i),'\\\\u{0:04x}'.format(i))\ndel i\n\nINFINITY=float('inf')\n\ndef py_encode_basestring(s):\n ''\n def replace(match):\n  return ESCAPE_DCT[match.group(0)]\n return '\"'+ESCAPE.sub(replace,s)+'\"'\nencode_basestring=(c_encode_basestring or py_encode_basestring)\ndef py_encode_basestring_ascii(s):\n ''\n def replace(match):\n  s=match.group(0)\n  try:\n   return ESCAPE_DCT[s]\n  except KeyError:\n   n=ord(s)\n   if n <0x10000:\n    return '\\\\u{0:04x}'.format(n)\n   else:\n    n -=0x10000\n    s1=0xd800 |((n >>10)&0x3ff)\n    s2=0xdc00 |(n&0x3ff)\n    return '\\\\u{0:04x}\\\\u{1:04x}'.format(s1,s2)\n return '\"'+ESCAPE_ASCII.sub(replace,s)+'\"'\nencode_basestring_ascii=(\nc_encode_basestring_ascii or py_encode_basestring_ascii)\n\nclass JSONEncoder(object):\n ''\n item_separator=', '\n key_separator=': '\n def __init__(self,*,skipkeys=False,ensure_ascii=True,\n check_circular=True,allow_nan=True,sort_keys=False,\n indent=None,separators=None,default=None):\n  ''\n  self.skipkeys=skipkeys\n  self.ensure_ascii=ensure_ascii\n  self.check_circular=check_circular\n  self.allow_nan=allow_nan\n  self.sort_keys=sort_keys\n  self.indent=indent\n  if separators is not None:\n   self.item_separator,self.key_separator=separators\n  elif indent is not None:\n   self.item_separator=','\n  if default is not None:\n   self.default=default\n def default(self,o):\n  ''\n  raise TypeError(f'Object of type {o.__class__.__name__} '\n  f'is not JSON serializable')\n def encode(self,o):\n  ''\n  if isinstance(o,str):\n   if self.ensure_ascii:\n    return encode_basestring_ascii(o)\n   else:\n    return encode_basestring(o)\n  chunks=self.iterencode(o,_one_shot=True)\n  if not isinstance(chunks,(list,tuple)):\n   chunks=list(chunks)\n  return ''.join(chunks)\n def iterencode(self,o,_one_shot=False):\n  ''\n  if self.check_circular:\n   markers={}\n  else:\n   markers=None\n  if self.ensure_ascii:\n   _encoder=encode_basestring_ascii\n  else:\n   _encoder=encode_basestring\n  def floatstr(o,allow_nan=self.allow_nan,\n  _repr=float.__repr__,_inf=INFINITY,_neginf=-INFINITY):\n   if o !=o:\n    text='NaN'\n   elif o ==_inf:\n    text='Infinity'\n   elif o ==_neginf:\n    text='-Infinity'\n   else:\n    return _repr(o)\n   if not allow_nan:\n    raise ValueError(\n    \"Out of range float values are not JSON compliant: \"+\n    repr(o))\n   return text\n  if(_one_shot and c_make_encoder is not None\n  and self.indent is None):\n   _iterencode=c_make_encoder(\n   markers,self.default,_encoder,self.indent,\n   self.key_separator,self.item_separator,self.sort_keys,\n   self.skipkeys,self.allow_nan)\n  else:\n   _iterencode=_make_iterencode(\n   markers,self.default,_encoder,self.indent,floatstr,\n   self.key_separator,self.item_separator,self.sort_keys,\n   self.skipkeys,_one_shot)\n  return _iterencode(o,0)\ndef _make_iterencode(markers,_default,_encoder,_indent,_floatstr,\n_key_separator,_item_separator,_sort_keys,_skipkeys,_one_shot,\n\nValueError=ValueError,\ndict=dict,\nfloat=float,\nid=id,\nint=int,\nisinstance=isinstance,\nlist=list,\nstr=str,\ntuple=tuple,\n_intstr=int.__repr__,\n):\n\n if _indent is not None and not isinstance(_indent,str):\n  _indent=' '*_indent\n def _iterencode_list(lst,_current_indent_level):\n  if not lst:\n   yield '[]'\n   return\n  if markers is not None:\n   markerid=id(lst)\n   if markerid in markers:\n    raise ValueError(\"Circular reference detected\")\n   markers[markerid]=lst\n  buf='['\n  if _indent is not None:\n   _current_indent_level +=1\n   newline_indent='\\n'+_indent *_current_indent_level\n   separator=_item_separator+newline_indent\n   buf +=newline_indent\n  else:\n   newline_indent=None\n   separator=_item_separator\n  first=True\n  for value in lst:\n   if first:\n    first=False\n   else:\n    buf=separator\n   if isinstance(value,str):\n    yield buf+_encoder(value)\n   elif value is None:\n    yield buf+'null'\n   elif value is True:\n    yield buf+'true'\n   elif value is False:\n    yield buf+'false'\n   elif isinstance(value,int):\n    yield buf+_intstr(value)\n   elif isinstance(value,float):\n    yield buf+_floatstr(value)\n   else:\n    yield buf\n    if isinstance(value,(list,tuple)):\n     chunks=_iterencode_list(value,_current_indent_level)\n    elif isinstance(value,dict):\n     chunks=_iterencode_dict(value,_current_indent_level)\n    else:\n     chunks=_iterencode(value,_current_indent_level)\n    yield from chunks\n  if newline_indent is not None:\n   _current_indent_level -=1\n   yield '\\n'+_indent *_current_indent_level\n  yield ']'\n  if markers is not None:\n   del markers[markerid]\n def _iterencode_dict(dct,_current_indent_level):\n  if not dct:\n   yield '{}'\n   return\n  if markers is not None:\n   markerid=id(dct)\n   if markerid in markers:\n    raise ValueError(\"Circular reference detected\")\n   markers[markerid]=dct\n  yield '{'\n  if _indent is not None:\n   _current_indent_level +=1\n   newline_indent='\\n'+_indent *_current_indent_level\n   item_separator=_item_separator+newline_indent\n   yield newline_indent\n  else:\n   newline_indent=None\n   item_separator=_item_separator\n  first=True\n  if _sort_keys:\n   items=sorted(dct.items())\n  else:\n   items=dct.items()\n  for key,value in items:\n   if isinstance(key,str):\n    pass\n   elif isinstance(key,float):\n    key=_floatstr(key)\n   elif key is True:\n    key='true'\n   elif key is False:\n    key='false'\n   elif key is None:\n    key='null'\n   elif isinstance(key,int):\n    key=_intstr(key)\n   elif _skipkeys:\n    continue\n   else:\n    raise TypeError(f'keys must be str, int, float, bool or None, '\n    f'not {key.__class__.__name__}')\n   if first:\n    first=False\n   else:\n    yield item_separator\n   yield _encoder(key)\n   yield _key_separator\n   if isinstance(value,str):\n    yield _encoder(value)\n   elif value is None:\n    yield 'null'\n   elif value is True:\n    yield 'true'\n   elif value is False:\n    yield 'false'\n   elif isinstance(value,int):\n    yield _intstr(value)\n   elif isinstance(value,float):\n    yield _floatstr(value)\n   else:\n    if isinstance(value,(list,tuple)):\n     chunks=_iterencode_list(value,_current_indent_level)\n    elif isinstance(value,dict):\n     chunks=_iterencode_dict(value,_current_indent_level)\n    else:\n     chunks=_iterencode(value,_current_indent_level)\n    yield from chunks\n  if newline_indent is not None:\n   _current_indent_level -=1\n   yield '\\n'+_indent *_current_indent_level\n  yield '}'\n  if markers is not None:\n   del markers[markerid]\n def _iterencode(o,_current_indent_level):\n  if isinstance(o,str):\n   yield _encoder(o)\n  elif o is None:\n   yield 'null'\n  elif o is True:\n   yield 'true'\n  elif o is False:\n   yield 'false'\n  elif isinstance(o,int):\n   yield _intstr(o)\n  elif isinstance(o,float):\n   yield _floatstr(o)\n  elif isinstance(o,(list,tuple)):\n   yield from _iterencode_list(o,_current_indent_level)\n  elif isinstance(o,dict):\n   yield from _iterencode_dict(o,_current_indent_level)\n  else:\n   if markers is not None:\n    markerid=id(o)\n    if markerid in markers:\n     raise ValueError(\"Circular reference detected\")\n    markers[markerid]=o\n   o=_default(o)\n   yield from _iterencode(o,_current_indent_level)\n   if markers is not None:\n    del markers[markerid]\n return _iterencode\n", ["_json", "re"]], "re": [".py", "from python_re import *\n\nimport python_re\n_compile=python_re._compile\n_reconstructor=python_re._reconstructor\n\npython_re._reconstructor.__module__='re'\n", ["python_re"]], "python_re": [".js", "// Regular expression\n(function($B){\n\nvar _debug = {value: 0}\n\nvar _b_ = $B.builtins\n\nvar MAXGROUPS = 2147483647,\n    MAXREPEAT = 2147483648\n\nvar word_gcs = ['Ll', 'Lu', 'Lm', 'Lt', 'Lo',\n                'Nd',\n                'Mc', 'Me', 'Mn',\n                'Pc']\n\nfunction is_word(cp){\n    if((cp >= 97 && cp <= 122) // a-z\n            || (cp >= 65 && cp <= 90) // A-Z\n        ){\n            return true\n    }\n    for(var word_gc of word_gcs){\n        if($B.in_unicode_category(word_gc, cp)){\n            return true\n        }\n    }\n    return false\n}\n\nvar ascii_word = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_word(cp)){\n        ascii_word[cp] = true\n    }\n}\n\nfunction is_ascii_word(cp){\n    return ascii_word[cp] !== undefined\n}\n\nfunction is_digit(cp){\n    if(cp >= 48 && cp <= 57){\n        return true\n    }\n    return $B.in_unicode_category('Nd', cp)\n}\n\nfunction is_ascii_digit(cp){\n    return cp <= 127 && is_digit(cp)\n}\n\nvar $error_2 = {\n    $name: \"error\",\n    $qualname: \"error\",\n    $is_class: true,\n    __module__: \"re\"\n}\n\nvar error = $B.make_class(\"error\",\n    function(message){\n        return {\n            __class__: error,\n            msg: message,\n            args: $B.fast_tuple([]),\n            __cause__: _b_.None,\n            __context__: _b_.None,\n            __suppress_context__: false\n        }\n    })\nerror.__bases__ = [_b_.Exception, _b_.object]\nerror.__mro__ = [_b_.Exception, _b_.BaseException, _b_.object]\n\nerror.__str__ = function(self){\n    var s = self.msg + ' at position ' + self.pos\n    if(self.lineno > 1){\n        s += ` (line ${self.lineno}, column ${self.colno})`\n    }\n    return s\n}\n\n$B.set_func_names(error, \"re\")\n\nfunction $last(t){\n    return t[t.length - 1]\n}\n\nfunction fail(message, pos, pattern){\n    var err = error.$factory(message)\n    err.msg = message\n    err.pos = pos\n    if(pattern){\n        err.pattern = pattern.py_obj // Python object passed to compile()\n        err.lineno = 1\n        var linestart = 0\n        for(var i = 0, len = pattern.string.length; i < pos; i++){\n            if(pattern.string[i] == '\\n'){\n                err.lineno++\n                linestart = i + 1\n            }\n        }\n        err.colno = pos - linestart + 1\n    }\n    throw err\n}\n\nfunction warn(klass, message, pos, text){\n    var frame = $B.frame_obj.frame,\n        file = frame[3].__file__,\n        src = $B.file_cache[file]\n    if(text === undefined){\n        var lineno = frame[1].$lineno\n        var lines = src.split('\\n'),\n            line = lines[lineno - 1]\n    }else{\n        if(Array.isArray(text)){\n            text = from_codepoint_list(text)\n        }\n        var lineno = 1,\n            line_start = 0\n        for(var i = 0; i < pos; i++){\n            if(text[i] == '\\n'){\n                lineno++\n                line_start = i + 1\n            }\n        }\n        var line_end = text.substr(line_start).search('\\n'),\n            line\n        if(line_end == -1){\n            line = text.substr(line_start)\n        }else{\n            line = text.substr(line_start, line_end)\n        }\n        var col_offset = pos - line_start\n    }\n    var warning = klass.$factory(message)\n    warning.pos = pos\n    warning.args[1] = [file, lineno, col_offset, lineno, col_offset,\n        line]\n    warning.filename = file\n    warning.lineno = warning.end_lineno = lineno\n    warning.offset = warning.end_offset = col_offset\n    warning.line = line\n    // module _warning is in builtin_modules.js\n    $B.imported._warnings.warn(warning)\n}\n\nfunction chr(i){\n    if(i < 0 || i > 1114111){\n        throw _b_.ValueError.$factory('Outside valid range')\n    }else if(i >= 0x10000 && i <= 0x10FFFF){\n        var code = (i - 0x10000)\n        return String.fromCodePoint(0xD800 | (code >> 10)) +\n            String.fromCodePoint(0xDC00 | (code & 0x3FF))\n    }else{\n        return String.fromCodePoint(i)\n    }\n}\n\nfunction ord(char){\n    return char.charCodeAt(0)\n}\n\nconst LETTERS = {\n    b: ord('b'),\n    N: ord('N'),\n    P: ord('P'),\n    u: ord('u'),\n    U: ord('U'),\n    x: ord('x')\n}\n\nconst PARENTH_OPEN = ord('('),\n      PARENTH_CLOSE = ord(')'),\n      BRACKET_OPEN = ord('['),\n      BRACKET_CLOSE = ord(']'),\n      BRACE_OPEN = ord('{'),\n      BRACE_CLOSE = ord('}'),\n      EQUAL = ord('='),\n      SUP = ord('>'),\n      INF = ord('<'),\n      MINUS = ord('-'),\n      PLUS = ord('+'),\n      OR = ord('|'),\n      DOT = ord('.'),\n      QUESTION_MARK = ord('?'),\n      EXCLAMATION_MARK = ord('!'),\n      COLON = ord(':'),\n      BACKSLASH = ord('\\\\'),\n      DOLLAR = ord('$'),\n      CARET = ord('^'),\n      LINEFEED = ord('\\n')\n\n// pattern tokenizer\n\nfunction is_ascii(name){\n    return /^[\\x00-\\x7F]*$/.test(name)\n}\n\nfunction open_unicode_db(){\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt?\" + (new Date()).getTime(), false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\n                        \"Warning - could not load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n}\n\nfunction validate_named_char(description, pos){\n    // validate that \\N{<description>} is in the Unicode db\n    // Load unicode table if not already loaded\n    if(description.length == 0){\n        fail(\"missing character name\", pos)\n    }\n    open_unicode_db()\n    if($B.unicodedb !== undefined){\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            description.toUpperCase() + \";.*$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            fail(`undefined character name '${description}'`, pos)\n        }\n        return parseInt(search[1], 16)\n    }else{\n        fail(\"could not load unicode.txt\", pos)\n    }\n}\n\nfunction validate_group_name(sname, pos, is_bytes){\n    // sname is an instance of StringObj\n    if(! _b_.str.isidentifier(sname.string)){\n        fail(`bad character in group name '${sname.string}'`, pos + 4)\n    }\n    if(is_bytes && ! is_ascii(sname.string)){\n        var s = _b_.bytes.decode(_b_.bytes.$factory(sname.codepoints),\n                                 'ascii', 'backslashreplace')\n        warn(_b_.DeprecationWarning,\n            `bad character in group name '${s}' at position ${pos + 4}`)\n    }\n    return true\n}\n\nfunction validate_group_num(so, pos){\n    var s = so.string\n    if(s.match(/^\\d+$/)){\n        return true\n    }\n    try{\n        var num = _b_.int.$factory(s)\n        warn(_b_.DeprecationWarning,\n            `bad character in group name '${s}' at position ${pos + 3}`,\n            pos + 3, s)\n        so.string = num + ''\n        return true\n    }catch(err){\n        return false\n    }\n}\n\nfunction validate_num_or_name(so, pos, is_bytes){\n    return validate_group_num(so, pos, is_bytes) ||\n               validate_group_name(so, pos - 1, is_bytes)\n}\n\nvar character_classes = {\n    in_charset: to_codepoint_list('dDsSwW'),\n    in_re: to_codepoint_list('AbBdDsSwWZ')\n}\n\nfunction escaped_char(args){\n    var cps = args.codepoints,\n        pos = args.pos,\n        in_charset = args.in_charset,\n        is_bytes = args.is_bytes // if pattern is bytes\n    var special = cps[pos + 1]\n    if(special === undefined){\n        fail('bad escape (end of pattern)', pos)\n    }\n    var key = in_charset ? 'in_charset' : 'in_re'\n    if(in_charset && special == LETTERS.b){\n        // Inside a character range, \\b represents the backspace character,\n        // for compatibility with Python\u2019s string literals.\n        return '\\b'\n    }\n    if(character_classes[key].indexOf(special) > -1){\n        return new CharacterClass(pos, special, 2)\n    }else if(special == LETTERS.N && ! is_bytes){\n        if(cps[pos + 2] != BRACE_OPEN){\n            fail('missing {', pos)\n        }\n        var i = pos + 3,\n            description = []\n        while(i < cps.length){\n            if(cps[i] == BRACE_CLOSE){\n                break\n            }\n            description.push(cps[i])\n            i++\n        }\n        if(description.length == 0){\n            fail(\"missing character name\", pos)\n        }\n        if(i == cps.length){\n            fail(\"missing }, unterminated name\", pos)\n        }\n        var cp = validate_named_char(from_codepoint_list(description), pos)\n        return {\n            type: 'N',\n            ord: cp,\n            char: chr(cp),\n            length: i - pos + 1\n        }\n    }else if(special == LETTERS.x){\n        // \\xhh = character with hex value hh\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,2}/.exec(rest),\n            hh = mo ? mo[0] : ''\n        if(mo && mo[0].length == 2){\n            var cp = parseInt(mo[0], 16)\n            return {\n                type: 'x',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\x' + hh, pos)\n    }else if(special == LETTERS.u){\n        // \\uxxxx = character with 16-bit hex value xxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,4}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 4){\n            var cp = parseInt(mo[0], 16)\n            return {\n                type: 'u',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\u' + xx, pos)\n    }else if(special == LETTERS.U){\n        // \\Uxxxxxxxx = character with 32-bit hex value xxxxxxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,8}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 8){\n            var cp = parseInt(mo[0], 16)\n            if(cp > 0x10FFFF){\n                fail(`bad escape \\\\U${mo[0]}`, pos)\n            }\n            return {\n                type: 'U',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\U' + xx, pos)\n    }else{\n        // octal ?\n        // If the first digit of number is 0, or number is 3 octal digits\n        // long, it will not be interpreted as a group match, but as the\n        // character with octal value number\n        var rest = from_codepoint_list(cps.slice(pos + 1)),\n            mo = /^[0-7]{3}/.exec(rest)\n        if(in_charset){\n            try{\n                var res = $B.test_escape(rest, -1)\n                if(res){\n                    return {\n                        type: 'u',\n                        ord: res[0].codePointAt(0),\n                        char: res[0],\n                        length: res[1]\n                    }\n                }\n            }catch(err){\n                // ignore\n            }\n        }\n        if(mo == null){\n            mo = /^0[0-7]*/.exec(rest)\n        }\n        if(mo){\n            var octal_value = parseInt(mo[0], 8)\n            if(octal_value > 0o377){\n                fail(`octal escape value \\\\` +\n                    `${mo[0]} outside of range 0-0o377`, pos)\n            }\n            return {\n                type: 'o',\n                ord: octal_value,\n                char: chr(octal_value),\n                length: 1 + mo[0].length\n            }\n        }\n        var mo = /^\\d{1,2}/.exec(rest) // backref is at most 99\n        if(mo){\n            return {\n                type: 'backref',\n                value: parseInt(mo[0]),\n                length: 1 + mo[0].length\n            }\n        }\n        var trans = {a: chr(7), f: '\\f', n: '\\n', r: '\\r', t: '\\t', v: '\\v'},\n            res = trans[chr(special)]\n        if(res){\n            return ord(res)\n        }\n        if(chr(special).match(/[a-zA-Z]/)){\n            fail(\"bad escape \\\\\" + chr(special), pos)\n        }else{\n            return special\n        }\n    }\n}\n\nfunction check_character_range(t, positions){\n    // Check if last 2 items in t are a valid character range\n    var start = t[t.length - 2],\n        end = t[t.length - 1]\n    if(start instanceof CharacterClass || end instanceof CharacterClass){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }else if(end < start){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }\n    t.splice(t.length - 2, 2, {\n        type: 'character_range',\n        start: start,\n        end: end,\n        ord: [start.ord, end.ord]\n    })\n}\n\nfunction parse_character_set(text, pos, is_bytes){\n    // Parse character set starting at position \"pos\" in \"text\"\n    // pos is the position of the leading \"[\"\n    var start = pos,\n        result = {items: []},\n        positions = []\n    pos++\n    if(text[pos] == CARET){\n        result.neg = true\n        pos++\n    }else if(text[pos] == BRACKET_CLOSE){\n        // a leading ] is the character \"]\", not the set end\n        result.items.push(']')\n        positions.push(pos)\n        pos++\n    }else if(text[pos] == BRACKET_OPEN){\n        // send FutureWarning\n        warn(_b_.FutureWarning, \"Possible nested set\", pos, text)\n    }\n    var range = false\n    while(pos < text.length){\n        var cp = text[pos],\n            char = chr(cp)\n        if(char == ']'){\n            if(pos == start + 2 && result.neg){\n                // in \"[^]]\", the first ] is the character \"]\"\n                result.items.push(']')\n            }else{\n                return [result, pos]\n            }\n        }\n        if(char == '\\\\'){\n            var escape = escaped_char({\n                    codepoints: text,\n                    pos,\n                    in_charset: true,\n                    is_bytes\n                })\n            if(typeof escape == \"number\"){\n                var s = chr(escape)\n                escape = {\n                    ord: escape,\n                    length: 2,\n                    toString: function(){\n                        return s\n                    }\n                }\n            }\n            if(escape.type == \"num\"){\n                // [\\9] is invalid\n                fail(\"bad escape 1 \\\\\" +\n                    escape.value.toString()[0], pos)\n            }\n            result.items.push(escape)\n            positions.push(pos)\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            pos += escape.length\n        }else if(char == '-'){\n            // Character range, or character \"-\"\n            if(pos == start + 1 ||\n                    (result.neg && pos == start + 2) ||\n                    pos == text.length - 2 || // [a-]\n                    range ||\n                    (result.items.length > 0 &&\n                    result.items[result.items.length - 1].type ==\n                        \"character_range\")){\n                result.items.push({\n                    ord: cp,\n                    char,\n                    toString: function(){\n                        return this.char\n                    }\n                })\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos, text)\n                }\n                pos++\n                if(range){\n                    check_character_range(result.items, positions)\n                }\n                range = false\n            }else{\n                range = true\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos, text)\n                }\n                pos++\n            }\n        }else{\n            positions.push(pos)\n            result.items.push({\n                ord: cp,\n                char,\n                toString: function(){\n                    return this.char\n                }\n            })\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            // FutureWarning for consecutive \"&\", \"|\" or \"~\"\n            if(char == \"&\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set intersection\", pos, text)\n            }else if(char == \"|\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set union\", pos, text)\n            }else if(char == \"~\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set symmetric difference\",\n                    pos, text)\n            }\n            pos++\n        }\n    }\n    fail(\"unterminated character set\", start)\n}\n\nfunction* tokenize(pattern, type, _verbose){\n    // pattern is a list of codepoints\n    var is_bytes = type == \"bytes\"\n    // verbose_stack is the stack of verbose state for each group in the regex\n    var verbose_stack = [_verbose],\n        verbose = _verbose,\n        parenth_pos\n    var pos = 0\n    while(pos < pattern.length){\n        var cp = pattern[pos],\n            char = String.fromCharCode(cp)\n        if(verbose){\n            // current group is in verbose mode\n            if(char == \"#\"){\n                // skip until next line feed\n                while(pos < pattern.length && pattern[pos] != 10){\n                    pos++\n                }\n                pos++\n                continue\n            }else{\n                while(pos < pattern.length &&\n                        [9, 10, 11, 12, 13, 32].indexOf(pattern[pos]) > -1){\n                    pos++\n                }\n            }\n            cp = pattern[pos]\n            if(cp === undefined){\n                break\n            }\n            char = String.fromCharCode(cp)\n            if(char == '#'){\n                continue\n            }\n        }\n        if(char == '('){\n            parenth_pos = pos\n            if(pattern[pos + 1] == QUESTION_MARK){\n                if(pattern[pos + 2] == LETTERS.P){\n                    if(pattern[pos + 3] == INF){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == SUP){\n                                break\n                            }else if(pattern[i] == PARENTH_CLOSE){\n                                fail(\"missing >, unterminated name\", pos)\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        var sname = StringObj.from_codepoints(name)\n                        validate_group_name(sname, pos, is_bytes)\n                        name = sname\n                        if(i == pattern.length){\n                            fail(\"missing >, unterminated name\", pos)\n                        }\n                        yield new Group(pos, {type: 'name_def', value: name})\n                        verbose_stack.push(verbose)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] == EQUAL){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == PARENTH_CLOSE){\n                                break\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate_group_name(name, pos, is_bytes)\n                        if(i == pattern.length){\n                            fail(\"missing ), unterminated name\", pos)\n                        }\n                        yield new BackReference(pos, 'name', name.string)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] === undefined){\n                        fail(\"unexpected end of pattern\", pos)\n                    }else{\n                        fail(\"unknown extension ?P\" + chr(pattern[pos + 3]), pos)\n                    }\n                }else if(pattern[pos + 2] == PARENTH_OPEN){\n                    var ref = [],\n                        i = pos + 3\n                    while(i < pattern.length){\n                        if(pattern[i] == PARENTH_CLOSE){\n                            break\n                        }\n                        ref.push(pattern[i])\n                        i++\n                    }\n                    var sref = StringObj.from_codepoints(ref)\n                    if(sref.string.match(/^\\d+$/)){\n                        ref = parseInt(sref.string)\n                    }else{\n                        validate_num_or_name(sref, pos, is_bytes)\n                        ref = sref.string\n                    }\n                    if(i == pattern.length){\n                        fail(\"missing ), unterminated name\", pos)\n                    }\n                    yield new ConditionalBackref(pos, ref)\n                    pos = i + 1\n                    continue\n                }else if(pattern[pos + 2] == EQUAL){\n                    // (?=...) : lookahead assertion\n                    yield new Group(pos, {type: 'lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == EXCLAMATION_MARK){\n                    // (?!...) : negative lookahead assertion\n                    yield new Group(pos, {type: 'negative_lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<!'){\n                    // (?<!...) : negative lookbehind\n                    yield new Group(pos, {type: 'negative_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<='){\n                    // (?<=...) : positive lookbehind\n                    yield new Group(pos, {type: 'positive_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(pattern[pos + 2] == INF){\n                    pos += 3\n                    if(pos == pattern.length){\n                        fail(\"unexpected end of pattern\", pos)\n                    }\n                    fail(\"unknown extension ?<\" + _b_.chr(pattern[pos]), pos)\n                }else if(pattern[pos + 2] == COLON){\n                    yield new Group(pos, {non_capturing: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == SUP){\n                    yield new Group(pos, {atomic: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] === undefined){\n                    fail(\"unexpected end of pattern\", pos)\n                }\n\n                var flags = to_codepoint_list('aiLmsux'),\n                    auL_flags = to_codepoint_list('auL'),\n                    flags_start = pos\n                if(pattern[pos + 2] == MINUS ||\n                        flags.indexOf(pattern[pos + 2]) > -1){\n                    if(pattern[pos + 2] == MINUS){\n                        var on_flags = [],\n                            has_off = true,\n                            off_flags = []\n                        pos += 3\n                    }else{\n                        var on_flags = [chr(pattern[pos + 2])],\n                            has_off = false,\n                            off_flags = [],\n                            auL = auL_flags.indexOf(pattern[pos + 2]) > -1 ?\n                                1 : 0,\n                            closed = false\n                        pos += 3\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    auL++\n                                    if(auL > 1){\n                                        fail(\"bad inline flags: flags 'a', 'u'\" +\n                                            \" and 'L' are incompatible\", pos)\n                                    }\n                                }\n                                on_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == MINUS){\n                                has_off = true\n                                closed = true\n                                pos++\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(pattern[pos] == PARENTH_CLOSE){\n                                closed = true\n                                break\n                            }else if(pattern[pos] == COLON){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                closed = true\n                                break\n                            }else{\n                                fail(\"missing -, : or )\", pos)\n                            }\n                        }\n                        if(! closed){\n                            fail(\"missing -, : or )\", pos)\n                        }\n                    }\n                    if(has_off){\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    fail(\"bad inline flags: cannot turn off \" +\n                                        \"flags 'a', 'u' and 'L'\", pos)\n                                }\n                                if(on_flags.indexOf(chr(pattern[pos])) > -1){\n                                    fail(\"bad inline flags: flag turned on and off\", pos)\n                                }\n                                off_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == COLON){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(off_flags.length == 0){\n                                fail(\"missing flag\", pos)\n                            }else{\n                                fail(\"missing :\", pos)\n                            }\n                        }\n                        if(off_flags.length == 0){\n                            fail(\"missing flag\", pos)\n                        }\n                    }\n                    if(has_off && pattern[pos] != COLON){\n                        fail(\"missing :\", pos)\n                    }\n                    if(on_flags.length == 0 && off_flags.length == 0){\n                        fail(\"missing flag\", pos)\n                    }\n                    var set_flags = new SetFlags(flags_start,\n                        {on_flags, off_flags})\n\n                    yield set_flags\n                    // reset verbose\n                    if(on_flags.indexOf('x') > -1){\n                        verbose = true\n                        verbose_stack.push(verbose)\n                    }\n                    if(off_flags.indexOf('x') > -1){\n                        verbose = false\n                    }\n                    if(! closed){\n                        node = set_flags\n                    }\n                    pos++\n                }else if(pattern[pos + 2] == ord('#')){\n                    pos += 3\n                    while(pos < pattern.length){\n                        if(pattern[pos] == PARENTH_CLOSE){\n                            break\n                        }\n                        pos++\n                    }\n                    if(pos == pattern.length){\n                        fail(\"missing ), unterminated comment\", pos)\n                    }\n                    pos++\n                    continue\n                }else{\n                    fail(\"unknown extension ?\" + _b_.chr(pattern[pos + 2]),\n                        pos)\n                }\n            }else{\n                yield new Group(pos)\n                verbose_stack.push(verbose)\n                pos++\n            }\n        }else if(cp == PARENTH_CLOSE){\n            yield new GroupEnd(pos)\n            verbose_stack.pop()\n            verbose = $last(verbose_stack)\n            pos++\n        }else if(cp == BACKSLASH){\n            var escape = escaped_char({codepoints: pattern, pos, is_bytes})\n            if(escape instanceof CharacterClass){\n                yield escape\n                pos += escape.length\n            }else if(escape.char !== undefined){\n                yield new Char(pos, escape.ord)\n                pos += escape.length\n            }else if(escape.type == \"backref\"){\n                var len = escape.length\n                if(escape.value.length > 2){\n                    escape.value = escape.value.substr(0, 2)\n                    len = 2\n                }\n                yield new BackReference(pos, \"num\", escape.value)\n                pos += len\n            }else if(typeof escape == \"number\"){\n                // eg \"\\.\"\n                var esc = new Char(pos, escape)\n                esc.escaped = true\n                yield esc\n                pos += 2\n            }else{\n                yield new Char(pos, escape)\n                pos += escape.length\n            }\n        }else if(cp == BRACKET_OPEN){\n            // Set of characters\n            var set,\n                end_pos\n            [set, end_pos] = parse_character_set(pattern, pos, is_bytes)\n            yield new CharacterSet(pos, set)\n            pos = end_pos + 1\n        }else if('+?*'.indexOf(char) > -1){\n            yield new Repeater(pos, char)\n            pos++\n        }else if(cp == BRACE_OPEN){\n            var reps = /\\{(\\d*)((,)(\\d*))?\\}/.exec(\n                    from_codepoint_list(pattern.slice(pos)))\n            if(reps && reps[0] != '{}'){\n                if(reps[1] == \"\"){\n                    var limits = [0]\n                }else{\n                    var limits = [parseInt(reps[1])]\n                }\n                if(reps[4] !== undefined){\n                    if(reps[4] == \"\"){\n                        var max = Number.POSITIVE_INFINITY\n                    }else{\n                        var max = parseInt(reps[4])\n                    }\n                    limits.push(max)\n                }\n                yield new Repeater(pos, limits)\n                pos += reps[0].length\n            }else if(pattern[pos + 1] == BRACE_CLOSE){\n                // {} is the characters \"{\" and \"}\"\n                yield new Char(pos, BRACE_OPEN)\n                pos++\n            }else{\n                yield new Char(pos, BRACE_OPEN)\n                pos++\n            }\n        }else if(cp == OR){\n            yield new Or(pos)\n            pos++\n        }else if(cp == DOT){\n            yield new CharacterClass(pos, cp, 1)\n            pos++\n        }else if(cp == CARET){\n            yield new StringStart(pos)\n            pos++\n        }else if(cp == DOLLAR){\n            yield new StringEnd(pos)\n            pos++\n        }else{\n            yield new Char(pos, cp)\n            pos++\n        }\n    }\n}\n\nfunction transform_repl(data, pattern){\n    // data.repl is a StringObj instance\n    var repl = data.repl.string\n    repl = repl.replace(/\\\\n/g, '\\n')\n    repl = repl.replace(/\\\\r/g, '\\r')\n    repl = repl.replace(/\\\\t/g, '\\t')\n    repl = repl.replace(/\\\\b/g, '\\b')\n    repl = repl.replace(/\\\\v/g, '\\v')\n    repl = repl.replace(/\\\\f/g, '\\f')\n    repl = repl.replace(/\\\\a/g, '\\x07')\n    // detect backreferences\n    var pos = 0,\n        escaped = false,\n        br = false,\n        repl1 = \"\",\n        has_backref = false\n    while(pos < repl.length){\n        br = false\n        if(repl[pos] == \"\\\\\"){\n            escaped = ! escaped\n            if(escaped){\n                pos++\n                continue\n            }\n        }else if(escaped){\n            escaped = false\n            var mo = /^\\d+/.exec(repl.substr(pos))\n            if(mo){\n                var cps = to_codepoint_list(repl)\n                var escape = escaped_char({\n                        codepoints: cps,\n                        pos: pos - 1,\n                        is_bytes: cps.type == \"bytes\"\n                     })\n                if(escape.type == \"o\"){\n                    if(escape.ord > 0o377){\n                        fail(`octal escape value \\\\${mo[0]} ` +\n                            \" outside of range 0-0o377\", pos)\n                    }\n                    repl1 += escape.char\n                    pos += escape.length - 1\n                    continue\n                }else if(escape.type != \"backref\"){\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    fail(`invalid group reference ${group_num}`, pos)\n                }else{\n                    // only keep first 2 digits\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    // check that pattern has the specified group num\n                    if(pattern.groups === undefined){\n                        throw _b_.AttributeError.$factory(\"$groups\")\n                    }\n                    if(pattern.groups[group_num] === undefined){\n                        fail(`invalid group reference ${group_num}`,\n                            pos)\n                    }else{\n                        mo[0] = group_num\n                    }\n                }\n                if(! has_backref){\n                    var parts = [repl.substr(0, pos - 1),\n                            parseInt(mo[0])]\n                }else{\n                    parts.push(repl.substring(next_pos, pos - 1))\n                    parts.push(parseInt(mo[0]))\n                }\n                has_backref = true\n                var next_pos = pos + mo[0].length\n                br = true\n                pos += mo[0].length\n            }else if(repl[pos] == \"g\"){\n                pos++\n                if(repl[pos] != '<'){\n                    fail(\"missing <\", pos)\n                }\n                pos++\n                mo = /(.*?)>/.exec(repl.substr(pos))\n                if(mo){\n                    if(mo[1] == \"\"){\n                        pos += mo[0].length\n                        fail(\"missing group name\", pos - 1)\n                    }\n                    var group_name = mo[1]\n                    if(group_name == '0'){\n                        //  The backreference \\g<0> substitutes in the entire\n                        // substring matched by the RE.\n                    }else if(/^\\d+$/.exec(group_name)){\n                        if(pattern.groups[group_name] === undefined){\n                            fail(`invalid group reference ${group_name}`,\n                                pos)\n                        }\n                    }else{\n                        try{\n                            var group_num = _b_.int.$factory(group_name)\n                            if(group_num < 0){\n                                fail(`bad character in group name ` +\n                                    `'${group_name}' at position ${pos}`, pos)\n                            }\n                            warn(_b_.DeprecationWarning,\n                                `bad character in group name '${group_name}' ` +\n                                `at position ${pos}`)\n                            mo[1] = group_name = group_num + ''\n                        }catch(err){\n                            if(! _b_.str.isidentifier(group_name)){\n                                var cps = to_codepoint_list(group_name)\n                                if(! $B.is_XID_Start(cps[0])){\n                                    fail(\"bad character in group name '\" +\n                                        group_name + \"'\", pos)\n                                }else{\n                                    for(cp of cps.slice(1)){\n                                        if(! $B.is_XID_Continue(cp)){\n                                            fail(\"bad character in group name '\" +\n                                                group_name + \"'\", pos)\n                                        }\n                                    }\n                                }\n                            }else if(data.type == \"bytes\" && ! is_ascii(group_name)){\n                                var b = _b_.bytes.$factory(group_name, 'latin-1'),\n                                    s = _b_.bytes.decode(b, 'ascii', 'backslashreplace')\n                                warn(_b_.DeprecationWarning,\n                                    `bad character in group name '${s}'` +\n                                    ` at position ${pos}`)\n                            }\n                        }\n                        if(pattern.groups[group_name] === undefined){\n                            throw _b_.IndexError.$factory(\n                                `unknown group name '${group_name}'`,\n                                pos)\n                        }\n                    }\n                    if(! has_backref){\n                        var parts = [repl.substr(0, pos - 3),\n                                mo[1]]\n                    }else{\n                        parts.push(repl.substring(next_pos, pos - 3))\n                        parts.push(mo[1])\n                    }\n                    has_backref = true\n                    var next_pos = pos + mo[0].length\n                    br = true\n                    pos = next_pos\n                }else{\n                    if(repl.substr(pos).length > 0){\n                        fail(\"missing >, unterminated name\", pos)\n                    }else{\n                        fail(\"missing group name\", pos)\n                    }\n                }\n            }else{\n                if(/[a-zA-Z]/.exec(repl[pos])){\n                    fail(\"unknown escape\", pos)\n                }\n                pos += repl[pos]\n            }\n        }\n        if(! br){\n            repl1 += repl[pos]\n            pos ++\n        }\n    }\n    data.repl1 = repl1\n    if(has_backref){\n        parts.push(repl.substr(next_pos))\n        data.repl = function(bmo){\n            var mo = bmo.mo,\n                res = parts[0],\n                groups = mo.$groups,\n                s = mo.string,\n                group,\n                is_bytes = s.type == 'bytes'\n            for(var i = 1, len = parts.length; i < len; i += 2){\n                if(parts[i] == 0){\n                    var x = s.substring(mo.start, mo.end)\n                    if(is_bytes){\n                        x = _b_.bytes.decode(x, 'latin-1')\n                    }\n                    res += x\n                }else if(groups[parts[i]] === undefined){\n                    if(mo.node.$groups[parts[i]] !== undefined){\n                        // group is defined in the RE, but didn't contribute\n                        // to the match\n                        // groups[parts[i]] = ''\n                    }else{\n                        // group is not defined in the RE\n                        pos++\n                        group_num = parts[i].toString().substr(0, 2)\n                        fail(`invalid group reference ${group_num}`, pos)\n                    }\n                }else{\n                    group = groups[parts[i]]\n                    var x = s.substring(group.start, group.end)\n                    if(is_bytes){\n                        x = _b_.bytes.decode(x, 'latin-1')\n                    }\n                    res += x\n                }\n                res += parts[i + 1]\n            }\n            return res\n        }\n    }else{\n        data.repl = new StringObj(repl)\n    }\n    return data\n}\nvar Flag = $B.make_class(\"Flag\",\n    function(value){\n        return {\n            __class__: Flag,\n            value\n        }\n    }\n)\n\nFlag.__and__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value & other.value)\n    }else if(typeof other == \"number\" || typeof other == \"boolean\"){\n        return Flag.$factory(self.value & other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__index__ = function(self){\n    return self.value\n}\n\nFlag.__invert__ = function(self){\n    return Flag.$factory(~self.value)\n}\n\nFlag.__eq__ = function(self, other){\n    return self.value == other.value\n}\n\nFlag.__or__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value | other.value)\n    }else if(typeof other == \"number\" || typeof other == \"boolean\"){\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__rand__ = function(self, other){\n    if(typeof other == \"number\" || $B.$isinstance(other, _b_.int)){\n        if(other == 0){\n            return false // Flag.$factory(self.value)\n        }\n        return self.value & other\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__ror__ = function(self, other){\n    if(typeof other == \"number\" || $B.$isinstance(other, _b_.int)){\n        if(other == 0){\n            return self.value\n        }\n        return self.value | other\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__repr__ = Flag.__str__ = function(self){\n    if(self.value == 0){\n        return \"re.none\"\n    }\n    var inverted = self.value < 0\n\n    var t = [],\n        value = inverted ? ~self.value : self.value\n    for(var flag in inline_flags){\n        if(value & inline_flags[flag].value){\n            t.push('re.' + flag_names[flag])\n            value &= ~inline_flags[flag].value\n        }\n    }\n    if(value > 0){\n        t.push('0x' + value.toString(16))\n    }\n    var res = t.join('|')\n    if(inverted){\n        if(t.length > 1){\n            return '~(' + res + ')'\n        }else{\n            return '~' + res\n        }\n    }\n    return res\n}\n\nFlag.__xor__ = function(self, other){\n    return Flag.$factory(self.value ^ other.value)\n}\n\n$B.set_func_names(Flag, \"re\")\n\nvar no_flag = {}\n\nvar Scanner = $B.make_class(\"Scanner\",\n    function(pattern, string, pos, endpos){\n        var $ = $B.args('__init__', 4,\n                    {pattern: null, string: null, pos: null, endpos:null},\n                    ['pattern', 'string', 'pos', 'endpos'],\n                    arguments, {pos: 0, endpos: _b_.None}, null, null),\n            endpos = endpos === _b_.None ? $.string.length : endpos\n        return {\n            __class__: Scanner,\n            $string: $.string,\n            pattern: $.pattern,\n            pos: $.pos,\n            endpos\n        }\n    }\n)\n\nScanner.match = function(self){\n    return Pattern.match(self.pattern, self.$string)\n}\n\nScanner.search = function(self){\n    if(! self.$iterator){\n        self.$iterator = module.finditer(self.pattern, self.$string)\n    }\n    // return last match\n    var mo = _b_.None\n    for(mo of self.$iterator.js_gen){\n        // set mo\n    }\n    return mo\n}\n\nvar GroupIndex = $B.make_class(\"GroupIndex\",\n    function(self, _default){\n        var res = $B.empty_dict()\n        res.__class__ = GroupIndex\n        for(var key in self.$groups){\n            if(isNaN(parseInt(key))){\n                _b_.dict.$setitem(res, key, self.$groups[key].num)\n            }\n        }\n        return res\n    }\n)\nGroupIndex.__mro__ = [_b_.dict, _b_.object]\nGroupIndex.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n$B.set_func_names(GroupIndex, \"re\")\n\nvar Pattern = $B.make_class(\"Pattern\",\n    function(pattern){\n        var nb_groups = 0\n        for(var key in pattern.groups){\n            if(isFinite(key)){\n                nb_groups++\n            }\n        }\n        return {\n            __class__: Pattern,\n            pattern: pattern.text,\n            groups: nb_groups,\n            flags: pattern.flags,\n            $groups: pattern.groups,\n            $pattern: pattern\n        }\n    }\n)\n\nPattern.__copy__ = function(self){\n    return self\n}\n\nPattern.__deepcopy__ = function(self){\n    return self\n}\n\nPattern.__eq__ = function(self, other){\n    if(other.$pattern && self.$pattern.type != other.$pattern.$type){\n        // warn(_b_.BytesWarning, \"cannot compare str and bytes pattern\", 1)\n    }\n    return self.pattern == other.pattern &&\n        self.flags.value == other.flags.value\n}\n\nPattern.__hash__ = function(self){\n    // best effort ;-)\n    return _b_.hash(self.pattern) + self.flags.value\n}\n\nPattern.__new__ = Pattern.$factory\n\nPattern.__reduce__ = function(self){\n    return Pattern.__reduce_ex__(self, 4)\n}\n\nPattern.__reduce_ex__ = function(self, protocol){\n    var res = _reconstructor,\n        state = [self.__class__].concat(self.__class__.__mro__)\n    var d = $B.empty_dict()\n    _b_.dict.$setitem(d, 'pattern', self.pattern)\n    _b_.dict.$setitem(d, 'flags', self.flags.value)\n    state.push(d)\n    return $B.fast_tuple([res, $B.fast_tuple(state)])\n}\n\nfunction _reconstructor(cls, base, state){\n    var pattern = _b_.dict.$getitem(state, 'pattern'),\n        flags = Flag.$factory(_b_.dict.$getitem(state, 'flags'))\n    return module.compile(pattern, flags)\n}\n\nPattern.__repr__ = Pattern.__str__ = function(self){\n    var text = self.$pattern.text,\n        s = text\n    if(self.$pattern.type == \"bytes\"){\n        s = _b_.str.$factory(_b_.str.encode(s, 'latin-1'))\n    }else{\n        s = _b_.repr(s)\n    }\n    s = s.substr(0, 200)\n    var res = `re.compile(${s}`,\n        flags = self.$pattern.flags\n    if(flags === no_flag){\n        return res + ')'\n    }\n    // mask UNICODE flag\n    if(flags.__class__ === Flag){\n        // copy flag, otherwise U.value would become 0\n        flags = Flag.$factory(flags.value)\n        flags.value &= ~U.value\n    }else if(typeof flags == \"number\"){\n        flags &= ~U.value\n    }\n    if(flags != 0 && flags.value != 0){\n        res += `, ${_b_.str.$factory(flags)}`\n    }\n    return res + ')'\n}\n\nPattern.findall = function(self){\n    var iter = Pattern.finditer.apply(null, arguments).js_gen,\n        res = []\n\n    while(true){\n        var next = iter.next()\n        if(next.done){\n            return res\n        }\n        var bmo = next.value,\n            mo = bmo.mo,\n            groups = MatchObject.groups(bmo)\n\n        // replace None by the empty string\n        for(var i = 0, len = groups.length; i < len; i++){\n            groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n        }\n        if(groups.length > 0){\n            if(groups.length == 1){\n                res.push(groups[0])\n            }else{\n                res.push($B.fast_tuple(groups))\n            }\n        }else{\n            res.push(mo.string.substring(mo.start, mo.end))\n        }\n    }\n}\n\nPattern.finditer = function(self){\n    var $ = $B.args(\"finditer\", 4,\n            {self: null, string: null, pos: null, endpos: null},\n            'self string pos endpos'.split(' '), arguments,\n            {pos: 0, endpos: _b_.None}, null, null)\n    var data = prepare({string: $.string})\n    var endpos = $.endpos === _b_.None ? data.string.length : $.endpos\n    return $B.generator.$factory(iterator)(self.$pattern, data.string,\n            self.flags, $.string, $.pos, endpos)\n}\n\nPattern.fullmatch = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var fullmatch_pattern = create_fullmatch_pattern($.self.$pattern)\n    var mo = match(fullmatch_pattern, data.string, $.pos, $.endpos)\n    if(mo && mo.end - mo.start == $.endpos - $.pos){\n        return MatchObject.$factory(mo)\n    }else{\n        return _b_.None\n    }\n}\n\nPattern.groupindex = {\n    __get__: function(self){\n        return GroupIndex.$factory(self)\n    }\n}\n\nPattern.match = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos,\n        $.endpos)\n    return mo ? MatchObject.$factory(mo) : _b_.None\n}\n\nPattern.scanner = function(self, string, pos, endpos){\n    return Scanner.$factory.apply(null, arguments) // self, string, pos, endpos)\n}\n\nPattern.search = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    if($.endpos === _b_.None){\n        $.endpos = data.string.length\n    }\n    var pos = $.pos\n    while(pos <= $.endpos){\n        var mo = match(self.$pattern, data.string, pos)\n        if(mo){\n            return MatchObject.$factory(mo)\n        }else{\n            pos++\n        }\n    }\n    return _b_.None\n}\n\nPattern.split = function(){\n    return module.split.apply(null, arguments)\n}\n\nPattern.sub = function(){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, repl: null, string: null, count: null},\n                    \"self repl string count\".split(' '), arguments,\n                    {count: 0}, null, null)\n    var data = prepare({string: $.string})\n    if($.self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n\n    return module.sub($.self, $.repl, $.string, $.count)\n}\n\n$B.set_func_names(Pattern, \"re\")\n\nfunction Node(parent){\n    this.parent = parent\n    this.items = []\n}\n\nNode.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nNode.prototype.fixed_length = function(){\n    // Return the sum of items lengths if fixed, else undefined\n    if(this.repeat){\n        return false\n    }\n    var len = 0\n    for(var item of this.items){\n        if(item.fixed_length === undefined){\n            console.log(\"pas de fixed length\", item)\n            alert()\n        }\n        var sublen = item.fixed_length()\n        if(sublen === false){\n            return false\n        }\n        len += sublen\n    }\n    return len\n}\n\nfunction get_top(node){\n    var top = node.parent\n    while(top.parent){\n        top = top.parent\n    }\n    return top\n}\n\nvar BackReference = function(pos, type, value){\n    // for \"\\number\"\n    this.name = \"BackReference\"\n    this.pos = pos\n    this.type = type // \"name\" or \"num\"\n    this.value = value\n    this.groups = []\n}\n\nBackReference.prototype.fixed_length = function(){\n    // Return length of referenced group if it is fixed, else undefined\n    if(this.repeat){\n        return undefined\n    }\n    var group = this.get_group()\n    if(group.fixed_length === undefined){\n        console.log(\"group\", group, \"no fixed length\")\n    }\n    return group === undefined ? false : group.fixed_length()\n}\n\nBackReference.prototype.get_group = function(){\n    var top = get_top(this)\n    return top.$groups[this.value]\n}\n\nBackReference.prototype.match = function(string, pos, endpos, groups){\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var group = groups[this.value]\n    if(group === undefined){\n        if(this.repeat.min == 0){\n            return {\n                nb_min: 0,\n                nb_max: 0\n            }\n        }\n        return false\n    }\n\n    // Get the codepoints matched by the referenced group\n    group_cps = string.codepoints.slice(group.start, group.end)\n\n    // search (repetitions of) the matched group codepoints\n    var _pos = pos,\n        nb = 0,\n        group_len = group_cps.length,\n        flag,\n        cp\n    while(string.cp_at(_pos) !== undefined && nb < this.repeat.max){\n        flag = true\n        for(var i = 0; i < group_len; i++){\n            cp = string.cp_at(_pos + i)\n            if(cp != group_cps[i]){\n                flag = false\n                break\n            }\n        }\n        if(flag){\n            nb++\n            _pos += group_len\n        }else{\n            break\n        }\n    }\n    if(nb >= this.repeat.min){\n        // Returns the accepted minimum and maximum number of repeats\n        // and the length of each repeat\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb,\n            group_len\n        }\n    }\n    return false\n}\n\nBackReference.prototype.toString = function(){\n    return \"BackRef to group\" + this.value\n}\n\nvar Case = function(){\n    this.name = \"Case\"\n    this.items = []\n    this.groups = []\n    this.text = 'Case '\n}\n\nCase.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nCase.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else{\n            len += fl\n        }\n    }\n    return len\n}\n\nCase.prototype.toString = function(){\n    var res = 'Case '\n    res += this.items.map(x => x + '').join(' ')\n    return this.text = res\n}\n\nvar Choice = function(){\n    this.type = \"choice\"\n    this.items = []\n    this.groups = []\n}\n\nChoice.prototype.add = Node.prototype.add\n\nChoice.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else if(len != fl){\n            return false\n        }\n     }\n     return len\n}\n\nChoice.prototype.toString = function(){\n    return 'Choice'\n}\n\nvar EmptyString = {\n        toString: function(){\n            return ''\n        },\n        match: function(string, pos, endpos){\n            return {nb_min: 0, nb_max: 0}\n        },\n        fixed_length: function(){\n            return 1\n        },\n        length: 0\n    },\n    Flags = function(flags){\n        this.flags = flags\n    },\n    GroupEnd = function(pos){\n        this.name = \"GroupEnd\"\n        this.pos = pos\n        this.text = ')'\n        this.toString = function(){\n            return '[end of group #' + this.group.num + ']'\n        }\n    },\n    Or = function(pos){\n        this.name = \"Or\"\n        this.pos = pos\n        this.text = '|'\n        this.toString = function(){\n            return '|'\n        }\n    },\n    Repeater = function(pos, op){\n        this.name = \"Repeater\"\n        this.pos = pos\n        this.op = op\n    }\n\nfunction cased_cps(cp, ignore_case, ascii){\n    // If cp is the codepoint of a cased Unicode character, return the list\n    // of the codepoints that match the character in a case-insensitive way\n\n    // ignore_case = this.flags && this.flags.value & IGNORECASE.value\n    // ascii = this.flags.value & ASCII.value\n    var cps,\n        char = $B.codepoint2jsstring(cp)\n    if(! ignore_case){\n        return [cp]\n    }\n    if(ascii){\n        // only test ASCII letters\n        ignore_case = ignore_case && (\n            (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z'))\n    }\n    if(ignore_case){\n        var char_up = char.toUpperCase(),\n            char_low = char.toLowerCase(),\n            cps = new Set([cp, $B.jsstring2codepoint(char_low),\n                $B.jsstring2codepoint(char_up)])\n        // special cases\n        if(char.toLowerCase() == \"k\"){\n            cps.add(0x212a) // Kelvin sign\n        }\n        if(cp == 0x212a){\n            cps.add(ord('k'))\n            cps.add(ord('K'))\n        }\n        if(char.toLowerCase() == \"s\"){\n            cps.add(0x017f) //  (Latin small letter long s)\n        }\n        if(cp == 0x017f){\n            cps.add(ord('s'))\n            cps.add(ord('S'))\n        }\n        if(char.toLowerCase() == 'i'){\n            cps.add(0x0130) //  (Latin capital letter I with dot above)\n            cps.add(0x0131) //  (Latin small letter dotless i)\n        }\n        if(cp == 0x0130 || cp == 0x0131){\n            cps.add(ord('i'))\n            cps.add(ord('I'))\n        }\n        return Array.from(cps)\n    }else{\n        cps = [cp]\n    }\n    return cps\n}\n\nvar Char = function(pos, cp, groups){\n    // character in a regular expression or in a character set\n    // pos : position of the character in the pattern string\n    // cp : the character's codepoint\n    // groups (optional) : the groups that contain the character\n    this.pos = pos\n    this.cp = cp\n    this.char = chr(this.cp)\n    this.text = this.char\n}\n\nChar.prototype.fixed_length = function(){\n    if(this.repeat){\n        return this.repeat.min\n    }\n    return this.char === EmptyString ? 0 : 1\n}\n\nChar.prototype.match = function(string, pos, endpos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    if(this.flags){\n        if(this.flags.value & ASCII.value){\n            if(this.cp > 127){\n                return false\n            }\n        }\n        if(this.flags.value & IGNORECASE.value &&\n                (! this.is_bytes || this.cp <= 127)){\n            // Flag IGNORECASE set\n            // For bytes pattern, case insensitive matching only works\n            // for ASCII characters\n            var char_upper = this.char.toUpperCase(),\n                char_lower = this.char.toLowerCase(),\n                cp\n            while(i < this.repeat.max && pos + i < endpos){\n                cp = string.cp_at(pos + i)\n                var char = chr(cp)\n                if(char.toUpperCase() != char_upper &&\n                        char.toLowerCase() != char_lower){\n                   break\n                }\n                i++\n            }\n        }else{\n            while(pos + i < endpos &&\n                    string.cp_at(pos + i) == this.cp &&\n                    i < this.repeat.max){\n                i++\n            }\n        }\n    }else{\n        while(pos + i < endpos &&\n                string.cp_at(pos + i) == this.cp &&\n                i < this.repeat.max){\n            i++\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nChar.prototype.toString = function(){\n    var res = 'Char ' + this.text\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nfunction CharSeq(chars, flags){\n    // sequence of consecutive characters\n    this.chars = chars\n    this.flags = flags\n    this.merge_same_chars()\n}\n\nCharSeq.prototype.add_char = function(char){\n    this.chars.push(char)\n    this.merge_same_chars()\n}\n\nCharSeq.prototype.fixed_length = function(){\n    var len = 0,\n        cps = [],\n        char_len\n    for(var char of this.chars){\n        if(! char.repeat){\n            char_len = 1\n        }else if(char.repeat.min == char.repeat.max){\n            char_len = char.repeat.min\n        }else{\n            len = false\n            break\n        }\n        for(var i = 0; i < char_len; i++){\n            cps.push(char.cp)\n        }\n        len += char_len\n    }\n    this.cps = cps\n    return this.len = len\n}\n\nCharSeq.prototype.match = function(string, pos, endpos){\n    var mos = [],\n        i = 0,\n        backtrack,\n        nb\n    this.len = this.len === undefined ? this.fixed_length() : this.len\n    // optimization if character sequence has a fixed length\n    if(this.len !== false && ! (this.flags.value & IGNORECASE.value)){\n        for(var i = 0; i < this.len; i++){\n            if(string.cp_at(pos + i) !== this.cps[i]){\n                return false\n            }\n        }\n        return {nb_min: this.len, nb_max: this.len}\n    }\n    for(var i = 0, len = this.chars.length; i < len; i++){\n        var char =  this.chars[i],\n            mo = char.match(string, pos, endpos) // form {nb_min, nb_max}\n        if(_debug.value){\n            console.log('CharSeq match, pos', pos, 'char', char, 'mo', mo)\n            alert()\n        }\n        if(mo){\n            nb = char.non_greedy ? mo.nb_min : mo.nb_max\n            mos.push({nb,\n                      nb_min: mo.nb_min,\n                      nb_max: mo.nb_max,\n                      non_greedy: !!char.non_greedy\n                     })\n            pos += nb\n        }else{\n            // backtrack\n            backtrack = false\n            while(mos.length > 0){\n                i--\n                mo = mos.pop()\n                pos -= mo.nb\n                nb = mo.nb\n                if(mo.non_greedy && nb < mo.nb_max){\n                    nb += 1\n                    backtrack = true\n                }else if(! mo.non_greedy && nb - 1 >= mo.nb_min){\n                    nb -= 1\n                    backtrack = true\n                }\n                if(backtrack){\n                    pos += nb\n                    mo.nb = nb\n                    mos.push(mo)\n                    break\n                }\n            }\n            if(mos.length == 0){\n                return false\n            }\n        }\n    }\n    var nb = 0,\n        last_mo = $B.last(mos)\n    for(var mo of mos.slice(0, mos.length - 1)){\n        nb += mo.nb\n    }\n    var res = {\n        nb_min: nb + last_mo.nb_min,\n        nb_max: nb + last_mo.nb_max\n    }\n    return res\n}\n\nCharSeq.prototype.merge_same_chars = function(){\n    // b?b merged into b+ etc.\n    var current,\n        chars = [],\n        merged\n    for(var item of this.chars){\n        if(current && current.char == item.char &&\n                current.non_greedy === item.non_greedy){\n            if(! current.repeat){\n                current.repeat = {min: 1, max: 1}\n            }\n            if(item.repeat){\n                current.repeat.min += item.repeat.min\n                current.repeat.max += item.repeat.max\n            }else{\n                current.repeat.min += 1\n                current.repeat.max += 1\n            }\n            merged = true\n        }else{\n            chars.push(item)\n        }\n        current = item\n    }\n    if(merged){\n        this.chars = chars\n    }\n}\n\nCharSeq.prototype.toString = function(){\n    var res = ''\n    for(var char of this.chars){\n        res += char.text\n    }\n    return 'CharSeq ' + res\n}\n\nfunction CharacterClass(pos, cp, length, groups){\n    this.cp = cp\n    this.value = chr(cp)\n    this.length = length\n    this.pos = pos\n\n    var flags = this.flags\n\n    // Test function : test(string, pos) returns:\n    // - true if \"this\" matches 1 character string[pos]\n    // - [true, 0] if \"this\" matches the empty string at pos\n    // - false or undefined if \"this\" doesn't match\n    switch(this.value){\n        case 'A':\n            this.test_func = function(string, pos){\n                if(pos == 0){\n                    return [true, 0]\n                }\n            }\n            break\n        case 's':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos)\n                return $B.in_unicode_category('Zs', cp) ||\n                    $B.unicode_bidi_whitespace.indexOf(cp) > -1\n            }\n            break\n        case 'S':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos)\n                return cp !== undefined &&\n                    ! $B.in_unicode_category('Zs', cp) &&\n                    $B.unicode_bidi_whitespace.indexOf(cp) == -1\n            }\n            break\n        case '.':\n            this.test_func = function(string, pos){\n                if(string.cp_at(pos) === undefined){\n                    return false\n                }\n                if(this.flags.value & DOTALL.value){\n                    return true\n                }else{\n                    return string.cp_at(pos) != 10\n                }\n            }\n            break\n        case 'd':\n            this.test_func = function(string, pos){\n                if(this.flags === undefined){\n                    console.log(\"\\\\d, no flags\", this)\n                }\n                var cp = string.cp_at(pos),\n                    tester = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return tester(cp)\n            }\n            break\n        case 'D':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos),\n                    tester = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return ! tester(cp)\n            }\n            break\n        case 'b':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                var cp = string.cp_at(pos),\n                    ok = {nb_min: 0, nb_max: 0}\n\n                // return true if char at pos is at the beginning or start\n                // of a word\n                if(pos == 0 && tester(cp)){\n                    return ok\n                }\n                if(string.cp_at(pos) === undefined && tester(string.cp_at(pos - 1))){\n                    return ok\n                }\n                if(pos > 0 && string.cp_at(pos) !== undefined){\n                    if((tester(string.cp_at(pos - 1))) !==\n                            tester(cp)){\n                        return ok\n                    }\n                }\n                return false\n            }\n            break\n        case 'B':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n\n                var cp = string.cp_at(pos),\n                    ok = {nb_min: 0, nb_max: 0}\n                // test is true if char at pos is not at the beginning or\n                // start of a word\n                if(pos == 0 && cp === undefined){\n                    // empty string\n                    return false\n                }\n                if(pos == 0 && tester(cp)){\n                    return false\n                }\n                if(cp === undefined &&\n                        tester(string.cp_at(pos - 1))){\n                    return false\n                }\n                if(pos > 0 && cp !== undefined){\n                    if(tester(string.cp_at(pos - 1)) !== tester(cp)){\n                        return false\n                    }\n                }\n                return ok\n            }\n            break\n        case 'w':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                return tester(string.cp_at(pos))\n            }\n            break\n        case 'W':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                return ! tester(string.cp_at(pos))\n            }\n            break\n        case 'Z':\n            this.test_func = function(string, pos){\n                if(string.cp_at(pos) === undefined){\n                    return {nb_min: 0, nb_max: 0}\n                }\n            }\n            break\n    }\n}\n\nCharacterClass.prototype.fixed_length = function(){\n    return this.repeat ? false : 1\n}\n\nCharacterClass.prototype.match = function(string, pos, endpos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    if(pos === undefined){\n        console.log('no pos')\n        throw Error()\n    }\n    var len = string.length\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    var i = 0\n    while(i < this.repeat.max && i < len){\n        var test = this.test_func(string, pos + i, this.flags)\n        if(! test){\n            break\n        }\n        i++\n    }\n\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        if('bBAZ'.indexOf(this.value) > -1 ){\n            return {nb_min: 0, nb_max: 0}\n        }\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nCharacterClass.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterClass.prototype.toString = function(){\n    return '\\\\' + this.value\n}\n\nvar CharacterSet = function(pos, set, groups){\n    // character set\n    this.pos = pos\n    this.set = set\n    this.neg = set.neg\n}\n\nCharacterSet.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterSet.prototype.match = function(string, pos, endpos){\n    var ignore_case = this.flags && (this.flags.value & IGNORECASE.value),\n        test,\n        match = false,\n        i = 0,\n        cp\n\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    while(i < this.repeat.max && (cp = string.cp_at(pos + i)) !== undefined){\n        test = false\n\n        if(string.cp_at(pos) === undefined){\n            cp = EmptyString\n        }\n        try{\n            $B.codepoint2jsstring(cp)\n        }catch(err){\n            console.log(err.message)\n            console.log('cp', cp, '\\nstring', string, 'pos', pos)\n            console.log($B.print_stack())\n            throw _b_.Exception.$factory('bad codepoint')\n        }\n        var char = $B.codepoint2jsstring(cp),\n            cps = cased_cps(cp, ignore_case, this.flags.value & ASCII.value),\n            char_is_cased = cps.length > 1\n\n        for(var cp1 of cps){\n            for(var item of this.set.items){\n                if(typeof item == 'string'){\n\n                }\n                if(Array.isArray(item.ord)){\n                    if(cp1 >= item.ord[0] &&\n                            cp1 <= item.ord[1]){\n                        test = true\n                        break\n                    }else if(ignore_case && char_is_cased){\n                        var start1 = chr(item.ord[0]).toUpperCase(),\n                            end1 = chr(item.ord[1]).toUpperCase(),\n                            char1 = char.toUpperCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                        var start1 = chr(item.ord[0]).toLowerCase(),\n                            end1 = chr(item.ord[1]).toLowerCase(),\n                            char1 = char.toLowerCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                    }\n                }else if(item instanceof CharacterClass){\n                    test = !! item.match(string, pos + i, endpos) // boolean\n                }else{\n                    if(item.ord == cp1){\n                        test = true\n                        break\n                    }\n                    item_str = typeof item == 'string' ? item : chr(item.ord)\n                    if(item_str == char){\n                        test = true\n                        break\n                    }\n                    if(ignore_case && char_is_cased &&\n                            (char.toUpperCase() == item_str.toUpperCase() ||\n                            char.toLowerCase() == item_str.toLowerCase())){\n                        test = true\n                        break\n                    }\n                }\n            }\n        }\n        if(this.neg){\n            test = ! test\n        }\n        if(test){\n            i++\n        }else{\n            break\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n\n}\n\nCharacterSet.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterSet.prototype.toString = function(){\n    return 'CharSet'\n}\n\nvar ConditionalBackref = function(pos, group_ref){\n    this.type = \"conditional backref\"\n    this.pos = pos\n    this.group_ref = group_ref\n    this.chars = []\n    this.match_codepoints = []\n    this.nb_success = 0\n    this.re_if_exists = new Group(pos)\n    this.re_if_not_exists = new Group(pos)\n    this.nb_options = 1\n}\n\nConditionalBackref.prototype.add = function(item){\n    if(this.nb_options == 1){\n        this.re_if_exists.add(item)\n    }else if(this.nb_options == 2){\n        this.re_if_not_exists.add(item)\n    }\n    item.parent = this\n}\n\nConditionalBackref.prototype.fixed_length = function(){\n    var len = this.re_if_exists.fixed_length()\n    if(len !== false && len == this.re_if_not_exists.fixed_length()){\n        return len\n    }\n    return false\n}\n\nConditionalBackref.prototype.match = function(string, pos, endpos, groups){\n    var re = groups[this.group_ref] ? this.re_if_exists :\n            this.re_if_not_exists,\n        pattern = {node: re, text: re + ''},\n        mo = match(pattern, string, pos, endpos, false, groups)\n    if(mo){\n        return {nb_min: mo.end - mo.start, nb_max: mo.end - mo.start}\n    }\n    return false\n}\n\nConditionalBackref.prototype.toString = function(){\n    return 'ConditionalBackref'\n}\n\nvar Group = function(pos, extension){\n    this.type = \"group\"\n    this.pos = pos\n    this.items = []\n    this.chars = []\n    this.groups = []\n    for(var key in extension){\n        this[key] = extension[key]\n    }\n    if(extension && extension.type){\n        if(extension.type.indexOf('lookahead') > -1){\n            this.is_lookahead = true\n        }else if(extension.type.indexOf('lookbehind') > -1){\n            this.is_lookbehind = true\n        }\n    }\n}\n\nGroup.prototype.add = Node.prototype.add\n\nGroup.prototype.toString = function(){\n    if(this.num === undefined){\n        var res = 'Group ' + this.type + ' ' + this.pattern\n    }else{\n        var res = 'Group #' + this.num + ' ' + this.pattern\n    }\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nBackReference.prototype.nb_repeats = Group.prototype.nb_repeats\n\nGroup.prototype.fixed_length = Node.prototype.fixed_length\n\nfunction groups_in(pattern, group_list){\n    if(group_list === undefined){\n        group_list = new Set()\n    }\n    if(pattern instanceof Group && pattern.hasOwnProperty('num')){\n        group_list.add(pattern.num)\n    }\n    if(pattern.items){\n        for(var subpattern of pattern.items){\n            for(var group of groups_in(subpattern, group_list)){\n                group_list.add(group)\n            }\n        }\n    }\n    return group_list\n}\n\nfunction GroupRef(group_num, item){\n    this.num = group_num\n    this.item = item\n}\n\nGroupRef.prototype.fixed_length = function(){\n    return this.item.fixed_length()\n}\n\nfunction Lookbehind(item){\n    this.re = item\n    this.neg = this.re.type == \"negative_lookbehind\"\n}\n\nLookbehind.prototype.match = function(string, pos, endpos, groups){\n    var ok = {nb_min: 0, nb_max: 0},\n        pattern = {node: this.re, text: this.re + ''},\n        length = this.re.length,\n        mo\n    if(pos - length < 0){\n        mo = false\n    }else{\n        mo = match(pattern, string, pos - length, endpos, false, groups)\n    }\n    if(mo){\n        return this.neg ? false : ok\n    }else{\n        return this.neg ? ok : false\n    }\n}\n\nLookbehind.prototype.fixed_length = function(){\n    return this.re.fixed_length()\n}\n\nLookbehind.prototype.toString = function(){\n    return \"Lookbehind\"\n}\n\nfunction SetFlags(pos, flags){\n    this.pos = pos\n    this.on_flags = flags.on_flags\n    this.off_flags = flags.off_flags\n    this.items = []\n}\n\nSetFlags.prototype.add = Node.prototype.add\n\nfunction StringStart(pos){\n    this.pos = pos\n}\n\nStringStart.prototype.match = function(string, pos, endpos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos == 0 || string.cp_at(pos - 1) == 10) ? ok : false\n    }\n    return pos == 0 ? ok : false\n}\n\nStringStart.prototype.fixed_length = function(){\n    return 0\n}\n\nStringStart.prototype.toString = function(){\n    return '^'\n}\n\nfunction StringEnd(pos){\n    this.pos = pos\n}\n\nStringEnd.prototype.match = function(string, pos, endpos){\n    var ok = {nb_min:0, nb_max: 0},\n        cp = string.cp_at(pos)\n    if(this.flags.value & MULTILINE.value){\n        return (pos > string.codepoints.length - 1 ||\n            cp == 10) ? ok : false\n    }\n    return pos > endpos - 1 ? ok :\n           (pos == endpos - 1 && cp == 10) ? ok : false\n}\n\nStringEnd.prototype.fixed_length = function(){\n    return 0\n}\n\nStringEnd.prototype.toString = function(){\n    return '$<end>'\n}\n\nvar cache = new Map()\n\nfunction compile(pattern, flags){\n    if(pattern.__class__ === Pattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\"no flags\")\n        }\n        return pattern\n    }\n    if(cache.has(pattern.py_obj)){\n        if(cache.get(pattern.py_obj).has(flags.value || 0)){\n            return cache.get(pattern.py_obj).get(flags.value || 0)\n        }\n    }\n    var original_pattern = pattern,\n        original_flags = flags,\n        type = pattern.type,\n        choices,\n        allow_global_flags = true\n    pattern = pattern.codepoints\n    var is_bytes = type !== \"str\"\n    if(is_bytes && flags && (flags.value & U.value)){\n        throw _b_.ValueError.$factory(\"cannot use UNICODE flag with \" +\n            \"a bytes pattern\")\n    }\n    if(flags && (flags.value & U.value) &&\n            (flags.value & ASCII.value)){\n        throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n            \"are incompatible\")\n    }\n    if(is_bytes){\n        // bytes patterns ignore re.ASCII flag\n        flags = Flag.$factory(flags.value || 0)\n        //flags.value &= ~ASCII.value\n    }\n    var group_num = 0,\n        group_stack = [],\n        groups = {},\n        pos,\n        lookbehind,\n        node = new Node(),\n        accept_inline_flag = true,\n        verbose = (flags.value || 0) & VERBOSE.value,\n        comment = false,\n        backrefs = {}\n    node.$groups = groups\n    for(var item of tokenize(pattern, type, verbose)){\n        item.flags = flags\n        item.is_bytes = is_bytes\n        if(lookbehind){\n            item.lookbehind = lookbehind\n            lookbehind.parent = item\n            lookbehind = false\n        }\n        if(allow_global_flags &&\n                (group_stack.length > 0 || ! (item instanceof SetFlags))){\n            allow_global_flags = false\n        }\n        if(item instanceof Group){\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            group_num++\n            item.num = group_num\n            node = item // next items will be stored as group's items\n            pos = item.pos\n            if(item.non_capturing){\n                delete item.num\n                group_num--\n            }else if(item.type == \"name_def\"){\n                var value = item.value\n                if(groups[value.string] !== undefined){\n                    fail(`redefinition of group name` +\n                        ` '${value.string}' as group ${group_num}; was group` +\n                        ` ${groups[value.string].num}`, pos)\n                }\n                item.name = value.string\n                groups[value.string] = groups[group_num] =\n                    new GroupRef(group_num, item)\n            }else if(item.is_lookahead){\n                // a lookahead assertion is relative to the previous regexp\n                group_num--\n                while(node.items.length > 0){\n                    item.add(node.items.shift())\n                }\n                node = item\n            }else if(item.is_lookbehind){\n                // a lookbehind assertion is relative to the next regexp\n                node.parent.items.pop() // remove from node items\n                // temporarily create a group\n                groups[group_num] = new GroupRef(group_num, item)\n            }else if(item.type == \"flags\"){\n                // save flags before a group with inline flags, eg \"(?i:a)\"\n                item.flags_before = Flag.$factory(flags.value | 0)\n            }else{\n                groups[group_num] = new GroupRef(group_num, item)\n            }\n        }else if(item instanceof GroupEnd){\n            end_pos = item.pos\n            if(group_stack.length == 0){\n                fail(\"unbalanced parenthesis\", end_pos, original_pattern)\n            }\n            var item = group_stack.pop()\n            item.end_pos = end_pos\n            try{\n                item.pattern = from_codepoint_list(\n                    pattern.slice(item.pos, end_pos + 1))\n            }catch(err){\n                console.log(\"err avec pattern substring\", pattern)\n                throw err\n            }\n            if(item.is_lookbehind){\n                delete groups[group_num]\n                group_num--\n                // check that all elements have a fixed length\n                item.length = item.fixed_length()\n                if(item.length === false){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                item.parent.add(new Lookbehind(item))\n                item.non_capturing = true\n                // store in variable \"lookbehind\", will be applied to next item\n                lookbehind = item\n            }else if(item.is_lookahead){\n                delete item.num\n            }\n            if(item instanceof Group && item.items.length == 0){\n                item.add(EmptyString)\n            }else if(item instanceof ConditionalBackref){\n                if(groups[item.group_ref] === undefined){\n                    // might be defined later; store in backrefs and check\n                    // when all items have been processed\n                    backrefs[item.group_ref] = backrefs[item.group_ref] | pos + 3\n                }\n                if(item.re_if_exists.items.length == 0){\n                    item.re_if_exists.add(EmptyString)\n                }else if(item.re_if_not_exists.items.length == 0){\n                    item.re_if_not_exists.pos = pos\n                    item.re_if_not_exists.add(EmptyString)\n                }\n            }else if(item.type == \"flags\"){\n                // restore flags when entering the group\n                flags = Flag.$factory(item.flags_before.value)\n            }\n            item.state = 'closed'\n            node = item.parent\n        }else if(item instanceof ConditionalBackref){\n            var pos = item.pos,\n                group_ref = item.group_ref\n            if(typeof group_ref == \"number\"){\n                if(group_ref == 0){\n                    fail(`bad group number`, pos + 3)\n                }else if(group_ref >= MAXGROUPS){\n                    fail(`invalid group reference ${group_ref}`, pos + 1)\n                }else if(groups[group_ref] &&\n                        groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else if(groups[group_ref] !== undefined){\n                if(groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else{\n                fail(`unknown group name '${group_ref}'`, pos)\n            }\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            node = item // next items will be stored as group's items\n        }else if(item instanceof BackReference){\n            pos = item.pos\n            if(item.type == \"num\" && item.value > 99){\n                var head = item.value.toString().substr(0, 2)\n                fail(`invalid group reference ${head}`, pos + 1)\n            }\n            if(groups[item.value] !== undefined){\n                if(groups[item.value].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n                var ref_item = groups[item.value].item.parent\n                while(ref_item){\n                    if(ref_item.is_lookbehind){\n                        fail(\"cannot refer to group defined in the same lookbehind subpattern\", pos)\n                    }\n                    ref_item = ref_item.parent\n                }\n            }else if(item.type == \"name\"){\n                fail(`unknown group name '${item.value}'`, pos)\n            }else if(item.type == \"num\"){\n                fail(`invalid group reference ${item.value}`, pos)\n            }\n            node.add(item)\n        }else if(item instanceof Char ||\n                item instanceof CharacterClass ||\n                item instanceof CharacterSet){\n            if(item instanceof CharacterSet){\n                for(var elt of item.set.items){\n                    elt.flags = flags\n                }\n            }\n            var added_to_charseq = false\n            if(item instanceof Char){\n                if(node.items && node.items.length > 0){\n                    var previous = $last(node.items)\n                    if(previous instanceof CharSeq){\n                        previous.add_char(item)\n                        added_to_charseq = true\n                    }else if(previous instanceof Char && ! previous.repeater){\n                        node.items.pop()\n                        node.items.push(new CharSeq([previous, item], flags))\n                        added_to_charseq = true\n                    }\n                }\n            }\n            if(! added_to_charseq){\n                node.add(item)\n            }\n        }else if(item instanceof Repeater){\n            // check that item is not in a lookbehind group\n            var pnode = node\n            while(pnode){\n                if(pnode.extension && pnode.extension.type &&\n                        pnode.extension.type.indexOf(\"lookbehind\") > -1){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                pnode = pnode.parent\n            }\n            pos = item.pos\n            if(node.items.length == 0){\n                fail(\"nothing to repeat\", pos)\n            }\n            previous = $last(node.items)\n            if(previous instanceof Char ||\n                    previous instanceof CharSeq ||\n                    previous instanceof CharacterClass ||\n                    previous instanceof CharacterSet ||\n                    previous instanceof Group ||\n                    previous instanceof BackReference){\n                if(previous instanceof GroupEnd){\n                    // associate repeat with Group\n                    previous = previous.group\n                }else if(previous instanceof CharSeq){\n                    previous = $last(previous.chars)\n                }\n                if(previous.repeater){\n                    if(item.op == '?' && ! previous.non_greedy){\n                        if(previous.possessive){\n                            fail('multiple repeat', pos)\n                        }\n                        previous.non_greedy = true\n                        if(previous instanceof CharacterClass &&\n                                previous.value == '.'){\n                            previous.min_repeat_one = true\n                        }\n                    }else{\n                        if(item instanceof Repeater && item.op == '+'){\n                            if(previous.possessive || previous.non_greedy){\n                                fail('multiple repeat', pos)\n                            }\n                            previous.possessive = true\n                        }else{\n                            fail(\"multiple repeat\", pos)\n                        }\n                    }\n                }else{\n                    // convert to minimum and maximum number of repeats\n                    var min = 1,\n                        max = 1\n                    if(Array.isArray(item.op)){\n                        min = item.op[0]\n                        if(min >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        max = item.op[1] === undefined ? min : item.op[1]\n                        if(isFinite(max) && max >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        if(max < min){\n                            fail('min repeat greater than max repeat', pos)\n                        }\n                    }else if(item.op == \"?\"){\n                        min = 0\n                        max = 1\n                    }else if(item.op == \"*\"){\n                        min = 0\n                        max = Number.POSITIVE_INFINITY\n                    }else if(item.op == \"+\"){\n                        min = 1\n                        max = Number.POSITIVE_INFINITY\n                    }\n                    previous.repeater = item\n                    previous.repeat = {min, max}\n                    // mark all parents of item as no fixed length\n                    var parent = item\n                    while(parent){\n                        parent.fixed_length = false\n                        parent = parent.parent\n                    }\n                }\n            }else{\n                fail(\"nothing to repeat\", pos)\n            }\n        }else if(item instanceof Or){\n            if(group_stack.length > 0){\n                item.group = group_stack[group_stack.length - 1]\n            }else{\n                item.group = false\n            }\n            pos = item.pos\n            if(node instanceof ConditionalBackref){\n                // case '(?(num)a|'\n                if(node.nb_options == 1){\n                    node.nb_options++\n                }else{\n                    fail('conditional backref with more than ' +\n                       'two branches', pos)\n                }\n            }else if(node.items.length == 0){\n                // token \"|\" in  \"(|...)\" : first option is the empty string\n                var choice = new Choice(),\n                    case1 = new Case()\n                case1.add(new Char(pos, EmptyString))\n                choice.add(case1)\n                node.add(choice)\n                var case2 = new Case()\n                choice.add(case2)\n                node = case2\n            }else if(node instanceof Case){\n                // node.parent is already a Choice\n                var new_case = new Case()\n                node.parent.add(new_case)\n                node = new_case\n            }else{\n                // token \"|\" in \"(ab|...)\"\n                var previous = node.items[node.items.length - 1]\n                if(previous instanceof Case){\n                    var new_case = new Case()\n                    previous.add(new_case)\n                    node = new_case\n                }else{\n                    var choice = new Choice(),\n                        case1 = new Case(),\n                        first_rank = node.items[0].rank\n                    while(node.items.length > 0){\n                        case1.add(node.items.shift())\n                    }\n                    case1.groups = node.$groups\n                    for(var group of group_stack){\n                        choice.groups.push(group)\n                    }\n                    choice.add(case1)\n                    node.add(choice)\n                    var case2 = new Case()\n                    choice.add(case2)\n                    node = case2\n                }\n            }\n        }else if(item instanceof StringStart ||\n                 item instanceof StringEnd){\n            node.add(item)\n        }else if(item instanceof SetFlags){\n            if(group_stack.length == 0 && ! allow_global_flags){\n                // pattern like (?x) only allowed as first in reg exp\n                fail('global flags not at the start of the ' +\n                        'expression', item.pos)\n            }\n            // copy flags, otherwise re.ASCII etc might be modified\n            flags = Flag.$factory(flags.value || U.value)\n            if(item.on_flags.indexOf('u') > -1){\n                if(is_bytes){\n                    fail(\"re.error: bad inline flags: cannot use 'u' flag \" +\n                        \"with a bytes pattern\", pos)\n                }\n                if(flags && flags.value & ASCII.value){\n                    // switch to Unicode\n                    flags.value ^= ASCII.value\n                }\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & ASCII.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(item.on_flags.indexOf('a') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(item.on_flags.indexOf('a') > -1){\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & U.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(flags && flags.value & U.value){\n                    // switch to ASCII\n                    flags.value ^= U.value\n                }\n                if(item.on_flags.indexOf('u') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(flags.value === undefined){\n                flags.value = 32\n            }\n            if(item.items.length == 0){\n                if(! accept_inline_flag && group_stack.length == 0){\n                    var s = from_codepoint_list(pattern)\n                    warn(_b_.DeprecationWarning,\n                        `Flags not at the start of the expression '${s}'`,\n                        pos)\n                }\n                for(var on_flag of item.on_flags){\n                    if(! is_bytes || on_flag !== 'a'){\n                        flags.value |= inline_flags[on_flag].value\n                    }\n                }\n                for(var off_flag of item.off_flags){\n                    if(! is_bytes || off_flag !== 'a'){\n                        flags.value ^= inline_flags[off_flag].value\n                    }\n                }\n            }else{\n                node.add(item)\n            }\n        }else{\n            fail(\"unknown item type \" + item, pos)\n        }\n        if(! (item instanceof SetFlags) &&\n                ! (item instanceof Group && item.type == \"flags\")){\n            accept_inline_flag = false\n        }\n    }\n    for(ref in backrefs){\n        if(groups[ref] === undefined){\n            fail('invalid group name ' + ref, backrefs[ref])\n        }\n    }\n    if(group_stack.length > 0){\n        var last = group_stack[group_stack.length - 1]\n        fail(\"missing ), unterminated subpattern\", last.pos)\n    }\n    while(node.parent){\n        node = node.parent\n    }\n    node.pattern = from_codepoint_list(pattern)\n    node.groups = group_num\n    flags = flags === no_flag ? 32 : flags\n    node.flags = flags\n    var res = {\n        node,\n        groups,\n        flags,\n        original_flags,\n        text: from_codepoint_list(pattern),\n        type, // \"str\" or \"bytes\"\n        fixed_length: node.fixed_length()\n    }\n    if(! cache.has(original_pattern.py_obj)){\n        cache.set(original_pattern.py_obj, new Map())\n    }\n    cache.get(original_pattern.py_obj).set(original_flags.value || 0, res)\n    if(_debug.value){\n        show(node)\n    }\n    return res\n}\n\nfunction show(node, indent){\n    indent = indent === undefined ? 0 : indent\n    if(indent == 0){\n        log('root', node)\n    }\n    log(' '.repeat(indent) + node)\n    if(node.items !== undefined){\n        for(var item of node.items){\n            show(item, indent + 1)\n        }\n    }\n}\n\nfunction to_codepoint_list(s){\n    var items = []\n    if(typeof s == \"string\" || $B.$isinstance(s, _b_.str)){\n        if(typeof s != \"string\"){\n            s = s.valueOf()\n        }\n        for(var char of s){\n            items.push(char.codePointAt(0))\n        }\n        items.type = \"unicode\"\n    }else if($B.$isinstance(s, [_b_.bytes, _b_.bytearray, _b_.memoryview])){\n        if($B.$isinstance(s, _b_.memoryview)){\n            items = s.obj.source\n        }else{\n            items = s.source\n        }\n        items.type = \"bytes\"\n    }else{\n        throw Error('invalid type ' + $B.class_name(s))\n    }\n    return items\n}\n\n$B.nb_from_cp = 0\nfunction from_codepoint_list(codepoints, type){\n    $B.nb_from_cp++\n    // Return a string\n    if(type == \"bytes\"){\n        return _b_.bytes.$factory(codepoints)\n    }\n    var s = ''\n    for(var cp of codepoints){\n        s += _b_.chr(cp)\n    }\n    return $B.String(s)\n}\n\nfunction string2bytes(s){\n    var t = []\n    for(var i = 0, len = s.length; i < len; i++){\n        t.push(s.charCodeAt(i))\n    }\n    return _b_.bytes.$factory(t)\n}\n\nfunction check_pattern_flags(pattern, flags){\n    if(pattern.__class__ === Pattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\n                \"cannot process flags argument with a compiled pattern\")\n        }\n    }\n    return pattern\n}\n\nfunction StringObj(obj){\n    // A StringObj object is a bridge between a Python string or bytes-like\n    // object and Javascript\n    // obj is the Python object\n    // this.string is a Javascript string\n    this.py_obj = obj\n    this.codepoints = []\n    this.type = \"str\"\n    this.is_string = typeof obj == 'string'\n    if(typeof obj == \"string\" ||\n            (obj instanceof String && ! obj.codepoints)){\n        // Python object represented as a Javascript string\n        this.string = obj\n        // Maps a position in codepoints to position in string\n        this.index_map = {}\n        for(var i = 0, len = obj.length; i < len; i++){\n            this.index_map[this.codepoints.length] = i\n            var cp = obj.codePointAt(i)\n            this.codepoints.push(cp)\n            if(cp >= 0x10000){\n                i++\n            }\n        }\n        this.length = _b_.str.__len__(obj)\n        if(obj instanceof String){\n            // store for next use\n            obj.codepoints = this.codepoints\n            obj.index_map = this.index_map\n        }\n    }else if(obj instanceof String){\n        // string with surrogate pairs\n        this.string = obj.string\n        this.codepoints = obj.codepoints\n        this.index_map = obj.index_map\n        this.length = _b_.str.__len__(obj)\n    }else if($B.$isinstance(obj, _b_.str)){ // str subclass\n        var so = new StringObj(_b_.str.$factory(obj))\n        this.string = so.string\n        this.codepoints = so.codepoints\n        this.length = _b_.str.__len__(obj)\n    }else if($B.$isinstance(obj, [_b_.bytes, _b_.bytearray])){\n        this.string = _b_.bytes.decode(obj, 'latin1')\n        this.codepoints = obj.source\n        this.type = \"bytes\"\n    }else if($B.$isinstance(obj, _b_.memoryview)){\n        this.string = _b_.bytes.decode(obj.obj, 'latin1')\n        this.codepoints = obj.obj.source\n        this.type = \"bytes\"\n    }else if(obj.__class__ && obj.__class__.$buffer_protocol){\n        // eg array.array\n        this.codepoints = _b_.list.$factory(obj)\n        this.string = from_codepoint_list(this.codepoints, \"bytes\")\n        this.type = \"bytes\"\n    }else if(Array.isArray(obj)){\n        // list of codepoints\n        this.codepoints = obj\n    }else{\n        throw _b_.TypeError.$factory(\n            `expected string or bytes-like object, got '${$B.class_name(obj)}'`)\n    }\n    if(this.length === undefined){\n        this.length = this.codepoints.length\n    }\n}\n\nStringObj.prototype.cp_at = function(pos){\n    if(pos >= this.length){\n        return undefined\n    }\n    /*\n    if(typeof this.string == 'string'){\n        return this.string.charCodeAt(pos)\n    }\n    */\n    var res = this.codepoints[pos]\n    if(res !== undefined){\n        return res\n    }\n}\n\nStringObj.prototype.substring = function(start, end){\n    // Returns a string\n    var s\n    if(this.string && this.index_map){\n        if(this.index_map[start] === undefined){\n            return ''\n        }\n        if(end === undefined){\n            return this.string.substr(this.index_map[start])\n        }\n        return this.string.substring(this.index_map[start],\n            this.index_map[end])\n    }\n    var codepoints,\n        res = ''\n    if(end === undefined){\n        codepoints = this.codepoints.slice(start)\n    }else{\n        codepoints = this.codepoints.slice(start, end)\n    }\n    return from_codepoint_list(codepoints, this.type)\n}\n\nStringObj.prototype.to_str = function(){\n    if(this.hasOwnProperty('string')){\n        return this.string\n    }\n    return from_codepoint_list(this.codepoints, this.type)\n}\n\nStringObj.from_codepoints = function(cps){\n    var res = new StringObj('')\n    res.codepoints = cps\n    for(var cp of cps){\n        res.string += _b_.chr(cp)\n    }\n    return res\n}\n\nfunction prepare(args){\n    // Check that all arguments are of the same type (string or bytes-like).\n    // Return an object with all attributes transformed into StringObj\n    // instances\n    var res = {},\n        keys = Object.keys(args),\n        first = keys[0]\n    res[first] = new StringObj(args[first])\n    res.type = res[first].type\n    for(var key of keys.slice(1)){\n        res[key] = new StringObj(args[key])\n        if(res[key].type != res.type){\n            throw _b_.TypeError.$factory(`not the same type for ${first} and ${key}`)\n        }\n    }\n    return res\n}\nfunction subn(pattern, repl, string, count, flags){\n    // string is a StringObj instance\n    // pattern is either a Pattern instance or a StringObj instance\n    var res = '',\n        pos = 0,\n        nb_sub = 0\n\n    if(pattern instanceof StringObj){\n        pattern = compile(pattern, flags)\n    }\n    if(typeof repl != \"function\"){\n        var data1 = transform_repl({repl}, pattern)\n        repl1 = data1.repl1\n    }\n    pos = 0\n    var s = string.to_str()\n    for(var bmo of module.finditer(Pattern.$factory(pattern), s).js_gen){\n        // finditer yields instances of MatchObject\n        var mo = bmo.mo // instance of MO\n        res += from_codepoint_list(string.codepoints.slice(pos, mo.start))\n        if(typeof repl == \"function\"){\n            var x = $B.$call(repl)(bmo)\n            if(x.__class__ === _b_.bytes){\n                x = _b_.bytes.decode(x, 'latin-1')\n            }\n            res += x // $B.$call(repl)(bmo)\n        }else{\n            res += repl1\n        }\n        nb_sub++\n        pos = mo.end\n        if(count != 0 && nb_sub >= count){\n            break\n        }\n    }\n    if(string.is_string){\n        res += string.string.substr(pos)\n    }else{\n        res += from_codepoint_list(string.codepoints.slice(pos))\n    }\n    if(pattern.type === \"bytes\"){\n        res = _b_.str.encode(res, \"latin-1\")\n    }\n    return [res, nb_sub]\n}\n\n// escaped chars : '\\t\\n\\x0b\\x0c\\r #$&()*+-.?[\\\\]^{|}~'\nvar escaped = [9, 10, 11, 12, 13, 32, 35, 36, 38, 40, 41, 42, 43, 45, 46, 63,\n               91, 92, 93, 94, 123, 124, 125, 126]\n\nfunction starts_with_string_start(pattern){\n    // returns true if the pattern starts with ^ or \\A\n    if(pattern.node){\n        pattern = pattern.node\n    }\n    if(pattern.items){\n        if(pattern.items.length == 0){\n            return false\n        }\n        return starts_with_string_start(pattern.items[0])\n    }else if(pattern instanceof CharacterClass){\n        return pattern.value == 'A'\n    }else if(pattern instanceof StringStart){\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction* iterator(pattern, string, flags, original_string, pos, endpos){\n    var result = [],\n        pos = pos | 0,\n        cp,\n        accept_one = true // used to test one position after string end\n    while((cp = string.cp_at(pos)) !== undefined || accept_one){\n        var mo = match(pattern, string, pos, endpos)\n        if(mo){\n            yield MatchObject.$factory(mo)\n            if(mo.end == mo.start){\n                // If match has zero with, retry at the same position but\n                // with the flag no_zero_width set, to avoid infinite loops\n                mo = match(pattern, string, pos, endpos, true)\n                if(mo){\n                    yield MatchObject.$factory(mo)\n                    pos = mo.end\n                }else{\n                    pos++ // at least 1, else infinite loop\n                }\n            }else{\n                pos = mo.end\n            }\n        }else{\n            pos++\n        }\n        if(cp === undefined){\n            accept_one = false\n        }\n        if (starts_with_string_start(pattern) && !(flags.value & MULTILINE.value)) {\n            break\n        }\n    }\n    delete original_string.in_iteration\n}\nfunction MO(node, pos, mo, len){\n    // Match Object\n    this.node = node\n    this.start = pos\n    this.mo = mo\n    this.nb_min = mo.nb_min\n    this.nb_max = mo.nb_max\n    this.len = len\n    this.nb = this.node.non_greedy ? mo.nb_min : mo.nb_max\n    this.end = pos + len * this.nb\n}\n\nMO.prototype.backtrack = function(string, groups){\n    if(this.node.possessive){\n        return false\n    }\n    if(this.node.non_greedy && this.nb < this.nb_max){\n        this.nb++\n        this.end = this.start + this.len * this.nb\n        return true\n    }else if((! this.node.non_greedy) && this.nb > this.nb_min){\n        this.nb--\n        this.end = this.start + this.len * this.nb\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction del_groups(groups, node){\n    if(node.num !== undefined){\n        delete groups[node.num]\n        groups.$last.splice(groups.$last.indexOf(node.num), 1)\n        if(node.name !== undefined){\n            delete groups[node.name]\n        }\n    }\n    for(var child of node.items){\n        if(child instanceof Group){\n            del_groups(groups, child)\n        }\n    }\n}\n\nfunction GroupMO(node, start, matches, string, groups, endpos){\n    // Match Object for Groups\n    this.node = node\n    this.start = start\n    this.matches = matches\n    this.string = string\n    this.end = matches.length > 0 ? $last(matches).end : start\n    this.endpos = endpos === undefined ? this.end : endpos\n    this.$groups = groups\n}\n\nGroupMO.prototype.backtrack = function(string, groups){\n    if(_debug.value){\n        console.log('group MO backtrack, this', this)\n        alert()\n    }\n    // Try backtracking in the last match\n    if(this.node.possessive || this.node.atomic){\n        return false\n    }\n    if(this.matches.length > 0){\n        var _match = $last(this.matches),\n            mos = _match.mos,\n            nb0 = mos.length\n        while(mos.length > 0){\n            var mo = mos.pop()\n            if(mo.node instanceof Case){\n                var rank = mo.node.parent.items.indexOf(mo.node)\n                for(var _case of mo.node.parent.items.slice(rank + 1)){\n                    var _mo = match({node: _case, text: _case.text},\n                        string, mo.start)\n                    if(_mo){\n                        // update GroupMO object\n                        mos.push(_mo)\n                        this.end = _mo.end\n                        if(this.$groups.$last.length > 0){\n                            var ix = this.$groups.$last[this.$groups.$last.length - 1]\n                            this.$groups[ix].end = _mo.end\n                        }\n                        return true\n                    }\n                }\n            }\n            if(mo.backtrack(string, groups)){\n                mos.push(mo)\n                if(this.node.num !== undefined){\n                    groups[this.node.num].end = mo.end\n                }\n                this.end = mo.end\n                return true\n            }\n        }\n    }\n    // Else, remove last match if possible\n    if(this.matches.length > this.node.repeat.min &&\n            this.matches.length >= 1){\n        this.matches.pop()\n        if(this.matches.length > 0){\n            this.end = $last(this.matches).end\n        }else{\n            // remove this group and its children from groups\n            del_groups(groups, this.node)\n            this.end = this.start\n        }\n        return true\n    }\n    // Group fails; if some of its subgroups succeded, remove them from\n    // groups\n    if(this.node.repeat.min > 0){\n        del_groups(groups, this.node)\n    }\n    return false\n}\n\nGroupMO.prototype.toString = function(){\n    var repr = _b_.repr(this.string.substring(this.start, this.end))\n    repr = repr.substring(0, 50)\n    return '<re.Match object; span=(' + this.start + ', ' + this.end +\n        '), match=' + repr + '>'\n}\n\nGroupMO.prototype.groups = function(_default){\n    var res = [],\n        groupobj = this.$groups\n\n    for(var key in this.node.$groups){\n        if(isFinite(key)){\n            res[key] = groupobj[key] === undefined ? _default :\n                this.string.substring(groupobj[key].start, groupobj[key].end)\n        }\n    }\n    res.shift()\n    return $B.fast_tuple(res)\n}\n\n// Brython MatchObject\nvar MatchObject = $B.make_class(\"Match\",\n    function(mo){\n        return {\n            __class__: MatchObject,\n            mo\n        }\n    }\n)\n\nMatchObject.__copy__ = function(self){\n    return self\n}\n\nMatchObject.__deepcopy__ = function(self){\n    return self\n}\n\nMatchObject.__getitem__ = function(){\n    var $ = $B.args(\"__getitem__\", 2, {self: null, key: null},\n                ['self', 'key'], arguments, {}, null, null),\n        self = $.self,\n        key = $.key\n    if(Array.isArray(key)){\n        throw _b_.IndexError.$factory(\"no such group\")\n    }\n    if(key == 0){\n        return self.mo.string.substring(self.mo.start, self.mo.end)\n    }\n    var match = self.mo.$groups[key]\n    if(match !== undefined){\n        return self.mo.string.substring(match.start, match.end)\n    }else if(self.mo.node.$groups[key] !== undefined){\n        return _b_.None\n    }\n    throw _b_.IndexError.$factory(\"no such group\")\n}\n\nMatchObject.__repr__ = MatchObject.__str__ =  function(self){\n    return self.mo.toString()\n}\n\nMatchObject.end = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = MatchObject.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.end\n    }else{\n        return self.mo.$groups[$.group].end\n    }\n}\n\nMatchObject.endpos = _b_.property.$factory(\n    function(self){\n        return self.mo.endpos\n    }\n)\n\nMatchObject.expand = function(){\n    var $ = $B.args(\"expand\", 2, {self: null, template: null},\n                ['self', 'template'], arguments, {}, null, null)\n    var data = {\n        repl: new StringObj($.template),\n    }\n    data = transform_repl(data, {groups: $.self.mo.node.$groups})\n    if(typeof data.repl == \"function\"){\n        return $B.$call(data.repl)(MatchObject.$factory($.self.mo))\n    }else{\n        return data.repl1\n    }\n}\n\nMatchObject.group = function(self){\n    var $ = $B.args(\"group\", 1, {self: null}, ['self'], arguments,\n                {}, 'args', null),\n            self = $.self,\n            args = $.args\n    if(args.length == 0){\n        args[0] = 0\n    }\n    var groupobj = self.mo.$groups,\n        result = []\n    for(var group_id of args){\n        if($B.rich_comp('__eq__', group_id, 0)){\n            result.push(self.mo.string.substring(self.mo.start, self.mo.end))\n            continue\n        }\n        try{\n            // Convert group_id to int if possible\n            group_id = $B.PyNumber_Index(group_id) // in py_utils.js\n        }catch(err){\n            // group_id can be an identifier\n        }\n        if(self.mo.node.$groups[group_id] === undefined){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n        var group = groupobj[group_id] // found in match\n        result.push(group === undefined ?\n            _b_.None :\n            self.mo.string.substring(group.start, group.end))\n    }\n    if(args.length == 1){\n        return result[0]\n    }\n    return $B.fast_tuple(result)\n}\n\nMatchObject.groupdict = function(){\n    /*\n    Return a dictionary containing all the named subgroups of the match, keyed\n    by the subgroup name. The default argument is used for groups that did not\n    participate in the match; it defaults to None.\n    */\n    var $ = $B.args(\"groupdict\", 2, {self: null, default: null},\n                ['self', 'default'], arguments, {default: _b_.None},\n                null, null),\n        self = $.self,\n        groupobj = $.self.mo.$groups,\n        d = $B.empty_dict()\n    for(var key in $.self.mo.node.$groups){\n        if(! isFinite(key)){\n            var value = groupobj[key] === undefined ? $.default :\n                    groupobj[key]\n            if(value !== $.default){\n                value = self.mo.string.substring(value.start, value.end)\n            }\n            _b_.dict.$setitem(d, key, value)\n        }\n    }\n    return d\n}\n\nMatchObject.groups = function(self){\n    var $ = $B.args(\"group\", 2, {self: null, default: null},\n                ['self', 'default'], arguments,\n                {default: _b_.None}, null, null),\n            self = $.self,\n            _default = $.default\n    return self.mo.groups(_default)\n}\n\nMatchObject.lastindex = _b_.property.$factory(\n   function(self){\n        /* The integer index of the last matched capturing group, or None if\n           no group was matched at all.\n        */\n        var last = self.mo.$groups.$last\n        if(last.length == 0){\n            return _b_.None\n        }\n        return parseInt($last(last))\n    }\n)\n\nMatchObject.lastgroup = _b_.property.$factory(\n    function(self){\n        /* The name of the last matched capturing group, or None if the group\n           didn't have a name, or if no group was matched at all.\n        */\n        var lastindex = MatchObject.lastindex.fget(self)\n        if(lastindex === _b_.None){\n            return _b_.None\n        }\n        var group = self.mo.node.$groups[lastindex],\n            name = group.item.name\n        return name === undefined ? _b_.None : name\n    }\n)\n\nMatchObject.pos = _b_.property.$factory(\n    function(self){\n        return self.mo.start\n    }\n)\n\nMatchObject.re = _b_.property.$factory(\n    function(self){\n        return self.mo.node.pattern\n    }\n)\n\nMatchObject.regs = _b_.property.$factory(\n    function(self){\n        var res = [$B.fast_tuple($B.fast_tuple([self.mo.start, self.mo.end]))]\n        for(var group_num in self.mo.node.$groups){\n            if(isFinite(group_num)){\n                var group = self.mo.node.$groups[group_num].item\n                // group.pattern includes the opening and closing brackets\n                res.push($B.fast_tuple([group.pos,\n                    group.pos + group.pattern.length - 2]))\n            }\n        }\n        return $B.fast_tuple(res)\n    }\n)\n\nMatchObject.span = function(){\n    /*\n    Match.span([group])\n\n    For a match m, return the 2-tuple (m.start(group), m.end(group)). Note\n    that if group did not contribute to the match, this is (-1, -1). group\n    defaults to zero, the entire match.\n    */\n    var $ = $B.args(\"span\", 2, {self: null, group: null},\n                ['self', 'group'], arguments,\n                {group: 0}, null, null),\n            self = $.self,\n            group = $.group\n    if(group == 0){\n        return $B.fast_tuple([self.mo.start, self.mo.end])\n    }\n    var span = self.mo.$groups[group]\n    if(span === undefined){\n        return $B.fast_tuple([-1, -1])\n    }\n    return $B.fast_tuple([span.start, span.end])\n}\n\nMatchObject.start = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = MatchObject.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.start\n    }else{\n        return self.mo.$groups[$.group].start\n    }\n}\n\nMatchObject.string = _b_.property.$factory(\n    function(self){\n        return self.mo.string.to_str()\n    }\n)\n\n$B.set_func_names(MatchObject, 're')\n\nfunction log(){\n    if(_debug.value){\n        console.log.apply(null, arguments)\n    }\n}\n\nfunction create_fullmatch_pattern(pattern){\n    // transform <pattern> into \"(?:<pattern>)$\"\n    // use a new pattern object, otherwise if pattern is in cache the\n    // value in cache would be changed\n    var new_pattern = {}\n    for(var key in pattern){\n        if(key == 'node'){\n            continue\n        }\n        new_pattern[key] = pattern[key]\n    }\n\n    var ncgroup = new Group() // non-capturing group\n    ncgroup.pos = 0\n    ncgroup.non_capturing = true\n    for(var item of pattern.node.items){\n        ncgroup.add(item)\n    }\n    var se = new StringEnd()\n    se.flags = Flag.$factory(32)\n    new_pattern.node = new Node()\n    new_pattern.node.add(ncgroup)\n    new_pattern.node.add(se)\n    return new_pattern\n}\n\nfunction match(pattern, string, pos, endpos, no_zero_width, groups){\n    // Follow the pattern tree structure\n    if(_debug.value){\n        console.log('match pattern', pattern.text, 'pos', pos, string.substring(pos))\n        alert()\n    }\n    if(endpos !== undefined){\n        if(endpos < pos){\n            return false\n        }\n    }else{\n        endpos = string.length\n    }\n    if(pattern.node instanceof Node){\n        show(pattern.node)\n    }\n    if(groups === undefined){\n        groups = {$last:[]}\n    }\n    if(pattern.text === undefined){\n        console.log('no text', pattern)\n    }\n    var node = pattern.node,\n        mo\n    if(node.items){\n        // node is either a Choice between several items, or a sequence of\n        // items\n        if(node instanceof Choice){\n            mo = false\n            for(var _case of node.items){\n                mo = match({node: _case, text: _case.text}, string, pos,\n                    endpos, no_zero_width, groups)\n                if(mo){\n                    // remove groups inside choice and before successful case\n                    // that did not contribute to the match\n                    var groups_succeed = groups_in(_case),\n                        min_num = Math.min(Array.from(groups_succeed))\n                    for(var group_num of groups_in(node)){\n                        if(group_num < min_num){\n                            delete groups[group_num]\n                        }\n                    }\n                    if(_debug.value){\n                        console.log('case', _case + '', 'of choice', node +\n                            ' succeeds, groups', groups)\n                    }\n                    return mo\n                }else{\n                    if(_debug.value){\n                        console.log('case', _case + '', 'of choice', node +\n                            ' fails')\n                    }\n                }\n            }\n            return false\n        }else{\n            // sequence of items\n            node.repeat = node.repeat === undefined ? {min: 1, max: 1} :\n                node.repeat\n            var start = pos,\n                nb_repeat = 0,\n                nb_zerolength_repeat = 0,\n                matches = [],\n                mos,\n                match_start,\n                empty_matches = {}\n            // loop until we get enough repetitions\n            while(true){\n                if(empty_matches[pos]){\n                    // no use trying again\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n                var initial_groups = Object.keys(groups)\n                mos = []\n                match_start = pos\n                if(_debug.value){\n                    console.log(\"pattern\", pattern.text,\n                        \"loop in group match, match start\", match_start)\n                }\n                var i = 0\n                while(i < node.items.length){\n                    var item = node.items[i]\n                    if(_debug.value){\n                        console.log('item', i, '/', node.items.length - 1,\n                            'of pattern', pattern.text)\n                    }\n                    var mo = match({node: item, text: item + ''}, string, pos,\n                        endpos, no_zero_width, groups)\n                    if(mo){\n                        if(item instanceof Group &&\n                                item.type == \"lookahead_assertion\"){\n                            log(\"lookahead assertion\", item + '',\n                                \"succeeds, mo\", mo)\n                        }else{\n                            mos.push(mo)\n                            pos = mo.end\n                        }\n                        i++\n                    }else if(false && item instanceof Group &&\n                            item.type == \"negative_lookahead_assertion\"){\n                        log(\"negative lookahead assertion\", item, \"fails : ok !\")\n                        i++\n                    }else{\n                        if(_debug.value){\n                            console.log('item ' + item, 'of group fails, nb_repeat',\n                                nb_repeat, 'node repeat', node.repeat)\n                        }\n                        var backtrack = false\n                        while(mos.length > 0){\n                            var mo = mos.pop()\n                            if(mo.backtrack === undefined){\n                                log('no backtrack for', mo)\n                            }\n                            if(_debug.value){\n                                console.log('try backtrack on mo', mo)\n                            }\n                            if(mo.backtrack(string, groups)){\n                                log('can backtrack, mo', mo)\n                                mos.push(mo)\n                                i = mos.length\n                                log('mos', mos, 'restart at item', i)\n                                pos = mo.end\n                                backtrack = true\n                                break\n                            }\n                        }\n                        if(backtrack){\n                            log('backtrack ok')\n                            continue\n                        }else{\n                            if(node.type == \"negative_lookahead_assertion\"){\n                                // If a negative lookahead assertion fails,\n                                // return a match\n                                var res = new GroupMO(node, start, matches,\n                                    string, groups, endpos)\n                                return res\n                            }\n                            if(nb_repeat == 0){\n                                // remove the groups introduced before\n                                // reaching this point\n                                for(var key in groups){\n                                    if(initial_groups.indexOf(key) == -1){\n                                        delete groups[key]\n                                    }\n                                }\n                            }\n                            if(nb_repeat >= node.repeat.min){\n                                log(\"enough repetitions for node\", node)\n                                if(node.type == \"negative_lookahead_assertion\"){\n                                    return false\n                                }\n                                return new GroupMO(node, start, matches, string,\n                                    groups, endpos)\n                            }\n                            return false\n                        }\n                    }\n                }\n                if(node.type == \"negative_lookahead_assertion\"){\n                    // If a negative lookahead succeeds, return false\n                    return false\n                }\n                nb_repeat++\n                if(pos > match_start){\n                    nb_zerolength_repeat = 0\n                }else{\n                    nb_zerolength_repeat++\n                    empty_matches[pos] = true\n                }\n                matches.push({start: match_start, end: pos, mos})\n                if(node.num !== undefined){\n                    groups[node.num] = $last(matches)\n                    if(node.name !== undefined){\n                        groups[node.name] = groups[node.num]\n                    }\n                    if(node.num != $last(groups.$last)){\n                        var ix = groups.$last.indexOf(node.num)\n                        if(ix > -1){\n                            groups.$last.splice(ix, 1)\n                        }\n                        groups.$last.push(node.num)\n                    }\n                }\n                if(nb_repeat >= node.repeat.max){\n                    var res = new GroupMO(node, start, matches, string,\n                        groups, endpos)\n                    if(res.start == res.end && no_zero_width){\n                        // no_zero_width is set when previous match in\n                        // iterator() had length 0; avoids infinite loops\n                        return false\n                    }\n                    return res\n                }\n                log('loop on group', pattern.text, 'nb repeats', nb_repeat,\n                    'nb zero length', nb_zerolength_repeat, 'groups', groups)\n                if(nb_zerolength_repeat == 65535){\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n            }\n        }\n    }else{\n        // for BackReference, Char, CharSeq, CharacterClass, CharacterSet,\n        // ConditionalBackref, Lookbehind, StringStart, StringEnd\n        var mo = node.match(string, pos, endpos, groups)\n        if(_debug.value){\n            console.log(node + '', \"mo\", mo)\n        }\n        if(mo){\n            var len = mo.group_len === undefined ? 1 : mo.group_len,\n                ix = node.non_greedy ? mo.nb_min : mo.nb_max,\n                end = pos + len * ix\n            return new MO(node, pos, mo, len)\n        }else{\n            return false\n        }\n    }\n}\n\n// expose re module API\nvar module = {\n    cache: cache,\n    compile: function(){\n        var $ = $B.args(\"compile\", 2, {pattern: null, flags: null},\n                    ['pattern', 'flags'], arguments, {flags: no_flag},\n                    null, null)\n        if($.pattern && $.pattern.__class__ === Pattern){\n            if($.flags !== no_flag){\n                throw _b_.ValueError.$factory(\n                    \"cannot process flags argument with a compiled pattern\")\n            }\n            return $.pattern\n        }\n        $.pattern = check_pattern_flags($.pattern, $.flags)\n        var data = prepare({pattern: $.pattern})\n        if(typeof $.flags == \"number\"){\n            $.flags = Flag.$factory($.flags)\n        }\n        var jspat = compile(data.pattern, $.flags)\n        return Pattern.$factory(jspat)\n    },\n    error: error,\n    escape: function(){\n        var $ = $B.args(\"escape\", 1, {pattern: null}, ['pattern'], arguments,\n                    {}, null, null),\n            data = prepare({pattern: $.pattern}),\n            pattern = data.pattern,\n            res = []\n        for(var cp of pattern.codepoints){\n            if(escaped.indexOf(cp) > -1){\n                res.push(BACKSLASH)\n            }\n            res.push(cp)\n        }\n        res = from_codepoint_list(res, data.type)\n        if(data.type == \"bytes\" && $B.$isinstance(res, _b_.str)){\n            res = _b_.str.encode(res, 'latin1')\n        }\n        return res\n    },\n    findall: function(){\n        /* Return all non-overlapping matches of pattern in string, as a list\n           of strings. The string is scanned left-to-right, and matches are\n           returned in the order found. If one or more groups are present in\n           the pattern, return a list of groups; this will be a list of tuples\n           if the pattern has more than one group. Empty matches are included\n           in the result.\n        */\n        var $ = $B.args(\"findall\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        if(data.type === \"str\"){\n            function conv(s){\n                return s === EmptyString ? '' : s\n            }\n        }else{\n            function conv(s){\n                return string2bytes(s)\n            }\n        }\n\n        var iter = module.finditer.apply(null, arguments).js_gen,\n            res = []\n        while(true){\n            var next = iter.next()\n            if(next.done){\n                return res\n            }\n            var bmo = next.value,\n                mo = bmo.mo,\n                groups = MatchObject.groups(bmo)\n\n            // replace None by the empty string\n            for(var i = 0, len = groups.length; i < len; i++){\n                groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n            }\n            if(groups.length > 0){\n                if(groups.length == 1){\n                    res.push(groups[0])\n                }else{\n                    res.push($B.fast_tuple(groups))\n                }\n            }else{\n                res.push(mo.string.substring(mo.start, mo.end))\n            }\n        }\n        console.log(\"end findall\")\n    },\n    finditer: function(){\n        var $ = $B.args(\"finditer\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        if($B.$isinstance(string, [_b_.bytearray, _b_.memoryview])){\n            string.in_iteration = true\n        }\n        var original_string = string,\n            data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            flags = pattern.flags\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        if(pattern.__class__ !== Pattern){\n            throw Error(\"pattern not a Python object\")\n        }\n        return $B.generator.$factory(iterator)(pattern.$pattern, data.string,\n            flags, original_string)\n    },\n    fullmatch: function(){\n        var $ = $B.args(\"fullmatch\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n\n        var new_pattern = create_fullmatch_pattern(pattern)\n\n        // match transformed RE\n        var res = match(new_pattern, data.string, 0)\n        var bmo = res === false ? _b_.None : MatchObject.$factory(res)\n        if(bmo !== _b_.None){\n            if(bmo.mo.string.codepoints.length != bmo.mo.end - bmo.mo.start){\n                return _b_.None\n            }else{\n                return bmo\n            }\n        }\n        return _b_.None\n    },\n    Match: MatchObject,\n    match: function(){\n        var $ = $B.args(\"match\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n        var res = match(pattern, data.string, 0)\n        return res === false ? _b_.None : MatchObject.$factory(res)\n    },\n    Pattern,\n    purge: function(){\n        var $ = $B.args(\"purge\", 0, {}, [], arguments, {}, null, null)\n        cache.clear()\n        return _b_.None\n    },\n    _reconstructor,\n    Scanner,\n    search: function(){\n        var $ = $B.args(\"search\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        data.pattern = pattern\n        // optimizations\n        if(pattern.pattern.startsWith('\\\\A') ||\n                pattern.pattern.startsWith('^')){\n            if(! (pattern.$pattern.node.items[0] instanceof Choice)){\n                var mo = match(data.pattern.$pattern, data.string, 0)\n                if(mo){\n                    return MatchObject.$factory(mo)\n                }else if(pattern.flags.value & MULTILINE.value){\n                    var pos = 0,\n                        cp\n                    while((cp = data.string.cp_at(pos)) !== undefined){\n                        if(cp == LINEFEED){\n                            mo = match(data.pattern.$pattern, data.string, pos + 1)\n                            if(mo){\n                                return MatchObject.$factory(mo)\n                            }\n                        }\n                        pos++\n                    }\n                }else{\n                    return _b_.None\n                }\n            }\n        }\n        if(pattern.$pattern.fixed_length !== false &&\n                isFinite(pattern.$pattern.fixed_length) &&\n                pattern.pattern.endsWith('$') &&\n                ! (pattern.flags.value & MULTILINE.value)){\n            var mo = match(data.pattern.$pattern, data.string,\n                data.string.length - pattern.$pattern.fixed_length)\n            if(mo){\n                return MatchObject.$factory(mo)\n            }\n            return _b_.None\n        }\n        var pos = 0\n        if(data.string.codepoints.length == 0){\n            mo = match(data.pattern.$pattern, data.string, 0)\n            if(mo){\n                mo.start = mo.end = 0\n            }\n            return mo ? MatchObject.$factory(mo) : _b_.None\n        }\n        while(pos < data.string.codepoints.length){\n            var mo = match(data.pattern.$pattern, data.string, pos)\n            if(mo){\n                return MatchObject.$factory(mo)\n            }else{\n                pos++\n            }\n        }\n        return _b_.None\n    },\n    set_debug: function(value){\n        _debug.value = value\n    },\n    split: function(){\n        var $ = $B.args(\"split\", 4,\n                    {pattern: null, string: null, maxsplit: null, flags: null},\n                    ['pattern', 'string', 'maxsplit', 'flags'],\n                    arguments, {maxsplit: 0, flags: no_flag}, null, null)\n        var res = [],\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags,\n            pos = 0,\n            nb_split = 0,\n            data\n        if(pattern.__class__ !== Pattern){\n            data = prepare({pattern, string})\n            var comp = compile(data.pattern, flags)\n            pattern = Pattern.$factory(comp)\n        }else{\n            data = {pattern, string}\n        }\n        for(var bmo of module.finditer(pattern, $.string).js_gen){\n            var mo = bmo.mo, // finditer returns instances of MatchObject\n                groupobj = mo.$groups\n            res.push(data.string.substring(pos, mo.start))\n            for(var key in mo.node.$groups){\n                if(isFinite(key)){\n                    if(groupobj[key] !== undefined){\n                        res.push(data.string.substring(groupobj[key].start,\n                            groupobj[key].end))\n                    }else{\n                        res.push(_b_.None)\n                    }\n                }\n            }\n            nb_split++\n            pos = mo.end\n            if(pos >= $.string.length){\n                break\n            }\n            if($.maxsplit != 0 && nb_split >= $.maxsplit){\n                break\n            }\n        }\n        res.push(data.string.substring(pos))\n        if(data.type === \"bytes\"){\n            res = res.map(\n                function(x){\n                    return $B.$isinstance(x, _b_.bytes) ?\n                               x :\n                               _b_.str.encode(x, \"latin-1\")\n                }\n            )\n        }\n        return res\n    },\n    sub: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        check_pattern_flags(pattern, flags)\n        if(typeof repl != \"function\"){\n            if(pattern.__class__ != Pattern){\n                data = prepare({pattern, string, repl})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string, repl})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data = transform_repl(data, pattern)\n        }else{\n            if(pattern.__class__ != Pattern){\n                data = prepare({pattern, string})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data.repl = repl\n        }\n        return subn(pattern, data.repl, data.string, count, flags)[0]\n    },\n    subn: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        if(pattern.__class__ != Pattern){\n            data = prepare({pattern, repl, string})\n        }else{\n            data = prepare({repl, string})\n            data.pattern = pattern.$pattern\n        }\n        return $B.fast_tuple(subn(data.pattern, data.repl, data.string, count,\n            flags))\n    }\n\n}\n\nvar ASCII = module.A = module.ASCII = Flag.$factory(256)\nvar IGNORECASE = module.I = module.IGNORECASE = Flag.$factory(2)\nvar LOCALE = module.L = module.LOCALE = Flag.$factory(4)\nvar MULTILINE = module.M = module.MULTILINE = Flag.$factory(8)\nvar DOTALL = module.S = module.DOTALL = Flag.$factory(16)\nvar U = module.U = module.UNICODE = Flag.$factory(32)\nvar VERBOSE = module.X = module.VERBOSE = Flag.$factory(64)\nmodule.cache = cache\nmodule._compile = module.compile\nvar inline_flags = {\n    i: IGNORECASE,\n    L: LOCALE,\n    m: MULTILINE,\n    s: DOTALL,\n    u: U,\n    x: VERBOSE,\n    a: ASCII\n}\n\nvar flag_names = {\n    i: 'IGNORECASE',\n    L: 'LOCALE',\n    m: 'MULTILINE',\n    s: 'DOTALL',\n    u: 'U',\n    x: 'VERBOSE',\n    a: 'ASCII'\n}\n\n$B.addToImported('python_re', module)\n\n})(__BRYTHON__)"], "sys": [".py", "\nfrom _sys import *\nimport _sys\n\n_getframe=_sys._getframe\n\nclass _dataclass(tuple):\n\n def __init__(self,**kwargs):\n  self.keys=list(kwargs)\n  self.__dict__.update(kwargs)\n def __getitem__(self,key):\n  if isinstance(key,int)and 0 <=key <=len(self.keys):\n   return self.__dict__[self.keys[key]]\n  raise KeyError(key)\n def __iter__(self):\n  return(self.__dict__[key]for key in self.keys)\n def __len__(self):\n  return len(self.keys)\n def __repr__(self):\n  s=', '.join(f'{k}={self.__dict__[k]!r}'for k in self.keys)\n  return f'sys.{self.__class__.__name__}({s})'\ndef make_dataclass(name,bases=None):\n bases=[_dataclass]if bases is None else[*bases,_dataclass]\n cls=type(name,bases,{})\n return cls\n__breakpointhook__=breakpointhook\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\nbrython_debug_mode=__BRYTHON__.get_option('debug')\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ncopyright=\"\"\"Copyright (c) 2001-2023 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.\"\"\"\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nargv=orig_argv=[__BRYTHON__.script_path]+list(__BRYTHON__.get_option('args'))\n\ndef displayhook(value):\n if value is not None:\n  stdout.write(repr(value))\n__displayhook__=displayhook\n\ndef exit(i=None):\n raise SystemExit('')\nflags=make_dataclass('flags')(\ndebug=0,\ninspect=0,\ninteractive=0,\noptimize=0,\ndont_write_bytecode=0,\nno_user_site=0,\nno_site=0,\nignore_environment=0,\nverbose=0,\nbytes_warning=0,\nquiet=0,\nhash_randomization=1,\nisolated=0,\ndev_mode=False,\nutf8_mode=0,\nwarn_default_encoding=0\n)\n\ndef getfilesystemencoding(*args,**kw):\n ''\n return 'utf-8'\ndef getfilesystemencodeerrors():\n return \"utf-8\"\ndef intern(string):\n return string\nint_info=make_dataclass('int_info')(\nbits_per_digit=30,\nsizeof_digit=4,\ndefault_max_str_digits=__BRYTHON__.int_max_str_digits,\nstr_digits_check_threshold=__BRYTHON__.str_digits_check_threshold)\n\ndef get_int_max_str_digits():\n return __BRYTHON__.int_max_str_digits\ndef set_int_max_str_digits(value):\n try:\n  value=int(value)\n except:\n  raise ValueError(f\"'{value.__class__.__name__}' object \"\n  \"cannot be interpreted as an integer\")\n if value !=0 and value <int_info.str_digits_check_threshold:\n  raise ValueError('maxdigits must be 0 or larger than 640')\n __BRYTHON__.int_max_str_digits=value\nmaxsize=__BRYTHON__.max_array_size\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nplatlibdir=__BRYTHON__.brython_path+'Lib'\n\nprefix=__BRYTHON__.brython_path\n\npycache_prefix=None\n\nstdlib_module_names=frozenset(__BRYTHON__.stdlib_module_names)\n\ndef unraisablehook(unraisable,/):\n pass\n__unraisablehook__=unraisablehook\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\n\nclass _comparable:\n\n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)==other\n  return NotImplemented\n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)>=other\n  return NotImplemented\n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)>other\n  return NotImplemented\n def __le__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)<=other\n  return NotImplemented\n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)<other\n  return NotImplemented\n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)!=other\n  return NotImplemented\nversion_info=make_dataclass('version_info',[_comparable])(\nmajor=__BRYTHON__.version_info[0],\nminor=__BRYTHON__.version_info[1],\nmicro=__BRYTHON__.version_info[2],\nreleaselevel=__BRYTHON__.version_info[3],\nserial=__BRYTHON__.version_info[4])\nclass SimpleNamespace:\n\n def __init__(self,/,**kwargs):\n  self.keys=list(kwargs)\n  self.__dict__.update(kwargs)\n def __getitem__(self,key):\n  if isinstance(key,int)and 0 <=key <=len(self.keys):\n   return getattr(self,self.keys[key])\n  raise KeyError(key)\n def __iter__(self):\n  return iter(self.__dict__.values())\n def __repr__(self):\n  items=(f\"{k}={v !r}\"for k,v in self.__dict__.items()\n  if k in self.keys)\n  return f\"namespace({', '.join(items)})\"\n def __eq__(self,other):\n  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\nSimpleNamespace.__module__=\"types\"\n\nhexversion=((__BRYTHON__.version_info[0]<<24)+\n(__BRYTHON__.version_info[1]<<16)+\n(__BRYTHON__.version_info[2]<<8))\n\n_implementation_info=make_dataclass('version_info',[_comparable])(\nmajor=__BRYTHON__.implementation[0],\nminor=__BRYTHON__.implementation[1],\nmicro=__BRYTHON__.implementation[2],\nreleaselevel=__BRYTHON__.implementation[3],\nserial=__BRYTHON__.implementation[4])\n\nimplementation=SimpleNamespace(\nname='Brython',\ncache_tag=None,\nversion=_implementation_info,\nhexversion=hexversion\n)\n\nhash_info=make_dataclass('hash_info')(\nwidth=32,\nmodulus=2147483647,\ninf=314159,\nnan=0,\nimag=1000003,\nalgorithm='siphash24',\nhash_bits=64,\nseed_bits=128,\ncutoff=0\n)\n\nfloat_info=make_dataclass('float_info')(\ndig=15,\nepsilon=2 **-52,\nmant_dig=53,\nmax=__BRYTHON__.MAX_VALUE,\nmax_exp=2 **10,\nmax_10_exp=308,\nmin=__BRYTHON__.MIN_VALUE,\nmin_exp=-1021,\nmin_10_exp=-307,\nradix=2,\nrounds=1\n)\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n__stdout__=stdout\n__stderr__=stderr\n__stdin__=stdin\n\n__excepthook__=excepthook\n", ["_sys"]], "os": [".py", "''\nimport abc\nimport sys\n\nerror=OSError\nname='posix'\nlinesep='\\n'\n\nfrom posix import *\nimport posixpath as path\n\nsys.modules['os.path']=path\nfrom os.path import(curdir,pardir,sep,pathsep,defpath,extsep,altsep,\ndevnull)\n\nenviron={'HOME':__BRYTHON__.curdir,\n'PYTHONPATH':__BRYTHON__.brython_path\n}\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\nclass terminal_size:\n\n def __init__(self,fileno):\n  self.columns=120\n  self.lines=30\ndef get_terminal_size(*args):\n return terminal_size(None)\ndef _get_exports_list(module):\n try:\n  return list(module.__all__)\n except AttributeError:\n  return[n for n in dir(module)if n[0]!='_']\ndef getenv(key,default=None):\n ''\n return environ.get(key,default)\nsupports_bytes_environ=True\n\ndef chdir(path):\n __BRYTHON__.curdir=path\ndef fsencode(filename):\n ''\n encoding=sys.getfilesystemencoding()\n errors='surrogateescape'\n if isinstance(filename,bytes):\n  return filename\n elif isinstance(filename,str):\n  return filename.encode(encoding,errors)\n else:\n  raise TypeError(\"expect bytes or str, not %s\"%type(filename).__name__)\ndef fsdecode(filename):\n ''\n encoding=sys.getfilesystemencoding()\n errors='surrogateescape'\n if isinstance(filename,str):\n  return filename\n elif isinstance(filename,bytes):\n  return filename.decode(encoding,errors)\n else:\n  raise TypeError(\"expect bytes or str, not %s\"%type(filename).__name__)\ndef fspath(path):\n if isinstance(path,[str,bytes]):\n  return path\n return path.__fspath__()\ndef getcwd():\n return __BRYTHON__.curdir\nclass PathLike(abc.ABC):\n\n ''\n @abc.abstractmethod\n def __fspath__(self):\n  ''\n  raise NotImplementedError\n @classmethod\n def __subclasshook__(cls,subclass):\n  return hasattr(subclass,'__fspath__')\nif name =='nt':\n class _AddedDllDirectory:\n  def __init__(self,path,cookie,remove_dll_directory):\n   self.path=path\n   self._cookie=cookie\n   self._remove_dll_directory=remove_dll_directory\n  def close(self):\n   self._remove_dll_directory(self._cookie)\n   self.path=None\n  def __enter__(self):\n   return self\n  def __exit__(self,*args):\n   self.close()\n  def __repr__(self):\n   if self.path:\n    return \"<AddedDllDirectory({!r})>\".format(self.path)\n   return \"<AddedDllDirectory()>\"\n def add_dll_directory(path):\n  ''\n  import nt\n  cookie=nt._add_dll_directory(path)\n  return _AddedDllDirectory(\n  path,\n  cookie,\n  nt._remove_dll_directory\n  )\ndef scandir(*args,**kw):\n raise NotImplementedError('browsers cannot read a directory content')\ndef waitstatus_to_exitcode(status):\n return status >>8\n_set=set()\n\nsupports_dir_fd=_set\n\nsupports_effective_ids=_set\n\nsupports_fd=_set\n\nsupports_follow_symlinks=_set\n\n", ["abc", "nt", "os.path", "posix", "posixpath", "sys"]], "pathlib": [".py", "''\nimport fnmatch\nimport functools\nimport io\nimport ntpath\nimport os\nimport posixpath\nimport re\nimport sys\nimport warnings\nfrom _collections_abc import Sequence\nfrom errno import ENOENT,ENOTDIR,EBADF,ELOOP\nfrom stat import S_ISDIR,S_ISLNK,S_ISREG,S_ISSOCK,S_ISBLK,S_ISCHR,S_ISFIFO\nfrom urllib.parse import quote_from_bytes as urlquote_from_bytes\n__all__=[\n\"PurePath\",\"PurePosixPath\",\"PureWindowsPath\",\n\"Path\",\"PosixPath\",\"WindowsPath\",\n]\n_WIN_RESERVED_NAMES=frozenset(\n{'CON','PRN','AUX','NUL','CONIN$','CONOUT$'}|\n{f'COM{c}'for c in '123456789\\xb9\\xb2\\xb3'}|\n{f'LPT{c}'for c in '123456789\\xb9\\xb2\\xb3'}\n)\n\n_WINERROR_NOT_READY=21\n_WINERROR_INVALID_NAME=123\n_WINERROR_CANT_RESOLVE_FILENAME=1921\n_IGNORED_ERRNOS=(ENOENT,ENOTDIR,EBADF,ELOOP)\n\n_IGNORED_WINERRORS=(\n_WINERROR_NOT_READY,\n_WINERROR_INVALID_NAME,\n_WINERROR_CANT_RESOLVE_FILENAME)\n\ndef _ignore_error(exception):\n return(getattr(exception,'errno',None)in _IGNORED_ERRNOS or\n getattr(exception,'winerror',None)in _IGNORED_WINERRORS)\n@functools.cache\ndef _is_case_sensitive(flavour):\n return flavour.normcase('Aa')=='Aa'\n_FNMATCH_PREFIX,_FNMATCH_SUFFIX=fnmatch.translate('_').split('_')\n_FNMATCH_SLICE=slice(len(_FNMATCH_PREFIX),-len(_FNMATCH_SUFFIX))\n_SWAP_SEP_AND_NEWLINE={\n'/':str.maketrans({'/':'\\n','\\n':'/'}),\n'\\\\':str.maketrans({'\\\\':'\\n','\\n':'\\\\'}),\n}\n@functools.lru_cache()\ndef _make_selector(pattern_parts,flavour,case_sensitive):\n pat=pattern_parts[0]\n if not pat:\n  return _TerminatingSelector()\n if pat =='**':\n  child_parts_idx=1\n  while child_parts_idx <len(pattern_parts)and pattern_parts[child_parts_idx]=='**':\n   child_parts_idx +=1\n  child_parts=pattern_parts[child_parts_idx:]\n  if '**'in child_parts:\n   cls=_DoubleRecursiveWildcardSelector\n  else:\n   cls=_RecursiveWildcardSelector\n else:\n  child_parts=pattern_parts[1:]\n  if pat =='..':\n   cls=_ParentSelector\n  elif '**'in pat:\n   raise ValueError(\"Invalid pattern: '**' can only be an entire path component\")\n  else:\n   cls=_WildcardSelector\n return cls(pat,child_parts,flavour,case_sensitive)\n@functools.lru_cache(maxsize=256)\ndef _compile_pattern(pat,case_sensitive):\n flags=re.NOFLAG if case_sensitive else re.IGNORECASE\n return re.compile(fnmatch.translate(pat),flags).match\n@functools.lru_cache()\ndef _compile_pattern_lines(pattern_lines,case_sensitive):\n ''\n parts=['^']\n for part in pattern_lines.splitlines(keepends=True):\n  if part =='*\\n':\n   part=r'.+\\n'\n  elif part =='*':\n   part=r'.+'\n  else:\n   part=fnmatch.translate(part)[_FNMATCH_SLICE]\n  parts.append(part)\n parts.append(r'\\Z')\n flags=re.MULTILINE\n if not case_sensitive:\n  flags |=re.IGNORECASE\n return re.compile(''.join(parts),flags=flags)\nclass _Selector:\n ''\n def __init__(self,child_parts,flavour,case_sensitive):\n  self.child_parts=child_parts\n  if child_parts:\n   self.successor=_make_selector(child_parts,flavour,case_sensitive)\n   self.dironly=True\n  else:\n   self.successor=_TerminatingSelector()\n   self.dironly=False\n def select_from(self,parent_path):\n  ''\n  path_cls=type(parent_path)\n  scandir=path_cls._scandir\n  if not parent_path.is_dir():\n   return iter([])\n  return self._select_from(parent_path,scandir)\nclass _TerminatingSelector:\n\n def _select_from(self,parent_path,scandir):\n  yield parent_path\nclass _ParentSelector(_Selector):\n\n def __init__(self,name,child_parts,flavour,case_sensitive):\n  _Selector.__init__(self,child_parts,flavour,case_sensitive)\n def _select_from(self,parent_path,scandir):\n  path=parent_path._make_child_relpath('..')\n  for p in self.successor._select_from(path,scandir):\n   yield p\nclass _WildcardSelector(_Selector):\n\n def __init__(self,pat,child_parts,flavour,case_sensitive):\n  _Selector.__init__(self,child_parts,flavour,case_sensitive)\n  if case_sensitive is None:\n   case_sensitive=_is_case_sensitive(flavour)\n  self.match=_compile_pattern(pat,case_sensitive)\n def _select_from(self,parent_path,scandir):\n  try:\n   with scandir(parent_path)as scandir_it:\n    entries=list(scandir_it)\n  except OSError:\n   pass\n  else:\n   for entry in entries:\n    if self.dironly:\n     try:\n      if not entry.is_dir():\n       continue\n     except OSError:\n      continue\n    name=entry.name\n    if self.match(name):\n     path=parent_path._make_child_relpath(name)\n     for p in self.successor._select_from(path,scandir):\n      yield p\nclass _RecursiveWildcardSelector(_Selector):\n\n def __init__(self,pat,child_parts,flavour,case_sensitive):\n  _Selector.__init__(self,child_parts,flavour,case_sensitive)\n def _iterate_directories(self,parent_path):\n  yield parent_path\n  for dirpath,dirnames,_ in parent_path.walk():\n   for dirname in dirnames:\n    yield dirpath._make_child_relpath(dirname)\n def _select_from(self,parent_path,scandir):\n  successor_select=self.successor._select_from\n  for starting_point in self._iterate_directories(parent_path):\n   for p in successor_select(starting_point,scandir):\n    yield p\nclass _DoubleRecursiveWildcardSelector(_RecursiveWildcardSelector):\n ''\n def _select_from(self,parent_path,scandir):\n  yielded=set()\n  try:\n   for p in super()._select_from(parent_path,scandir):\n    if p not in yielded:\n     yield p\n     yielded.add(p)\n  finally:\n   yielded.clear()\nclass _PathParents(Sequence):\n ''\n __slots__=('_path','_drv','_root','_tail')\n def __init__(self,path):\n  self._path=path\n  self._drv=path.drive\n  self._root=path.root\n  self._tail=path._tail\n def __len__(self):\n  return len(self._tail)\n def __getitem__(self,idx):\n  if isinstance(idx,slice):\n   return tuple(self[i]for i in range(*idx.indices(len(self))))\n  if idx >=len(self)or idx <-len(self):\n   raise IndexError(idx)\n  if idx <0:\n   idx +=len(self)\n  return self._path._from_parsed_parts(self._drv,self._root,\n  self._tail[:-idx -1])\n def __repr__(self):\n  return \"<{}.parents>\".format(type(self._path).__name__)\nclass PurePath(object):\n ''\n __slots__=(\n '_raw_paths',\n '_drv','_root','_tail_cached',\n '_str',\n '_str_normcase_cached',\n '_parts_normcase_cached',\n '_lines_cached',\n '_hash',\n )\n _flavour=os.path\n def __new__(cls,*args,**kwargs):\n  ''\n  if cls is PurePath:\n   cls=PureWindowsPath if os.name =='nt'else PurePosixPath\n  return object.__new__(cls)\n def __reduce__(self):\n  return(self.__class__,self.parts)\n def __init__(self,*args):\n  paths=[]\n  for arg in args:\n   if isinstance(arg,PurePath):\n    if arg._flavour is ntpath and self._flavour is posixpath:\n     paths.extend(path.replace('\\\\','/')for path in arg._raw_paths)\n    else:\n     paths.extend(arg._raw_paths)\n   else:\n    try:\n     path=os.fspath(arg)\n    except TypeError:\n     path=arg\n    if not isinstance(path,str):\n     raise TypeError(\n     \"argument should be a str or an os.PathLike \"\n     \"object where __fspath__ returns a str, \"\n     f\"not {type(path).__name__ !r}\")\n    paths.append(path)\n  self._raw_paths=paths\n def with_segments(self,*pathsegments):\n  ''\n  return type(self)(*pathsegments)\n @classmethod\n def _parse_path(cls,path):\n  if not path:\n   return '','',[]\n  sep=cls._flavour.sep\n  altsep=cls._flavour.altsep\n  if altsep:\n   path=path.replace(altsep,sep)\n  drv,root,rel=cls._flavour.splitroot(path)\n  if not root and drv.startswith(sep)and not drv.endswith(sep):\n   drv_parts=drv.split(sep)\n   if len(drv_parts)==4 and drv_parts[2]not in '?.':\n    root=sep\n   elif len(drv_parts)==6:\n    root=sep\n  parsed=[sys.intern(str(x))for x in rel.split(sep)if x and x !='.']\n  return drv,root,parsed\n def _load_parts(self):\n  paths=self._raw_paths\n  if len(paths)==0:\n   path=''\n  elif len(paths)==1:\n   path=paths[0]\n  else:\n   path=self._flavour.join(*paths)\n  drv,root,tail=self._parse_path(path)\n  self._drv=drv\n  self._root=root\n  self._tail_cached=tail\n def _from_parsed_parts(self,drv,root,tail):\n  path_str=self._format_parsed_parts(drv,root,tail)\n  path=self.with_segments(path_str)\n  path._str=path_str or '.'\n  path._drv=drv\n  path._root=root\n  path._tail_cached=tail\n  return path\n @classmethod\n def _format_parsed_parts(cls,drv,root,tail):\n  if drv or root:\n   return drv+root+cls._flavour.sep.join(tail)\n  elif tail and cls._flavour.splitdrive(tail[0])[0]:\n   tail=['.']+tail\n  return cls._flavour.sep.join(tail)\n def __str__(self):\n  ''\n  try:\n   return self._str\n  except AttributeError:\n   self._str=self._format_parsed_parts(self.drive,self.root,\n   self._tail)or '.'\n   return self._str\n def __fspath__(self):\n  return str(self)\n def as_posix(self):\n  ''\n  f=self._flavour\n  return str(self).replace(f.sep,'/')\n def __bytes__(self):\n  ''\n  return os.fsencode(self)\n def __repr__(self):\n  return \"{}({!r})\".format(self.__class__.__name__,self.as_posix())\n def as_uri(self):\n  ''\n  if not self.is_absolute():\n   raise ValueError(\"relative path can't be expressed as a file URI\")\n  drive=self.drive\n  if len(drive)==2 and drive[1]==':':\n   prefix='file:///'+drive\n   path=self.as_posix()[2:]\n  elif drive:\n   prefix='file:'\n   path=self.as_posix()\n  else:\n   prefix='file://'\n   path=str(self)\n  return prefix+urlquote_from_bytes(os.fsencode(path))\n @property\n def _str_normcase(self):\n  try:\n   return self._str_normcase_cached\n  except AttributeError:\n   if _is_case_sensitive(self._flavour):\n    self._str_normcase_cached=str(self)\n   else:\n    self._str_normcase_cached=str(self).lower()\n   return self._str_normcase_cached\n @property\n def _parts_normcase(self):\n  try:\n   return self._parts_normcase_cached\n  except AttributeError:\n   self._parts_normcase_cached=self._str_normcase.split(self._flavour.sep)\n   return self._parts_normcase_cached\n @property\n def _lines(self):\n  try:\n   return self._lines_cached\n  except AttributeError:\n   path_str=str(self)\n   if path_str =='.':\n    self._lines_cached=''\n   else:\n    trans=_SWAP_SEP_AND_NEWLINE[self._flavour.sep]\n    self._lines_cached=path_str.translate(trans)\n   return self._lines_cached\n def __eq__(self,other):\n  if not isinstance(other,PurePath):\n   return NotImplemented\n  return self._str_normcase ==other._str_normcase and self._flavour is other._flavour\n def __hash__(self):\n  try:\n   return self._hash\n  except AttributeError:\n   self._hash=hash(self._str_normcase)\n   return self._hash\n def __lt__(self,other):\n  if not isinstance(other,PurePath)or self._flavour is not other._flavour:\n   return NotImplemented\n  return self._parts_normcase <other._parts_normcase\n def __le__(self,other):\n  if not isinstance(other,PurePath)or self._flavour is not other._flavour:\n   return NotImplemented\n  return self._parts_normcase <=other._parts_normcase\n def __gt__(self,other):\n  if not isinstance(other,PurePath)or self._flavour is not other._flavour:\n   return NotImplemented\n  return self._parts_normcase >other._parts_normcase\n def __ge__(self,other):\n  if not isinstance(other,PurePath)or self._flavour is not other._flavour:\n   return NotImplemented\n  return self._parts_normcase >=other._parts_normcase\n @property\n def drive(self):\n  ''\n  try:\n   return self._drv\n  except AttributeError:\n   self._load_parts()\n   return self._drv\n @property\n def root(self):\n  ''\n  try:\n   return self._root\n  except AttributeError:\n   self._load_parts()\n   return self._root\n @property\n def _tail(self):\n  try:\n   return self._tail_cached\n  except AttributeError:\n   self._load_parts()\n   return self._tail_cached\n @property\n def anchor(self):\n  ''\n  anchor=self.drive+self.root\n  return anchor\n @property\n def name(self):\n  ''\n  tail=self._tail\n  if not tail:\n   return ''\n  return tail[-1]\n @property\n def suffix(self):\n  ''\n  name=self.name\n  i=name.rfind('.')\n  if 0 <i <len(name)-1:\n   return name[i:]\n  else:\n   return ''\n @property\n def suffixes(self):\n  ''\n  name=self.name\n  if name.endswith('.'):\n   return[]\n  name=name.lstrip('.')\n  return['.'+suffix for suffix in name.split('.')[1:]]\n @property\n def stem(self):\n  ''\n  name=self.name\n  i=name.rfind('.')\n  if 0 <i <len(name)-1:\n   return name[:i]\n  else:\n   return name\n def with_name(self,name):\n  ''\n  if not self.name:\n   raise ValueError(\"%r has an empty name\"%(self,))\n  f=self._flavour\n  drv,root,tail=f.splitroot(name)\n  if drv or root or not tail or f.sep in tail or(f.altsep and f.altsep in tail):\n   raise ValueError(\"Invalid name %r\"%(name))\n  return self._from_parsed_parts(self.drive,self.root,\n  self._tail[:-1]+[name])\n def with_stem(self,stem):\n  ''\n  return self.with_name(stem+self.suffix)\n def with_suffix(self,suffix):\n  ''\n  f=self._flavour\n  if f.sep in suffix or f.altsep and f.altsep in suffix:\n   raise ValueError(\"Invalid suffix %r\"%(suffix,))\n  if suffix and not suffix.startswith('.')or suffix =='.':\n   raise ValueError(\"Invalid suffix %r\"%(suffix))\n  name=self.name\n  if not name:\n   raise ValueError(\"%r has an empty name\"%(self,))\n  old_suffix=self.suffix\n  if not old_suffix:\n   name=name+suffix\n  else:\n   name=name[:-len(old_suffix)]+suffix\n  return self._from_parsed_parts(self.drive,self.root,\n  self._tail[:-1]+[name])\n def relative_to(self,other,/,*_deprecated,walk_up=False):\n  ''\n  if _deprecated:\n   msg=(\"support for supplying more than one positional argument \"\n   \"to pathlib.PurePath.relative_to() is deprecated and \"\n   \"scheduled for removal in Python {remove}\")\n   warnings._deprecated(\"pathlib.PurePath.relative_to(*args)\",msg,\n   remove=(3,14))\n  other=self.with_segments(other,*_deprecated)\n  for step,path in enumerate([other]+list(other.parents)):\n   if self.is_relative_to(path):\n    break\n   elif not walk_up:\n    raise ValueError(f\"{str(self)!r} is not in the subpath of {str(other)!r}\")\n   elif path.name =='..':\n    raise ValueError(f\"'..' segment in {str(other)!r} cannot be walked\")\n  else:\n   raise ValueError(f\"{str(self)!r} and {str(other)!r} have different anchors\")\n  parts=['..']*step+self._tail[len(path._tail):]\n  return self.with_segments(*parts)\n def is_relative_to(self,other,/,*_deprecated):\n  ''\n  if _deprecated:\n   msg=(\"support for supplying more than one argument to \"\n   \"pathlib.PurePath.is_relative_to() is deprecated and \"\n   \"scheduled for removal in Python {remove}\")\n   warnings._deprecated(\"pathlib.PurePath.is_relative_to(*args)\",\n   msg,remove=(3,14))\n  other=self.with_segments(other,*_deprecated)\n  return other ==self or other in self.parents\n @property\n def parts(self):\n  ''\n  if self.drive or self.root:\n   return(self.drive+self.root,)+tuple(self._tail)\n  else:\n   return tuple(self._tail)\n def joinpath(self,*pathsegments):\n  ''\n  return self.with_segments(self,*pathsegments)\n def __truediv__(self,key):\n  try:\n   return self.joinpath(key)\n  except TypeError:\n   return NotImplemented\n def __rtruediv__(self,key):\n  try:\n   return self.with_segments(key,self)\n  except TypeError:\n   return NotImplemented\n @property\n def parent(self):\n  ''\n  drv=self.drive\n  root=self.root\n  tail=self._tail\n  if not tail:\n   return self\n  return self._from_parsed_parts(drv,root,tail[:-1])\n @property\n def parents(self):\n  ''\n  return _PathParents(self)\n def is_absolute(self):\n  ''\n  if self._flavour is ntpath:\n   return bool(self.drive and self.root)\n  elif self._flavour is posixpath:\n   for path in self._raw_paths:\n    if path.startswith('/'):\n     return True\n   return False\n  else:\n   return self._flavour.isabs(str(self))\n def is_reserved(self):\n  ''\n  if self._flavour is posixpath or not self._tail:\n   return False\n  if self.drive.startswith('\\\\\\\\'):\n   return False\n  name=self._tail[-1].partition('.')[0].partition(':')[0].rstrip(' ')\n  return name.upper()in _WIN_RESERVED_NAMES\n def match(self,path_pattern,*,case_sensitive=None):\n  ''\n  if not isinstance(path_pattern,PurePath):\n   path_pattern=self.with_segments(path_pattern)\n  if case_sensitive is None:\n   case_sensitive=_is_case_sensitive(self._flavour)\n  pattern=_compile_pattern_lines(path_pattern._lines,case_sensitive)\n  if path_pattern.drive or path_pattern.root:\n   return pattern.match(self._lines)is not None\n  elif path_pattern._tail:\n   return pattern.search(self._lines)is not None\n  else:\n   raise ValueError(\"empty pattern\")\nos.PathLike.register(PurePath)\nclass PurePosixPath(PurePath):\n ''\n _flavour=posixpath\n __slots__=()\nclass PureWindowsPath(PurePath):\n ''\n _flavour=ntpath\n __slots__=()\nclass Path(PurePath):\n ''\n __slots__=()\n def stat(self,*,follow_symlinks=True):\n  ''\n  return os.stat(self,follow_symlinks=follow_symlinks)\n def lstat(self):\n  ''\n  return self.stat(follow_symlinks=False)\n def exists(self,*,follow_symlinks=True):\n  ''\n  try:\n   self.stat(follow_symlinks=follow_symlinks)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n  return True\n def is_dir(self):\n  ''\n  try:\n   return S_ISDIR(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_file(self):\n  ''\n  try:\n   return S_ISREG(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_mount(self):\n  ''\n  return self._flavour.ismount(self)\n def is_symlink(self):\n  ''\n  try:\n   return S_ISLNK(self.lstat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_junction(self):\n  ''\n  return self._flavour.isjunction(self)\n def is_block_device(self):\n  ''\n  try:\n   return S_ISBLK(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_char_device(self):\n  ''\n  try:\n   return S_ISCHR(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_fifo(self):\n  ''\n  try:\n   return S_ISFIFO(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def is_socket(self):\n  ''\n  try:\n   return S_ISSOCK(self.stat().st_mode)\n  except OSError as e:\n   if not _ignore_error(e):\n    raise\n   return False\n  except ValueError:\n   return False\n def samefile(self,other_path):\n  ''\n  st=self.stat()\n  try:\n   other_st=other_path.stat()\n  except AttributeError:\n   other_st=self.with_segments(other_path).stat()\n  return self._flavour.samestat(st,other_st)\n def open(self,mode='r',buffering=-1,encoding=None,\n errors=None,newline=None):\n  ''\n  if \"b\"not in mode:\n   encoding=io.text_encoding(encoding)\n  return io.open(self,mode,buffering,encoding,errors,newline)\n def read_bytes(self):\n  ''\n  with self.open(mode='rb')as f:\n   return f.read()\n def read_text(self,encoding=None,errors=None):\n  ''\n  encoding=io.text_encoding(encoding)\n  with self.open(mode='r',encoding=encoding,errors=errors)as f:\n   return f.read()\n def write_bytes(self,data):\n  ''\n  view=memoryview(data)\n  with self.open(mode='wb')as f:\n   return f.write(view)\n def write_text(self,data,encoding=None,errors=None,newline=None):\n  ''\n  if not isinstance(data,str):\n   raise TypeError('data must be str, not %s'%\n   data.__class__.__name__)\n  encoding=io.text_encoding(encoding)\n  with self.open(mode='w',encoding=encoding,errors=errors,newline=newline)as f:\n   return f.write(data)\n def iterdir(self):\n  ''\n  for name in os.listdir(self):\n   yield self._make_child_relpath(name)\n def _scandir(self):\n  return os.scandir(self)\n def _make_child_relpath(self,name):\n  path_str=str(self)\n  tail=self._tail\n  if tail:\n   path_str=f'{path_str}{self._flavour.sep}{name}'\n  elif path_str !='.':\n   path_str=f'{path_str}{name}'\n  else:\n   path_str=name\n  path=self.with_segments(path_str)\n  path._str=path_str\n  path._drv=self.drive\n  path._root=self.root\n  path._tail_cached=tail+[name]\n  return path\n def glob(self,pattern,*,case_sensitive=None):\n  ''\n  sys.audit(\"pathlib.Path.glob\",self,pattern)\n  if not pattern:\n   raise ValueError(\"Unacceptable pattern: {!r}\".format(pattern))\n  drv,root,pattern_parts=self._parse_path(pattern)\n  if drv or root:\n   raise NotImplementedError(\"Non-relative patterns are unsupported\")\n  if pattern[-1]in(self._flavour.sep,self._flavour.altsep):\n   pattern_parts.append('')\n  selector=_make_selector(tuple(pattern_parts),self._flavour,case_sensitive)\n  for p in selector.select_from(self):\n   yield p\n def rglob(self,pattern,*,case_sensitive=None):\n  ''\n  sys.audit(\"pathlib.Path.rglob\",self,pattern)\n  drv,root,pattern_parts=self._parse_path(pattern)\n  if drv or root:\n   raise NotImplementedError(\"Non-relative patterns are unsupported\")\n  if pattern and pattern[-1]in(self._flavour.sep,self._flavour.altsep):\n   pattern_parts.append('')\n  selector=_make_selector((\"**\",)+tuple(pattern_parts),self._flavour,case_sensitive)\n  for p in selector.select_from(self):\n   yield p\n def walk(self,top_down=True,on_error=None,follow_symlinks=False):\n  ''\n  sys.audit(\"pathlib.Path.walk\",self,on_error,follow_symlinks)\n  paths=[self]\n  while paths:\n   path=paths.pop()\n   if isinstance(path,tuple):\n    yield path\n    continue\n   try:\n    scandir_it=path._scandir()\n   except OSError as error:\n    if on_error is not None:\n     on_error(error)\n    continue\n   with scandir_it:\n    dirnames=[]\n    filenames=[]\n    for entry in scandir_it:\n     try:\n      is_dir=entry.is_dir(follow_symlinks=follow_symlinks)\n     except OSError:\n      is_dir=False\n     if is_dir:\n      dirnames.append(entry.name)\n     else:\n      filenames.append(entry.name)\n   if top_down:\n    yield path,dirnames,filenames\n   else:\n    paths.append((path,dirnames,filenames))\n   paths +=[path._make_child_relpath(d)for d in reversed(dirnames)]\n def __init__(self,*args,**kwargs):\n  if kwargs:\n   msg=(\"support for supplying keyword arguments to pathlib.PurePath \"\n   \"is deprecated and scheduled for removal in Python {remove}\")\n   warnings._deprecated(\"pathlib.PurePath(**kwargs)\",msg,remove=(3,14))\n  super().__init__(*args)\n def __new__(cls,*args,**kwargs):\n  if cls is Path:\n   cls=WindowsPath if os.name =='nt'else PosixPath\n  return object.__new__(cls)\n def __enter__(self):\n  warnings.warn(\"pathlib.Path.__enter__() is deprecated and scheduled \"\n  \"for removal in Python 3.13; Path objects as a context \"\n  \"manager is a no-op\",\n  DeprecationWarning,stacklevel=2)\n  return self\n def __exit__(self,t,v,tb):\n  pass\n @classmethod\n def cwd(cls):\n  ''\n  return cls().absolute()\n @classmethod\n def home(cls):\n  ''\n  return cls(\"~\").expanduser()\n def absolute(self):\n  ''\n  if self.is_absolute():\n   return self\n  elif self.drive:\n   cwd=self._flavour.abspath(self.drive)\n  else:\n   cwd=os.getcwd()\n   if not self.root and not self._tail:\n    result=self.with_segments(cwd)\n    result._str=cwd\n    return result\n  return self.with_segments(cwd,self)\n def resolve(self,strict=False):\n  ''\n  def check_eloop(e):\n   winerror=getattr(e,'winerror',0)\n   if e.errno ==ELOOP or winerror ==_WINERROR_CANT_RESOLVE_FILENAME:\n    raise RuntimeError(\"Symlink loop from %r\"%e.filename)\n  try:\n   s=self._flavour.realpath(self,strict=strict)\n  except OSError as e:\n   check_eloop(e)\n   raise\n  p=self.with_segments(s)\n  if not strict:\n   try:\n    p.stat()\n   except OSError as e:\n    check_eloop(e)\n  return p\n def owner(self):\n  ''\n  try:\n   import pwd\n   return pwd.getpwuid(self.stat().st_uid).pw_name\n  except ImportError:\n   raise NotImplementedError(\"Path.owner() is unsupported on this system\")\n def group(self):\n  ''\n  try:\n   import grp\n   return grp.getgrgid(self.stat().st_gid).gr_name\n  except ImportError:\n   raise NotImplementedError(\"Path.group() is unsupported on this system\")\n def readlink(self):\n  ''\n  if not hasattr(os,\"readlink\"):\n   raise NotImplementedError(\"os.readlink() not available on this system\")\n  return self.with_segments(os.readlink(self))\n def touch(self,mode=0o666,exist_ok=True):\n  ''\n  if exist_ok:\n   try:\n    os.utime(self,None)\n   except OSError:\n    pass\n   else:\n    return\n  flags=os.O_CREAT |os.O_WRONLY\n  if not exist_ok:\n   flags |=os.O_EXCL\n  fd=os.open(self,flags,mode)\n  os.close(fd)\n def mkdir(self,mode=0o777,parents=False,exist_ok=False):\n  ''\n  try:\n   os.mkdir(self,mode)\n  except FileNotFoundError:\n   if not parents or self.parent ==self:\n    raise\n   self.parent.mkdir(parents=True,exist_ok=True)\n   self.mkdir(mode,parents=False,exist_ok=exist_ok)\n  except OSError:\n   if not exist_ok or not self.is_dir():\n    raise\n def chmod(self,mode,*,follow_symlinks=True):\n  ''\n  os.chmod(self,mode,follow_symlinks=follow_symlinks)\n def lchmod(self,mode):\n  ''\n  self.chmod(mode,follow_symlinks=False)\n def unlink(self,missing_ok=False):\n  ''\n  try:\n   os.unlink(self)\n  except FileNotFoundError:\n   if not missing_ok:\n    raise\n def rmdir(self):\n  ''\n  os.rmdir(self)\n def rename(self,target):\n  ''\n  os.rename(self,target)\n  return self.with_segments(target)\n def replace(self,target):\n  ''\n  os.replace(self,target)\n  return self.with_segments(target)\n def symlink_to(self,target,target_is_directory=False):\n  ''\n  if not hasattr(os,\"symlink\"):\n   raise NotImplementedError(\"os.symlink() not available on this system\")\n  os.symlink(target,self,target_is_directory)\n def hardlink_to(self,target):\n  ''\n  if not hasattr(os,\"link\"):\n   raise NotImplementedError(\"os.link() not available on this system\")\n  os.link(target,self)\n def expanduser(self):\n  ''\n  if(not(self.drive or self.root)and\n  self._tail and self._tail[0][:1]=='~'):\n   homedir=self._flavour.expanduser(self._tail[0])\n   if homedir[:1]==\"~\":\n    raise RuntimeError(\"Could not determine home directory.\")\n   drv,root,tail=self._parse_path(homedir)\n   return self._from_parsed_parts(drv,root,tail+self._tail[1:])\n  return self\nclass PosixPath(Path,PurePosixPath):\n ''\n __slots__=()\n if os.name =='nt':\n  def __new__(cls,*args,**kwargs):\n   raise NotImplementedError(\n   f\"cannot instantiate {cls.__name__ !r} on your system\")\nclass WindowsPath(Path,PureWindowsPath):\n ''\n __slots__=()\n if os.name !='nt':\n  def __new__(cls,*args,**kwargs):\n   raise NotImplementedError(\n   f\"cannot instantiate {cls.__name__ !r} on your system\")\n", ["_collections_abc", "errno", "fnmatch", "functools", "grp", "io", "ntpath", "os", "posixpath", "pwd", "re", "stat", "sys", "urllib.parse", "warnings"]], "abc": [".py", "\ndef abstractmethod(funcobj):\n ''\n funcobj.__isabstractmethod__=True\n return funcobj\nclass abstractclassmethod(classmethod):\n ''\n __isabstractmethod__=True\n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\nclass abstractstaticmethod(staticmethod):\n ''\n __isabstractmethod__=True\n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\nclass abstractproperty(property):\n ''\n __isabstractmethod__=True\ntry:\n from _abc import(get_cache_token,_abc_init,_abc_register,\n _abc_instancecheck,_abc_subclasscheck,_get_dump,\n _reset_registry,_reset_caches)\nexcept ImportError:\n from _py_abc import ABCMeta,get_cache_token\n ABCMeta.__module__='abc'\nelse:\n class ABCMeta(type):\n  ''\n  def __new__(mcls,name,bases,namespace,/,**kwargs):\n   cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n   _abc_init(cls)\n   return cls\n  def register(cls,subclass):\n   ''\n   return _abc_register(cls,subclass)\n  def __instancecheck__(cls,instance):\n   ''\n   return _abc_instancecheck(cls,instance)\n  def __subclasscheck__(cls,subclass):\n   ''\n   return _abc_subclasscheck(cls,subclass)\n  def _dump_registry(cls,file=None):\n   ''\n   print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n   print(f\"Inv. counter: {get_cache_token()}\",file=file)\n   (_abc_registry,_abc_cache,_abc_negative_cache,\n   _abc_negative_cache_version)=_get_dump(cls)\n   print(f\"_abc_registry: {_abc_registry !r}\",file=file)\n   print(f\"_abc_cache: {_abc_cache !r}\",file=file)\n   print(f\"_abc_negative_cache: {_abc_negative_cache !r}\",file=file)\n   print(f\"_abc_negative_cache_version: {_abc_negative_cache_version !r}\",\n   file=file)\n  def _abc_registry_clear(cls):\n   ''\n   _reset_registry(cls)\n  def _abc_caches_clear(cls):\n   ''\n   _reset_caches(cls)\ndef update_abstractmethods(cls):\n ''\n if not hasattr(cls,'__abstractmethods__'):\n  return cls\n abstracts=set()\n for scls in cls.__bases__:\n  for name in getattr(scls,'__abstractmethods__',()):\n   value=getattr(cls,name,None)\n   if getattr(value,\"__isabstractmethod__\",False):\n    abstracts.add(name)\n for name,value in cls.__dict__.items():\n  if getattr(value,\"__isabstractmethod__\",False):\n   abstracts.add(name)\n cls.__abstractmethods__=frozenset(abstracts)\n return cls\nclass ABC(metaclass=ABCMeta):\n ''\n __slots__=()\n", ["_abc", "_py_abc"]], "_py_abc": [".py", "from _weakrefset import WeakSet\ndef get_cache_token():\n ''\n return ABCMeta._abc_invalidation_counter\nclass ABCMeta(type):\n ''\n _abc_invalidation_counter=0\n def __new__(mcls,name,bases,namespace,/,**kwargs):\n  cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n  abstracts={name\n  for name,value in namespace.items()\n  if getattr(value,\"__isabstractmethod__\",False)}\n  for base in bases:\n   for name in getattr(base,\"__abstractmethods__\",set()):\n    value=getattr(cls,name,None)\n    if getattr(value,\"__isabstractmethod__\",False):\n     abstracts.add(name)\n  cls.__abstractmethods__=frozenset(abstracts)\n  cls._abc_registry=WeakSet()\n  cls._abc_cache=WeakSet()\n  cls._abc_negative_cache=WeakSet()\n  cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter\n  return cls\n def register(cls,subclass):\n  ''\n  if not isinstance(subclass,type):\n   raise TypeError(\"Can only register classes\")\n  if issubclass(subclass,cls):\n   return subclass\n  if issubclass(cls,subclass):\n   raise RuntimeError(\"Refusing to create an inheritance cycle\")\n  cls._abc_registry.add(subclass)\n  ABCMeta._abc_invalidation_counter +=1\n  return subclass\n def _dump_registry(cls,file=None):\n  ''\n  print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n  print(f\"Inv. counter: {get_cache_token()}\",file=file)\n  for name in cls.__dict__:\n   if name.startswith(\"_abc_\"):\n    value=getattr(cls,name)\n    if isinstance(value,WeakSet):\n     value=set(value)\n    print(f\"{name}: {value !r}\",file=file)\n def _abc_registry_clear(cls):\n  ''\n  cls._abc_registry.clear()\n def _abc_caches_clear(cls):\n  ''\n  cls._abc_cache.clear()\n  cls._abc_negative_cache.clear()\n def __instancecheck__(cls,instance):\n  ''\n  subclass=instance.__class__\n  if subclass in cls._abc_cache:\n   return True\n  subtype=type(instance)\n  if subtype is subclass:\n   if(cls._abc_negative_cache_version ==\n   ABCMeta._abc_invalidation_counter and\n   subclass in cls._abc_negative_cache):\n    return False\n   return cls.__subclasscheck__(subclass)\n  return any(cls.__subclasscheck__(c)for c in(subclass,subtype))\n def __subclasscheck__(cls,subclass):\n  ''\n  if not isinstance(subclass,type):\n   raise TypeError('issubclass() arg 1 must be a class')\n  if subclass in cls._abc_cache:\n   return True\n  if cls._abc_negative_cache_version <ABCMeta._abc_invalidation_counter:\n   cls._abc_negative_cache=WeakSet()\n   cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter\n  elif subclass in cls._abc_negative_cache:\n   return False\n  ok=cls.__subclasshook__(subclass)\n  if ok is not NotImplemented:\n   assert isinstance(ok,bool)\n   if ok:\n    cls._abc_cache.add(subclass)\n   else:\n    cls._abc_negative_cache.add(subclass)\n   return ok\n  if cls in getattr(subclass,'__mro__',()):\n   cls._abc_cache.add(subclass)\n   return True\n  for rcls in cls._abc_registry:\n   if issubclass(subclass,rcls):\n    cls._abc_cache.add(subclass)\n    return True\n  for scls in cls.__subclasses__():\n   if issubclass(subclass,scls):\n    cls._abc_cache.add(subclass)\n    return True\n  cls._abc_negative_cache.add(subclass)\n  return False\n", ["_weakrefset"]], "_weakrefset": [".py", "\nfrom _weakref import ref\nfrom types import GenericAlias\n\n__all__=['WeakSet']\nclass _IterationGuard:\n def __init__(self,weakcontainer):\n  self.weakcontainer=ref(weakcontainer)\n def __enter__(self):\n  w=self.weakcontainer()\n  if w is not None:\n   w._iterating.add(self)\n  return self\n def __exit__(self,e,t,b):\n  w=self.weakcontainer()\n  if w is not None:\n   s=w._iterating\n   s.remove(self)\n   if not s:\n    w._commit_removals()\nclass WeakSet:\n def __init__(self,data=None):\n  self.data=set()\n  def _remove(item,selfref=ref(self)):\n   self=selfref()\n   if self is not None:\n    if self._iterating:\n     self._pending_removals.append(item)\n    else:\n     self.data.discard(item)\n  self._remove=_remove\n  self._pending_removals=[]\n  self._iterating=set()\n  if data is not None:\n   self.update(data)\n def _commit_removals(self):\n  pop=self._pending_removals.pop\n  discard=self.data.discard\n  while True:\n   try:\n    item=pop()\n   except IndexError:\n    return\n   discard(item)\n def __iter__(self):\n  with _IterationGuard(self):\n   for itemref in self.data:\n    item=itemref()\n    if item is not None:\n     yield item\n def __len__(self):\n  return len(self.data)-len(self._pending_removals)\n def __contains__(self,item):\n  try:\n   wr=ref(item)\n  except TypeError:\n   return False\n  return wr in self.data\n def __reduce__(self):\n  return self.__class__,(list(self),),self.__getstate__()\n def add(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.add(ref(item,self._remove))\n def clear(self):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.clear()\n def copy(self):\n  return self.__class__(self)\n def pop(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True:\n   try:\n    itemref=self.data.pop()\n   except KeyError:\n    raise KeyError('pop from empty WeakSet')from None\n   item=itemref()\n   if item is not None:\n    return item\n def remove(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.remove(ref(item))\n def discard(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.discard(ref(item))\n def update(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  for element in other:\n   self.add(element)\n def __ior__(self,other):\n  self.update(other)\n  return self\n def difference(self,other):\n  newset=self.copy()\n  newset.difference_update(other)\n  return newset\n __sub__=difference\n def difference_update(self,other):\n  self.__isub__(other)\n def __isub__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else:\n   self.data.difference_update(ref(item)for item in other)\n  return self\n def intersection(self,other):\n  return self.__class__(item for item in other if item in self)\n __and__=intersection\n def intersection_update(self,other):\n  self.__iand__(other)\n def __iand__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.intersection_update(ref(item)for item in other)\n  return self\n def issubset(self,other):\n  return self.data.issubset(ref(item)for item in other)\n __le__=issubset\n def __lt__(self,other):\n  return self.data <set(map(ref,other))\n def issuperset(self,other):\n  return self.data.issuperset(ref(item)for item in other)\n __ge__=issuperset\n def __gt__(self,other):\n  return self.data >set(map(ref,other))\n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.data ==set(map(ref,other))\n def symmetric_difference(self,other):\n  newset=self.copy()\n  newset.symmetric_difference_update(other)\n  return newset\n __xor__=symmetric_difference\n def symmetric_difference_update(self,other):\n  self.__ixor__(other)\n def __ixor__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else:\n   self.data.symmetric_difference_update(ref(item,self._remove)for item in other)\n  return self\n def union(self,other):\n  return self.__class__(e for s in(self,other)for e in s)\n __or__=union\n def isdisjoint(self,other):\n  return len(self.intersection(other))==0\n def __repr__(self):\n  return repr(self.data)\n __class_getitem__=classmethod(GenericAlias)\n", ["_weakref", "types"]], "_weakref": [".py", "\n\nclass ProxyType:\n\n def __init__(self,obj):\n  object.__setattr__(self,\"obj\",obj)\n def __setattr__(self,attr,value):\n  setattr(object.__getattribute__(self,\"obj\"),attr,value)\n def __getattr__(self,attr):\n  return getattr(object.__getattribute__(self,\"obj\"),attr)\nCallableProxyType=ProxyType\nProxyTypes=[ProxyType,CallableProxyType]\n\nclass ReferenceType:\n\n def __init__(self,obj,callback):\n  self.obj=obj\n  self.callback=callback\nclass ref:\n\n def __new__(cls,*args,**kw):\n  return object.__new__(cls)\n def __init__(self,obj,callback=None):\n  self.obj=ReferenceType(obj,callback)\n  self.callback=callback\n def __call__(self):\n  return self.obj.obj\n def __hash__(self):\n  return hash(self.obj.obj)\n def __eq__(self,other):\n  return self.obj.obj ==other.obj.obj\ndef getweakrefcount(obj):\n return 1\ndef getweakrefs(obj):\n return obj\ndef _remove_dead_weakref(*args):\n pass\ndef proxy(obj,callback=None):\n return ProxyType(obj)\n", []], "types": [".py", "''\nimport sys\ndef _f():pass\nFunctionType=type(_f)\nLambdaType=type(lambda:None)\nCodeType=type(_f.__code__)\nMappingProxyType=type(type.__dict__)\nSimpleNamespace=type(sys.implementation)\n\ndef _cell_factory():\n a=1\n def f():\n  nonlocal a\n return f.__closure__[0]\nCellType=type(_cell_factory())\n\ndef _g():\n yield 1\nGeneratorType=type(_g())\n\nasync def _c():pass\n_c=_c()\nCoroutineType=type(_c)\n_c.close()\n\nasync def _ag():\n yield\n_ag=_ag()\nAsyncGeneratorType=type(_ag)\n\nclass _C:\n def _m(self):pass\nMethodType=type(_C()._m)\n\nBuiltinFunctionType=type(len)\nBuiltinMethodType=type([].append)\n\nWrapperDescriptorType=type(object.__init__)\nMethodWrapperType=type(object().__str__)\nMethodDescriptorType=type(str.join)\nClassMethodDescriptorType=type(dict.__dict__['fromkeys'])\n\nModuleType=type(sys)\n\ntry:\n raise TypeError\nexcept TypeError as exc:\n TracebackType=type(exc.__traceback__)\n FrameType=type(exc.__traceback__.tb_frame)\nGetSetDescriptorType=type(FunctionType.__code__)\nMemberDescriptorType=type(FunctionType.__globals__)\n\ndel sys,_f,_g,_C,_c,_ag,_cell_factory\ndef new_class(name,bases=(),kwds=None,exec_body=None):\n ''\n resolved_bases=resolve_bases(bases)\n meta,ns,kwds=prepare_class(name,resolved_bases,kwds)\n if exec_body is not None:\n  exec_body(ns)\n if resolved_bases is not bases:\n  ns['__orig_bases__']=bases\n return meta(name,resolved_bases,ns,**kwds)\ndef resolve_bases(bases):\n ''\n new_bases=list(bases)\n updated=False\n shift=0\n for i,base in enumerate(bases):\n  if isinstance(base,type):\n   continue\n  if not hasattr(base,\"__mro_entries__\"):\n   continue\n  new_base=base.__mro_entries__(bases)\n  updated=True\n  if not isinstance(new_base,tuple):\n   raise TypeError(\"__mro_entries__ must return a tuple\")\n  else:\n   new_bases[i+shift:i+shift+1]=new_base\n   shift +=len(new_base)-1\n if not updated:\n  return bases\n return tuple(new_bases)\ndef prepare_class(name,bases=(),kwds=None):\n ''\n if kwds is None:\n  kwds={}\n else:\n  kwds=dict(kwds)\n if 'metaclass'in kwds:\n  meta=kwds.pop('metaclass')\n else:\n  if bases:\n   meta=type(bases[0])\n  else:\n   meta=type\n if isinstance(meta,type):\n  meta=_calculate_meta(meta,bases)\n if hasattr(meta,'__prepare__'):\n  ns=meta.__prepare__(name,bases,**kwds)\n else:\n  ns={}\n return meta,ns,kwds\ndef _calculate_meta(meta,bases):\n ''\n winner=meta\n for base in bases:\n  base_meta=type(base)\n  if issubclass(winner,base_meta):\n   continue\n  if issubclass(base_meta,winner):\n   winner=base_meta\n   continue\n  raise TypeError(\"metaclass conflict: \"\n  \"the metaclass of a derived class \"\n  \"must be a (non-strict) subclass \"\n  \"of the metaclasses of all its bases\")\n return winner\ndef get_original_bases(cls,/):\n ''\n try:\n  return cls.__dict__.get(\"__orig_bases__\",cls.__bases__)\n except AttributeError:\n  raise TypeError(\n  f\"Expected an instance of type, not {type(cls).__name__ !r}\"\n  )from None\nclass DynamicClassAttribute:\n ''\n def __init__(self,fget=None,fset=None,fdel=None,doc=None):\n  self.fget=fget\n  self.fset=fset\n  self.fdel=fdel\n  self.__doc__=doc or fget.__doc__\n  self.overwrite_doc=doc is None\n  self.__isabstractmethod__=bool(getattr(fget,'__isabstractmethod__',False))\n def __get__(self,instance,ownerclass=None):\n  if instance is None:\n   if self.__isabstractmethod__:\n    return self\n   raise AttributeError()\n  elif self.fget is None:\n   raise AttributeError(\"unreadable attribute\")\n  return self.fget(instance)\n def __set__(self,instance,value):\n  if self.fset is None:\n   raise AttributeError(\"can't set attribute\")\n  self.fset(instance,value)\n def __delete__(self,instance):\n  if self.fdel is None:\n   raise AttributeError(\"can't delete attribute\")\n  self.fdel(instance)\n def getter(self,fget):\n  fdoc=fget.__doc__ if self.overwrite_doc else None\n  result=type(self)(fget,self.fset,self.fdel,fdoc or self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n def setter(self,fset):\n  result=type(self)(self.fget,fset,self.fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n def deleter(self,fdel):\n  result=type(self)(self.fget,self.fset,fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\nclass _GeneratorWrapper:\n\n def __init__(self,gen):\n  self.__wrapped=gen\n  self.__isgen=gen.__class__ is GeneratorType\n  self.__name__=getattr(gen,'__name__',None)\n  self.__qualname__=getattr(gen,'__qualname__',None)\n def send(self,val):\n  return self.__wrapped.send(val)\n def throw(self,tp,*rest):\n  return self.__wrapped.throw(tp,*rest)\n def close(self):\n  return self.__wrapped.close()\n @property\n def gi_code(self):\n  return self.__wrapped.gi_code\n @property\n def gi_frame(self):\n  return self.__wrapped.gi_frame\n @property\n def gi_running(self):\n  return self.__wrapped.gi_running\n @property\n def gi_yieldfrom(self):\n  return self.__wrapped.gi_yieldfrom\n cr_code=gi_code\n cr_frame=gi_frame\n cr_running=gi_running\n cr_await=gi_yieldfrom\n def __next__(self):\n  return next(self.__wrapped)\n def __iter__(self):\n  if self.__isgen:\n   return self.__wrapped\n  return self\n __await__=__iter__\ndef coroutine(func):\n ''\n if not callable(func):\n  raise TypeError('types.coroutine() expects a callable')\n if(func.__class__ is FunctionType and\n getattr(func,'__code__',None).__class__ is CodeType):\n  co_flags=func.__code__.co_flags\n  if co_flags&0x180:\n   return func\n  if co_flags&0x20:\n   co=func.__code__\n   func.__code__=co.replace(co_flags=co.co_flags |0x100)\n   return func\n import functools\n import _collections_abc\n @functools.wraps(func)\n def wrapped(*args,**kwargs):\n  coro=func(*args,**kwargs)\n  if(coro.__class__ is CoroutineType or\n  coro.__class__ is GeneratorType and coro.gi_code.co_flags&0x100):\n   return coro\n  if(isinstance(coro,_collections_abc.Generator)and\n  not isinstance(coro,_collections_abc.Coroutine)):\n   return _GeneratorWrapper(coro)\n  return coro\n return wrapped\nGenericAlias=type(list[int])\nUnionType=type(int |str)\n\nEllipsisType=type(Ellipsis)\nNoneType=type(None)\nNotImplementedType=type(NotImplemented)\n\n__all__=[n for n in globals()if n[:1]!='_']\n", ["_collections_abc", "functools", "sys"]], "posix": [".js", "/*\nThis module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.\n*/\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nfunction _randint(a, b){\n    return parseInt(Math.random() * (b - a + 1) + a)\n}\n\nvar stat_result = $B.make_class(\"stat_result\",\n    function(filename){\n        filename = _b_.str.$factory(filename)\n        if($B.file_cache && $B.file_cache.hasOwnProperty(filename)){\n            var f = $B.file_cache[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: __BRYTHON__.timestamp,\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: f.length\n                };\n                [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                    forEach(function(item){\n                        res[\"st_\" + item] = res.st_atime\n                    });\n            return res\n        }else if($B.files && $B.files.hasOwnProperty(filename)){\n            var f = $B.files[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: __BRYTHON__.timestamp,\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: f.content.length\n                };\n            for(var item of [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"]){\n                res[\"st_\" + item] = res.st_atime\n            }\n            return res\n\n        }else{\n            var res = {\n                __class__: stat_result,\n                st_atime: __BRYTHON__.timestamp,\n                st_uid: -1,\n                st_gid: -1,\n                st_ino: -1,\n                st_mode: filename.endsWith('/') ? 16895 : 33206,\n                st_size: 1 // fake\n            };\n            [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                forEach(function(item){\n                    res[\"st_\" + item] = res.st_atime\n                });\n            return res\n        }\n    }\n)\n$B.set_func_names(stat_result, \"posix\")\n\nvar module = {\n    F_OK: 0,\n    O_APPEND: 8,\n    O_BINARY: 32768,\n    O_CREAT: 256,\n    O_EXCL: 1024,\n    O_NOINHERIT: 128,\n    O_RANDOM: 16,\n    O_RDONLY: 0,\n    O_RDWR: 2,\n    O_SEQUENTIAL: 32,\n    O_SHORT_LIVED: 4096,\n    O_TEMPORARY: 64,\n    O_TEXT: 16384,\n    O_TRUNC: 512,\n    O_WRONLY: 1,\n    P_DETACH: 4,\n    P_NOWAIT: 1,\n    P_NOWAITO: 3,\n    P_OVERLAY: 2,\n    P_WAIT: 0,\n    R_OK: 4,\n    TMP_MAX: 32767,\n    W_OK: 2,\n    X_OK: 1,\n    _have_functions: ['MS_WINDOWS'],\n    environ: _b_.dict.$factory(\n        [['PYTHONPATH', $B.brython_path],\n         ['PYTHONUSERBASE', ' ']]),\n    error: _b_.OSError,\n    fspath: function(path){\n        return path\n    },\n    getcwd: function(){return $B.brython_path},\n    getpid: function(){return 0},\n    lstat: function(filename){\n        return stat_result.$factory(filename)\n    },\n    open: function(path, flags){return _b_.open(path, flags)},\n    remove: function(path) {\n        var $ = $B.args(\"remove\", 1, { path: null }, [\"path\"], arguments, {}, null, null)\n        console.log($)\n\n        var path = $.path\n        var found_file = false\n\n        if ($B.file_cache && $B.file_cache.hasOwnProperty(path)){\n            delete $B.file_cache[path]\n            found_file = true\n        }\n        if ($B.files && $B.files.hasOwnProperty(path)){\n            delete $B.files[path]\n            found_file = true\n        }\n\n        if(!found_file) {\n            throw _b_.FileNotFoundError.$factory(`No such file or directory: '${path}'`)\n        }\n\n        return _b_.None\n    },\n    stat: function(filename){return stat_result.$factory(filename)},\n    stat_result: function(filename){return stat_result.$factory(filename)},\n    urandom: function(n){\n        const randbytes = new Uint8Array(n);\n        crypto.getRandomValues(randbytes);\n        return _b_.bytes.$factory(Array.from(randbytes));\n    },\n    WTERMSIG: function(){return 0},\n    WNOHANG: function(){return _b_.tuple.$factory([0, 0])}\n};\n\n[\"WCOREDUMP\", \"WIFCONTINUED\", \"WIFSTOPPED\", \"WIFSIGNALED\", \"WIFEXITED\"].forEach(function(funcname){\n        module[funcname] = function(){return false}\n    });\n\n[\"WEXITSTATUS\", \"WSTOPSIG\", \"WTERMSIG\"].\n    forEach(function(funcname){\n        module[funcname] = function(){return _b_.None}\n    });\n\n[\"_exit\", \"_getdiskusage\", \"_getfileinformation\", \"_getfinalpathname\",\n    \"_getfullpathname\", \"_isdir\", \"abort\", \"access\", \"chdir\", \"chmod\",\n    \"close\", \"closerange\", \"device_encoding\", \"dup\", \"dup2\",\n    \"execv\", \"execve\", \"fsat\", \"fsync\", \"get_terminal_size\", \"getcwdb\",\n    \"getlogin\", \"getppid\", \"isatty\", \"kill\", \"link\", \"listdir\", \"lseek\",\n    \"mkdir\", \"pipe\", \"putenv\", \"read\", \"readlink\", \"rename\",\n    \"replace\", \"rmdir\", \"spawnv\", \"spawnve\", \"startfile\", \"stat_float_times\",\n    \"statvfs_result\", \"strerror\", \"symlink\", \"system\", \"terminal_size\",\n    \"times\", \"times_result\", \"umask\", \"uname_result\", \"unlink\", \"utime\",\n    \"waitpid\", \"write\"].forEach(function(funcname){\n        module[funcname] = function(){\n            throw _b_.NotImplementedError.$factory(\"posix.\" + funcname +\n                \" is not implemented\")\n        }\n    });\n\n$B.addToImported('posix', module)"], "posixpath": [".py", "''\ncurdir='.'\npardir='..'\nextsep='.'\nsep='/'\npathsep=':'\ndefpath='/bin:/usr/bin'\naltsep=None\ndevnull='/dev/null'\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__=[\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"splitroot\",\"split\",\"splitext\",\n\"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n\"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n\"ismount\",\"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n\"samefile\",\"sameopenfile\",\"samestat\",\n\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n\"commonpath\",\"isjunction\"]\ndef _get_sep(path):\n if isinstance(path,bytes):\n  return b'/'\n else:\n  return '/'\ndef normcase(s):\n ''\n return os.fspath(s)\ndef isabs(s):\n ''\n s=os.fspath(s)\n sep=_get_sep(s)\n return s.startswith(sep)\ndef join(a,*p):\n ''\n a=os.fspath(a)\n sep=_get_sep(a)\n path=a\n try:\n  if not p:\n   path[:0]+sep\n  for b in map(os.fspath,p):\n   if b.startswith(sep):\n    path=b\n   elif not path or path.endswith(sep):\n    path +=b\n   else:\n    path +=sep+b\n except(TypeError,AttributeError,BytesWarning):\n  genericpath._check_arg_types('join',a,*p)\n  raise\n return path\ndef split(p):\n ''\n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n head,tail=p[:i],p[i:]\n if head and head !=sep *len(head):\n  head=head.rstrip(sep)\n return head,tail\ndef splitext(p):\n p=os.fspath(p)\n if isinstance(p,bytes):\n  sep=b'/'\n  extsep=b'.'\n else:\n  sep='/'\n  extsep='.'\n return genericpath._splitext(p,sep,None,extsep)\nsplitext.__doc__=genericpath._splitext.__doc__\ndef splitdrive(p):\n ''\n p=os.fspath(p)\n return p[:0],p\ndef splitroot(p):\n ''\n p=os.fspath(p)\n if isinstance(p,bytes):\n  sep=b'/'\n  empty=b''\n else:\n  sep='/'\n  empty=''\n if p[:1]!=sep:\n  return empty,empty,p\n elif p[1:2]!=sep or p[2:3]==sep:\n  return empty,sep,p[1:]\n else:\n  return empty,p[:2],p[2:]\ndef basename(p):\n ''\n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n return p[i:]\ndef dirname(p):\n ''\n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n head=p[:i]\n if head and head !=sep *len(head):\n  head=head.rstrip(sep)\n return head\ndef isjunction(path):\n ''\n os.fspath(path)\n return False\ndef lexists(path):\n ''\n try:\n  os.lstat(path)\n except(OSError,ValueError):\n  return False\n return True\ndef ismount(path):\n ''\n try:\n  s1=os.lstat(path)\n except(OSError,ValueError):\n  return False\n else:\n  if stat.S_ISLNK(s1.st_mode):\n   return False\n path=os.fspath(path)\n if isinstance(path,bytes):\n  parent=join(path,b'..')\n else:\n  parent=join(path,'..')\n parent=realpath(parent)\n try:\n  s2=os.lstat(parent)\n except(OSError,ValueError):\n  return False\n dev1=s1.st_dev\n dev2=s2.st_dev\n if dev1 !=dev2:\n  return True\n ino1=s1.st_ino\n ino2=s2.st_ino\n if ino1 ==ino2:\n  return True\n return False\ndef expanduser(path):\n ''\n path=os.fspath(path)\n if isinstance(path,bytes):\n  tilde=b'~'\n else:\n  tilde='~'\n if not path.startswith(tilde):\n  return path\n sep=_get_sep(path)\n i=path.find(sep,1)\n if i <0:\n  i=len(path)\n if i ==1:\n  if 'HOME'not in os.environ:\n   try:\n    import pwd\n   except ImportError:\n    return path\n   try:\n    userhome=pwd.getpwuid(os.getuid()).pw_dir\n   except KeyError:\n    return path\n  else:\n   userhome=os.environ['HOME']\n else:\n  try:\n   import pwd\n  except ImportError:\n   return path\n  name=path[1:i]\n  if isinstance(name,bytes):\n   name=str(name,'ASCII')\n  try:\n   pwent=pwd.getpwnam(name)\n  except KeyError:\n   return path\n  userhome=pwent.pw_dir\n if userhome is None and sys.platform ==\"vxworks\":\n  return path\n if isinstance(path,bytes):\n  userhome=os.fsencode(userhome)\n  root=b'/'\n else:\n  root='/'\n userhome=userhome.rstrip(root)\n return(userhome+path[i:])or root\n_varprog=None\n_varprogb=None\n\ndef expandvars(path):\n ''\n path=os.fspath(path)\n global _varprog,_varprogb\n if isinstance(path,bytes):\n  if b'$'not in path:\n   return path\n  if not _varprogb:\n   import re\n   _varprogb=re.compile(br'\\$(\\w+|\\{[^}]*\\})',re.ASCII)\n  search=_varprogb.search\n  start=b'{'\n  end=b'}'\n  environ=getattr(os,'environb',None)\n else:\n  if '$'not in path:\n   return path\n  if not _varprog:\n   import re\n   _varprog=re.compile(r'\\$(\\w+|\\{[^}]*\\})',re.ASCII)\n  search=_varprog.search\n  start='{'\n  end='}'\n  environ=os.environ\n i=0\n while True:\n  m=search(path,i)\n  if not m:\n   break\n  i,j=m.span(0)\n  name=m.group(1)\n  if name.startswith(start)and name.endswith(end):\n   name=name[1:-1]\n  try:\n   if environ is None:\n    value=os.fsencode(os.environ[os.fsdecode(name)])\n   else:\n    value=environ[name]\n  except KeyError:\n   i=j\n  else:\n   tail=path[j:]\n   path=path[:i]+value\n   i=len(path)\n   path +=tail\n return path\ntry:\n from posix import _path_normpath\nexcept ImportError:\n def normpath(path):\n  ''\n  path=os.fspath(path)\n  if isinstance(path,bytes):\n   sep=b'/'\n   empty=b''\n   dot=b'.'\n   dotdot=b'..'\n  else:\n   sep='/'\n   empty=''\n   dot='.'\n   dotdot='..'\n  if path ==empty:\n   return dot\n  _,initial_slashes,path=splitroot(path)\n  comps=path.split(sep)\n  new_comps=[]\n  for comp in comps:\n   if comp in(empty,dot):\n    continue\n   if(comp !=dotdot or(not initial_slashes and not new_comps)or\n   (new_comps and new_comps[-1]==dotdot)):\n    new_comps.append(comp)\n   elif new_comps:\n    new_comps.pop()\n  comps=new_comps\n  path=initial_slashes+sep.join(comps)\n  return path or dot\nelse:\n def normpath(path):\n  ''\n  path=os.fspath(path)\n  if isinstance(path,bytes):\n   return os.fsencode(_path_normpath(os.fsdecode(path)))or b\".\"\n  return _path_normpath(path)or \".\"\ndef abspath(path):\n ''\n path=os.fspath(path)\n if not isabs(path):\n  if isinstance(path,bytes):\n   cwd=os.getcwdb()\n  else:\n   cwd=os.getcwd()\n  path=join(cwd,path)\n return normpath(path)\ndef realpath(filename,*,strict=False):\n ''\n filename=os.fspath(filename)\n path,ok=_joinrealpath(filename[:0],filename,strict,{})\n return abspath(path)\ndef _joinrealpath(path,rest,strict,seen):\n if isinstance(path,bytes):\n  sep=b'/'\n  curdir=b'.'\n  pardir=b'..'\n else:\n  sep='/'\n  curdir='.'\n  pardir='..'\n if isabs(rest):\n  rest=rest[1:]\n  path=sep\n while rest:\n  name,_,rest=rest.partition(sep)\n  if not name or name ==curdir:\n   continue\n  if name ==pardir:\n   if path:\n    path,name=split(path)\n    if name ==pardir:\n     path=join(path,pardir,pardir)\n   else:\n    path=pardir\n   continue\n  newpath=join(path,name)\n  try:\n   st=os.lstat(newpath)\n  except OSError:\n   if strict:\n    raise\n   is_link=False\n  else:\n   is_link=stat.S_ISLNK(st.st_mode)\n  if not is_link:\n   path=newpath\n   continue\n  if newpath in seen:\n   path=seen[newpath]\n   if path is not None:\n    continue\n   if strict:\n    os.stat(newpath)\n   else:\n    return join(newpath,rest),False\n  seen[newpath]=None\n  path,ok=_joinrealpath(path,os.readlink(newpath),strict,seen)\n  if not ok:\n   return join(path,rest),False\n  seen[newpath]=path\n return path,True\nsupports_unicode_filenames=(sys.platform =='darwin')\n\ndef relpath(path,start=None):\n ''\n if not path:\n  raise ValueError(\"no path specified\")\n path=os.fspath(path)\n if isinstance(path,bytes):\n  curdir=b'.'\n  sep=b'/'\n  pardir=b'..'\n else:\n  curdir='.'\n  sep='/'\n  pardir='..'\n if start is None:\n  start=curdir\n else:\n  start=os.fspath(start)\n try:\n  start_list=[x for x in abspath(start).split(sep)if x]\n  path_list=[x for x in abspath(path).split(sep)if x]\n  i=len(commonprefix([start_list,path_list]))\n  rel_list=[pardir]*(len(start_list)-i)+path_list[i:]\n  if not rel_list:\n   return curdir\n  return join(*rel_list)\n except(TypeError,AttributeError,BytesWarning,DeprecationWarning):\n  genericpath._check_arg_types('relpath',path,start)\n  raise\ndef commonpath(paths):\n ''\n if not paths:\n  raise ValueError('commonpath() arg is an empty sequence')\n paths=tuple(map(os.fspath,paths))\n if isinstance(paths[0],bytes):\n  sep=b'/'\n  curdir=b'.'\n else:\n  sep='/'\n  curdir='.'\n try:\n  split_paths=[path.split(sep)for path in paths]\n  try:\n   isabs,=set(p[:1]==sep for p in paths)\n  except ValueError:\n   raise ValueError(\"Can't mix absolute and relative paths\")from None\n  split_paths=[[c for c in s if c and c !=curdir]for s in split_paths]\n  s1=min(split_paths)\n  s2=max(split_paths)\n  common=s1\n  for i,c in enumerate(s1):\n   if c !=s2[i]:\n    common=s1[:i]\n    break\n  prefix=sep if isabs else sep[:0]\n  return prefix+sep.join(common)\n except(TypeError,AttributeError):\n  genericpath._check_arg_types('commonpath',*paths)\n  raise\n", ["genericpath", "os", "posix", "pwd", "re", "stat", "sys"]], "stat": [".py", "''\nST_MODE=0\nST_INO=1\nST_DEV=2\nST_NLINK=3\nST_UID=4\nST_GID=5\nST_SIZE=6\nST_ATIME=7\nST_MTIME=8\nST_CTIME=9\ndef S_IMODE(mode):\n ''\n return mode&0o7777\ndef S_IFMT(mode):\n ''\n return mode&0o170000\nS_IFDIR=0o040000\nS_IFCHR=0o020000\nS_IFBLK=0o060000\nS_IFREG=0o100000\nS_IFIFO=0o010000\nS_IFLNK=0o120000\nS_IFSOCK=0o140000\n\nS_IFDOOR=0\nS_IFPORT=0\nS_IFWHT=0\ndef S_ISDIR(mode):\n ''\n return S_IFMT(mode)==S_IFDIR\ndef S_ISCHR(mode):\n ''\n return S_IFMT(mode)==S_IFCHR\ndef S_ISBLK(mode):\n ''\n return S_IFMT(mode)==S_IFBLK\ndef S_ISREG(mode):\n ''\n return S_IFMT(mode)==S_IFREG\ndef S_ISFIFO(mode):\n ''\n return S_IFMT(mode)==S_IFIFO\ndef S_ISLNK(mode):\n ''\n return S_IFMT(mode)==S_IFLNK\ndef S_ISSOCK(mode):\n ''\n return S_IFMT(mode)==S_IFSOCK\ndef S_ISDOOR(mode):\n ''\n return False\ndef S_ISPORT(mode):\n ''\n return False\ndef S_ISWHT(mode):\n ''\n return False\nS_ISUID=0o4000\nS_ISGID=0o2000\nS_ENFMT=S_ISGID\nS_ISVTX=0o1000\nS_IREAD=0o0400\nS_IWRITE=0o0200\nS_IEXEC=0o0100\nS_IRWXU=0o0700\nS_IRUSR=0o0400\nS_IWUSR=0o0200\nS_IXUSR=0o0100\nS_IRWXG=0o0070\nS_IRGRP=0o0040\nS_IWGRP=0o0020\nS_IXGRP=0o0010\nS_IRWXO=0o0007\nS_IROTH=0o0004\nS_IWOTH=0o0002\nS_IXOTH=0o0001\nUF_NODUMP=0x00000001\nUF_IMMUTABLE=0x00000002\nUF_APPEND=0x00000004\nUF_OPAQUE=0x00000008\nUF_NOUNLINK=0x00000010\nUF_COMPRESSED=0x00000020\nUF_HIDDEN=0x00008000\nSF_ARCHIVED=0x00010000\nSF_IMMUTABLE=0x00020000\nSF_APPEND=0x00040000\nSF_NOUNLINK=0x00100000\nSF_SNAPSHOT=0x00200000\n_filemode_table=(\n((S_IFLNK,\"l\"),\n(S_IFSOCK,\"s\"),\n(S_IFREG,\"-\"),\n(S_IFBLK,\"b\"),\n(S_IFDIR,\"d\"),\n(S_IFCHR,\"c\"),\n(S_IFIFO,\"p\")),\n\n((S_IRUSR,\"r\"),),\n((S_IWUSR,\"w\"),),\n((S_IXUSR |S_ISUID,\"s\"),\n(S_ISUID,\"S\"),\n(S_IXUSR,\"x\")),\n\n((S_IRGRP,\"r\"),),\n((S_IWGRP,\"w\"),),\n((S_IXGRP |S_ISGID,\"s\"),\n(S_ISGID,\"S\"),\n(S_IXGRP,\"x\")),\n\n((S_IROTH,\"r\"),),\n((S_IWOTH,\"w\"),),\n((S_IXOTH |S_ISVTX,\"t\"),\n(S_ISVTX,\"T\"),\n(S_IXOTH,\"x\"))\n)\n\ndef filemode(mode):\n ''\n perm=[]\n for table in _filemode_table:\n  for bit,char in table:\n   if mode&bit ==bit:\n    perm.append(char)\n    break\n  else:\n   perm.append(\"-\")\n return \"\".join(perm)\nFILE_ATTRIBUTE_ARCHIVE=32\nFILE_ATTRIBUTE_COMPRESSED=2048\nFILE_ATTRIBUTE_DEVICE=64\nFILE_ATTRIBUTE_DIRECTORY=16\nFILE_ATTRIBUTE_ENCRYPTED=16384\nFILE_ATTRIBUTE_HIDDEN=2\nFILE_ATTRIBUTE_INTEGRITY_STREAM=32768\nFILE_ATTRIBUTE_NORMAL=128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED=8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA=131072\nFILE_ATTRIBUTE_OFFLINE=4096\nFILE_ATTRIBUTE_READONLY=1\nFILE_ATTRIBUTE_REPARSE_POINT=1024\nFILE_ATTRIBUTE_SPARSE_FILE=512\nFILE_ATTRIBUTE_SYSTEM=4\nFILE_ATTRIBUTE_TEMPORARY=256\nFILE_ATTRIBUTE_VIRTUAL=65536\ntry:\n from _stat import *\nexcept ImportError:\n pass\n", ["_stat"]], "genericpath": [".py", "''\nimport os\nimport stat\n\n__all__=['commonprefix','exists','getatime','getctime','getmtime',\n'getsize','isdir','isfile','islink','samefile','sameopenfile',\n'samestat']\ndef exists(path):\n ''\n try:\n  os.stat(path)\n except(OSError,ValueError):\n  return False\n return True\ndef isfile(path):\n ''\n try:\n  st=os.stat(path)\n except(OSError,ValueError):\n  return False\n return stat.S_ISREG(st.st_mode)\ndef isdir(s):\n ''\n try:\n  st=os.stat(s)\n except(OSError,ValueError):\n  return False\n return stat.S_ISDIR(st.st_mode)\ndef islink(path):\n ''\n try:\n  st=os.lstat(path)\n except(OSError,ValueError,AttributeError):\n  return False\n return stat.S_ISLNK(st.st_mode)\ndef getsize(filename):\n ''\n return os.stat(filename).st_size\ndef getmtime(filename):\n ''\n return os.stat(filename).st_mtime\ndef getatime(filename):\n ''\n return os.stat(filename).st_atime\ndef getctime(filename):\n ''\n return os.stat(filename).st_ctime\ndef commonprefix(m):\n ''\n if not m:return ''\n if not isinstance(m[0],(list,tuple)):\n  m=tuple(map(os.fspath,m))\n s1=min(m)\n s2=max(m)\n for i,c in enumerate(s1):\n  if c !=s2[i]:\n   return s1[:i]\n return s1\ndef samestat(s1,s2):\n ''\n return(s1.st_ino ==s2.st_ino and\n s1.st_dev ==s2.st_dev)\ndef samefile(f1,f2):\n ''\n s1=os.stat(f1)\n s2=os.stat(f2)\n return samestat(s1,s2)\ndef sameopenfile(fp1,fp2):\n ''\n s1=os.fstat(fp1)\n s2=os.fstat(fp2)\n return samestat(s1,s2)\ndef _splitext(p,sep,altsep,extsep):\n ''\n sepIndex=p.rfind(sep)\n if altsep:\n  altsepIndex=p.rfind(altsep)\n  sepIndex=max(sepIndex,altsepIndex)\n dotIndex=p.rfind(extsep)\n if dotIndex >sepIndex:\n  filenameIndex=sepIndex+1\n  while filenameIndex <dotIndex:\n   if p[filenameIndex:filenameIndex+1]!=extsep:\n    return p[:dotIndex],p[dotIndex:]\n   filenameIndex +=1\n return p,p[:0]\ndef _check_arg_types(funcname,*args):\n hasstr=hasbytes=False\n for s in args:\n  if isinstance(s,str):\n   hasstr=True\n  elif isinstance(s,bytes):\n   hasbytes=True\n  else:\n   raise TypeError(f'{funcname}() argument must be str, bytes, or '\n   f'os.PathLike object, not {s.__class__.__name__ !r}')from None\n if hasstr and hasbytes:\n  raise TypeError(\"Can't mix strings and bytes in path components\")from None\n", ["os", "stat"]], "codecs": [".py", "''\nimport builtins\nimport sys\ntry:\n from _codecs import *\nexcept ImportError as why:\n raise SystemError('Failed to load the builtin codecs: %s'%why)\n__all__=[\"register\",\"lookup\",\"open\",\"EncodedFile\",\"BOM\",\"BOM_BE\",\n\"BOM_LE\",\"BOM32_BE\",\"BOM32_LE\",\"BOM64_BE\",\"BOM64_LE\",\n\"BOM_UTF8\",\"BOM_UTF16\",\"BOM_UTF16_LE\",\"BOM_UTF16_BE\",\n\"BOM_UTF32\",\"BOM_UTF32_LE\",\"BOM_UTF32_BE\",\n\"CodecInfo\",\"Codec\",\"IncrementalEncoder\",\"IncrementalDecoder\",\n\"StreamReader\",\"StreamWriter\",\n\"StreamReaderWriter\",\"StreamRecoder\",\n\"getencoder\",\"getdecoder\",\"getincrementalencoder\",\n\"getincrementaldecoder\",\"getreader\",\"getwriter\",\n\"encode\",\"decode\",\"iterencode\",\"iterdecode\",\n\"strict_errors\",\"ignore_errors\",\"replace_errors\",\n\"xmlcharrefreplace_errors\",\n\"backslashreplace_errors\",\"namereplace_errors\",\n\"register_error\",\"lookup_error\"]\nBOM_UTF8=b'\\xef\\xbb\\xbf'\nBOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\nBOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\nBOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\nBOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder =='little':\n BOM=BOM_UTF16=BOM_UTF16_LE\n BOM_UTF32=BOM_UTF32_LE\nelse:\n BOM=BOM_UTF16=BOM_UTF16_BE\n BOM_UTF32=BOM_UTF32_BE\nBOM32_LE=BOM_UTF16_LE\nBOM32_BE=BOM_UTF16_BE\nBOM64_LE=BOM_UTF32_LE\nBOM64_BE=BOM_UTF32_BE\nclass CodecInfo(tuple):\n ''\n _is_text_encoding=True\n def __new__(cls,encode,decode,streamreader=None,streamwriter=None,\n incrementalencoder=None,incrementaldecoder=None,name=None,\n *,_is_text_encoding=None):\n  self=tuple.__new__(cls,(encode,decode,streamreader,streamwriter))\n  self.name=name\n  self.encode=encode\n  self.decode=decode\n  self.incrementalencoder=incrementalencoder\n  self.incrementaldecoder=incrementaldecoder\n  self.streamwriter=streamwriter\n  self.streamreader=streamreader\n  if _is_text_encoding is not None:\n   self._is_text_encoding=_is_text_encoding\n  return self\n def __repr__(self):\n  return \"<%s.%s object for encoding %s at %#x>\"%\\\n  (self.__class__.__module__,self.__class__.__qualname__,\n  self.name,id(self))\nclass Codec:\n\n ''\n def encode(self,input,errors='strict'):\n  ''\n  raise NotImplementedError\n def decode(self,input,errors='strict'):\n  ''\n  raise NotImplementedError\nclass IncrementalEncoder(object):\n ''\n def __init__(self,errors='strict'):\n  ''\n  self.errors=errors\n  self.buffer=\"\"\n def encode(self,input,final=False):\n  ''\n  raise NotImplementedError\n def reset(self):\n  ''\n def getstate(self):\n  ''\n  return 0\n def setstate(self,state):\n  ''\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n ''\n def __init__(self,errors='strict'):\n  IncrementalEncoder.__init__(self,errors)\n  self.buffer=\"\"\n def _buffer_encode(self,input,errors,final):\n  raise NotImplementedError\n def encode(self,input,final=False):\n  data=self.buffer+input\n  (result,consumed)=self._buffer_encode(data,self.errors,final)\n  self.buffer=data[consumed:]\n  return result\n def reset(self):\n  IncrementalEncoder.reset(self)\n  self.buffer=\"\"\n def getstate(self):\n  return self.buffer or 0\n def setstate(self,state):\n  self.buffer=state or \"\"\nclass IncrementalDecoder(object):\n ''\n def __init__(self,errors='strict'):\n  ''\n  self.errors=errors\n def decode(self,input,final=False):\n  ''\n  raise NotImplementedError\n def reset(self):\n  ''\n def getstate(self):\n  ''\n  return(b\"\",0)\n def setstate(self,state):\n  ''\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n ''\n def __init__(self,errors='strict'):\n  IncrementalDecoder.__init__(self,errors)\n  self.buffer=b\"\"\n def _buffer_decode(self,input,errors,final):\n  raise NotImplementedError\n def decode(self,input,final=False):\n  data=self.buffer+input\n  (result,consumed)=self._buffer_decode(data,self.errors,final)\n  self.buffer=data[consumed:]\n  return result\n def reset(self):\n  IncrementalDecoder.reset(self)\n  self.buffer=b\"\"\n def getstate(self):\n  return(self.buffer,0)\n def setstate(self,state):\n  self.buffer=state[0]\nclass StreamWriter(Codec):\n\n def __init__(self,stream,errors='strict'):\n  ''\n  self.stream=stream\n  self.errors=errors\n def write(self,object):\n  ''\n  data,consumed=self.encode(object,self.errors)\n  self.stream.write(data)\n def writelines(self,list):\n  ''\n  self.write(''.join(list))\n def reset(self):\n  ''\n  pass\n def seek(self,offset,whence=0):\n  self.stream.seek(offset,whence)\n  if whence ==0 and offset ==0:\n   self.reset()\n def __getattr__(self,name,\n getattr=getattr):\n  ''\n  return getattr(self.stream,name)\n def __enter__(self):\n  return self\n def __exit__(self,type,value,tb):\n  self.stream.close()\nclass StreamReader(Codec):\n\n charbuffertype=str\n def __init__(self,stream,errors='strict'):\n  ''\n  self.stream=stream\n  self.errors=errors\n  self.bytebuffer=b\"\"\n  self._empty_charbuffer=self.charbuffertype()\n  self.charbuffer=self._empty_charbuffer\n  self.linebuffer=None\n def decode(self,input,errors='strict'):\n  raise NotImplementedError\n def read(self,size=-1,chars=-1,firstline=False):\n  ''\n  if self.linebuffer:\n   self.charbuffer=self._empty_charbuffer.join(self.linebuffer)\n   self.linebuffer=None\n  if chars <0:\n   chars=size\n  while True:\n   if chars >=0:\n    if len(self.charbuffer)>=chars:\n     break\n   if size <0:\n    newdata=self.stream.read()\n   else:\n    newdata=self.stream.read(size)\n   data=self.bytebuffer+newdata\n   if not data:\n    break\n   try:\n    newchars,decodedbytes=self.decode(data,self.errors)\n   except UnicodeDecodeError as exc:\n    if firstline:\n     newchars,decodedbytes=\\\n     self.decode(data[:exc.start],self.errors)\n     lines=newchars.splitlines(keepends=True)\n     if len(lines)<=1:\n      raise\n    else:\n     raise\n   self.bytebuffer=data[decodedbytes:]\n   self.charbuffer +=newchars\n   if not newdata:\n    break\n  if chars <0:\n   result=self.charbuffer\n   self.charbuffer=self._empty_charbuffer\n  else:\n   result=self.charbuffer[:chars]\n   self.charbuffer=self.charbuffer[chars:]\n  return result\n def readline(self,size=None,keepends=True):\n  ''\n  if self.linebuffer:\n   line=self.linebuffer[0]\n   del self.linebuffer[0]\n   if len(self.linebuffer)==1:\n    self.charbuffer=self.linebuffer[0]\n    self.linebuffer=None\n   if not keepends:\n    line=line.splitlines(keepends=False)[0]\n   return line\n  readsize=size or 72\n  line=self._empty_charbuffer\n  while True:\n   data=self.read(readsize,firstline=True)\n   if data:\n    if(isinstance(data,str)and data.endswith(\"\\r\"))or\\\n    (isinstance(data,bytes)and data.endswith(b\"\\r\")):\n     data +=self.read(size=1,chars=1)\n   line +=data\n   lines=line.splitlines(keepends=True)\n   if lines:\n    if len(lines)>1:\n     line=lines[0]\n     del lines[0]\n     if len(lines)>1:\n      lines[-1]+=self.charbuffer\n      self.linebuffer=lines\n      self.charbuffer=None\n     else:\n      self.charbuffer=lines[0]+self.charbuffer\n     if not keepends:\n      line=line.splitlines(keepends=False)[0]\n     break\n    line0withend=lines[0]\n    line0withoutend=lines[0].splitlines(keepends=False)[0]\n    if line0withend !=line0withoutend:\n     self.charbuffer=self._empty_charbuffer.join(lines[1:])+\\\n     self.charbuffer\n     if keepends:\n      line=line0withend\n     else:\n      line=line0withoutend\n     break\n   if not data or size is not None:\n    if line and not keepends:\n     line=line.splitlines(keepends=False)[0]\n    break\n   if readsize <8000:\n    readsize *=2\n  return line\n def readlines(self,sizehint=None,keepends=True):\n  ''\n  data=self.read()\n  return data.splitlines(keepends)\n def reset(self):\n  ''\n  self.bytebuffer=b\"\"\n  self.charbuffer=self._empty_charbuffer\n  self.linebuffer=None\n def seek(self,offset,whence=0):\n  ''\n  self.stream.seek(offset,whence)\n  self.reset()\n def __next__(self):\n  ''\n  line=self.readline()\n  if line:\n   return line\n  raise StopIteration\n def __iter__(self):\n  return self\n def __getattr__(self,name,\n getattr=getattr):\n  ''\n  return getattr(self.stream,name)\n def __enter__(self):\n  return self\n def __exit__(self,type,value,tb):\n  self.stream.close()\nclass StreamReaderWriter:\n\n ''\n encoding='unknown'\n def __init__(self,stream,Reader,Writer,errors='strict'):\n  ''\n  self.stream=stream\n  self.reader=Reader(stream,errors)\n  self.writer=Writer(stream,errors)\n  self.errors=errors\n def read(self,size=-1):\n  return self.reader.read(size)\n def readline(self,size=None):\n  return self.reader.readline(size)\n def readlines(self,sizehint=None):\n  return self.reader.readlines(sizehint)\n def __next__(self):\n  ''\n  return next(self.reader)\n def __iter__(self):\n  return self\n def write(self,data):\n  return self.writer.write(data)\n def writelines(self,list):\n  return self.writer.writelines(list)\n def reset(self):\n  self.reader.reset()\n  self.writer.reset()\n def seek(self,offset,whence=0):\n  self.stream.seek(offset,whence)\n  self.reader.reset()\n  if whence ==0 and offset ==0:\n   self.writer.reset()\n def __getattr__(self,name,\n getattr=getattr):\n  ''\n  return getattr(self.stream,name)\n def __enter__(self):\n  return self\n def __exit__(self,type,value,tb):\n  self.stream.close()\nclass StreamRecoder:\n\n ''\n data_encoding='unknown'\n file_encoding='unknown'\n def __init__(self,stream,encode,decode,Reader,Writer,\n errors='strict'):\n  ''\n  self.stream=stream\n  self.encode=encode\n  self.decode=decode\n  self.reader=Reader(stream,errors)\n  self.writer=Writer(stream,errors)\n  self.errors=errors\n def read(self,size=-1):\n  data=self.reader.read(size)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n def readline(self,size=None):\n  if size is None:\n   data=self.reader.readline()\n  else:\n   data=self.reader.readline(size)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n def readlines(self,sizehint=None):\n  data=self.reader.read()\n  data,bytesencoded=self.encode(data,self.errors)\n  return data.splitlines(keepends=True)\n def __next__(self):\n  ''\n  data=next(self.reader)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n def __iter__(self):\n  return self\n def write(self,data):\n  data,bytesdecoded=self.decode(data,self.errors)\n  return self.writer.write(data)\n def writelines(self,list):\n  data=b''.join(list)\n  data,bytesdecoded=self.decode(data,self.errors)\n  return self.writer.write(data)\n def reset(self):\n  self.reader.reset()\n  self.writer.reset()\n def seek(self,offset,whence=0):\n  self.reader.seek(offset,whence)\n  self.writer.seek(offset,whence)\n def __getattr__(self,name,\n getattr=getattr):\n  ''\n  return getattr(self.stream,name)\n def __enter__(self):\n  return self\n def __exit__(self,type,value,tb):\n  self.stream.close()\ndef open(filename,mode='r',encoding=None,errors='strict',buffering=-1):\n\n ''\n if encoding is not None and\\\n 'b'not in mode:\n  mode=mode+'b'\n file=builtins.open(filename,mode,buffering)\n if encoding is None:\n  return file\n try:\n  info=lookup(encoding)\n  srw=StreamReaderWriter(file,info.streamreader,info.streamwriter,errors)\n  srw.encoding=encoding\n  return srw\n except:\n  file.close()\n  raise\ndef EncodedFile(file,data_encoding,file_encoding=None,errors='strict'):\n\n ''\n if file_encoding is None:\n  file_encoding=data_encoding\n data_info=lookup(data_encoding)\n file_info=lookup(file_encoding)\n sr=StreamRecoder(file,data_info.encode,data_info.decode,\n file_info.streamreader,file_info.streamwriter,errors)\n sr.data_encoding=data_encoding\n sr.file_encoding=file_encoding\n return sr\ndef getencoder(encoding):\n\n ''\n return lookup(encoding).encode\ndef getdecoder(encoding):\n\n ''\n return lookup(encoding).decode\ndef getincrementalencoder(encoding):\n\n ''\n encoder=lookup(encoding).incrementalencoder\n if encoder is None:\n  raise LookupError(encoding)\n return encoder\ndef getincrementaldecoder(encoding):\n\n ''\n decoder=lookup(encoding).incrementaldecoder\n if decoder is None:\n  raise LookupError(encoding)\n return decoder\ndef getreader(encoding):\n\n ''\n return lookup(encoding).streamreader\ndef getwriter(encoding):\n\n ''\n return lookup(encoding).streamwriter\ndef iterencode(iterator,encoding,errors='strict',**kwargs):\n ''\n encoder=getincrementalencoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=encoder.encode(input)\n  if output:\n   yield output\n output=encoder.encode(\"\",True)\n if output:\n  yield output\ndef iterdecode(iterator,encoding,errors='strict',**kwargs):\n ''\n decoder=getincrementaldecoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=decoder.decode(input)\n  if output:\n   yield output\n output=decoder.decode(b\"\",True)\n if output:\n  yield output\ndef make_identity_dict(rng):\n\n ''\n return{i:i for i in rng}\ndef make_encoding_map(decoding_map):\n\n ''\n m={}\n for k,v in decoding_map.items():\n  if not v in m:\n   m[v]=k\n  else:\n   m[v]=None\n return m\ntry:\n strict_errors=lookup_error(\"strict\")\n ignore_errors=lookup_error(\"ignore\")\n replace_errors=lookup_error(\"replace\")\n xmlcharrefreplace_errors=lookup_error(\"xmlcharrefreplace\")\n backslashreplace_errors=lookup_error(\"backslashreplace\")\n namereplace_errors=lookup_error(\"namereplace\")\nexcept LookupError:\n\n strict_errors=None\n ignore_errors=None\n replace_errors=None\n xmlcharrefreplace_errors=None\n backslashreplace_errors=None\n namereplace_errors=None\n_false=0\nif _false:\n import encodings\n", ["_codecs", "builtins", "encodings", "sys"]], "_codecs": [".py", "\ndef ascii_decode(*args,**kw):\n pass\ndef ascii_encode(*args,**kw):\n pass\ndef charbuffer_encode(*args,**kw):\n pass\ndef charmap_build(decoding_table):\n return{car:i for(i,car)in enumerate(decoding_table)}\ndef charmap_decode(input,errors,decoding_table):\n res=''\n for car in input:\n  code=decoding_table[car]\n  if code is None:\n   raise UnicodeDecodeError(input)\n  res +=code\n return res,len(input)\ndef charmap_encode(input,errors,encoding_table):\n t=[]\n for car in input:\n  code=encoding_table.get(car)\n  if code is None:\n   raise UnicodeEncodeError(input)\n  t.append(code)\n return bytes(t),len(input)\ndef decode(obj,encoding=\"utf-8\",errors=\"strict\"):\n ''\n return __BRYTHON__.decode(obj,encoding,errors)\ndef encode(obj,encoding=\"utf-8\",errors=\"strict\"):\n ''\n return __BRYTHON__.encode(obj,encoding,errors)\ndef escape_decode(*args,**kw):\n pass\ndef escape_encode(*args,**kw):\n pass\ndef latin_1_decode(*args,**kw):\n pass\ndef latin_1_encode(*args,**kw):\n pass\ndef lookup(encoding):\n ''\n if encoding in('utf-8','utf_8'):\n  from browser import console\n  import encodings.utf_8\n  return encodings.utf_8.getregentry()\n LookupError(encoding)\ndef lookup_error(*args,**kw):\n ''\n pass\ndef mbcs_decode(*args,**kw):\n pass\ndef mbcs_encode(*args,**kw):\n pass\ndef raw_unicode_escape_decode(*args,**kw):\n pass\ndef raw_unicode_escape_encode(*args,**kw):\n pass\ndef readbuffer_encode(*args,**kw):\n pass\ndef register(*args,**kw):\n ''\n pass\ndef register_error(*args,**kw):\n ''\n pass\ndef unicode_escape_decode(*args,**kw):\n pass\ndef unicode_escape_encode(*args,**kw):\n pass\ndef unicode_internal_decode(*args,**kw):\n pass\ndef unicode_internal_encode(*args,**kw):\n pass\ndef utf_16_be_decode(*args,**kw):\n pass\ndef utf_16_be_encode(*args,**kw):\n pass\ndef utf_16_decode(*args,**kw):\n pass\ndef utf_16_encode(*args,**kw):\n pass\ndef utf_16_ex_decode(*args,**kw):\n pass\ndef utf_16_le_decode(*args,**kw):\n pass\ndef utf_16_le_encode(*args,**kw):\n pass\ndef utf_32_be_decode(*args,**kw):\n pass\ndef utf_32_be_encode(*args,**kw):\n pass\ndef utf_32_decode(*args,**kw):\n pass\ndef utf_32_encode(*args,**kw):\n pass\ndef utf_32_ex_decode(*args,**kw):\n pass\ndef utf_32_le_decode(*args,**kw):\n pass\ndef utf_32_le_encode(*args,**kw):\n pass\ndef utf_7_decode(*args,**kw):\n pass\ndef utf_7_encode(*args,**kw):\n pass\ndef utf_8_decode(decoder,bytes_obj,errors,*args):\n return(bytes_obj.decode(\"utf-8\"),len(bytes_obj))\ndef utf_8_encode(*args,**kw):\n input=args[0]\n if len(args)==2:\n  errors=args[1]\n else:\n  errors=kw.get('errors','strict')\n return(bytes(input,'utf-8'),len(input))\n", ["browser", "encodings.utf_8"]], "builtins": [".js", "(function(){\n    var obj = {},\n        builtin_names = ['ArithmeticError', 'AssertionError',\n            'AttributeError', 'BaseException', 'BaseExceptionGroup',\n            'BlockingIOError', 'BrokenPipeError', 'BufferError',\n            'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',\n            'ConnectionError', 'ConnectionRefusedError',\n            'ConnectionResetError', 'DeprecationWarning', 'EOFError',\n            'Ellipsis', 'EncodingWarning', 'EnvironmentError', 'Exception',\n            'ExceptionGroup', 'False', 'FileExistsError', 'FileNotFoundError',\n            'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',\n            'ImportError', 'ImportWarning', 'IndentationError', 'IndexError',\n            'InterruptedError', 'IsADirectoryError', 'KeyError',\n            'KeyboardInterrupt', 'LookupError', 'MemoryError',\n            'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError',\n            'NotImplemented', 'NotImplementedError', 'OSError',\n            'OverflowError', 'PendingDeprecationWarning', 'PermissionError',\n            'ProcessLookupError', 'RecursionError', 'ReferenceError',\n            'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n            'StopAsyncIteration', 'StopIteration', 'SyntaxError',\n            'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',\n            'TimeoutError', 'True', 'TypeError', 'UnboundLocalError',\n            'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',\n            'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n            'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError',\n            '_', '__build_class__', '__debug__', '__import__',\n            'abs', 'aiter', 'all', 'anext', 'any', 'ascii', 'bin', 'bool',\n            'breakpoint', 'bytearray', 'bytes', 'callable', 'chr',\n            'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir',\n            'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float',\n            'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash',\n            'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n            'iter', 'len', 'list', 'locals', 'map', 'max', 'memoryview',\n            'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print',\n            'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set',\n            'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum',\n            'super', 'tuple', 'type', 'vars', 'zip']\n    for(var key of builtin_names){\n        if(__BRYTHON__.builtins[key] !== undefined){\n            obj[key] = __BRYTHON__.builtins[key]\n        }\n    }\n    obj.__doc__ = 'builtins module'\n    obj.copyright = 'CPython copyright'\n    obj.credits = 'CPython builtins credits'\n    obj.license = 'CPython license'\n    $B.addToImported('builtins', obj)\n})()\n"], "errno": [".py", "''\nE2BIG=7\n\nEACCES=13\n\nEADDRINUSE=10048\n\nEADDRNOTAVAIL=10049\n\nEAFNOSUPPORT=10047\n\nEAGAIN=11\n\nEALREADY=10037\n\nEBADF=9\n\nEBADMSG=104\n\nEBUSY=16\n\nECANCELED=105\n\nECHILD=10\n\nECONNABORTED=10053\n\nECONNREFUSED=10061\n\nECONNRESET=10054\n\nEDEADLK=36\n\nEDEADLOCK=36\n\nEDESTADDRREQ=10039\n\nEDOM=33\n\nEDQUOT=10069\n\nEEXIST=17\n\nEFAULT=14\n\nEFBIG=27\n\nEHOSTDOWN=10064\n\nEHOSTUNREACH=10065\n\nEIDRM=111\n\nEILSEQ=42\n\nEINPROGRESS=10036\n\nEINTR=4\n\nEINVAL=22\n\nEIO=5\n\nEISCONN=10056\n\nEISDIR=21\n\nELOOP=10062\n\nEMFILE=24\n\nEMLINK=31\n\nEMSGSIZE=10040\n\nENAMETOOLONG=38\n\nENETDOWN=10050\n\nENETRESET=10052\n\nENETUNREACH=10051\n\nENFILE=23\n\nENOBUFS=10055\n\nENODATA=120\n\nENODEV=19\n\nENOENT=2\n\nENOEXEC=8\n\nENOLCK=39\n\nENOLINK=121\n\nENOMEM=12\n\nENOMSG=122\n\nENOPROTOOPT=10042\n\nENOSPC=28\n\nENOSR=124\n\nENOSTR=125\n\nENOSYS=40\n\nENOTCONN=10057\n\nENOTDIR=20\n\nENOTEMPTY=41\n\nENOTRECOVERABLE=127\n\nENOTSOCK=10038\n\nENOTSUP=129\n\nENOTTY=25\n\nENXIO=6\n\nEOPNOTSUPP=10045\n\nEOVERFLOW=132\n\nEOWNERDEAD=133\n\nEPERM=1\n\nEPFNOSUPPORT=10046\n\nEPIPE=32\n\nEPROTO=134\n\nEPROTONOSUPPORT=10043\n\nEPROTOTYPE=10041\n\nERANGE=34\n\nEREMOTE=10071\n\nEROFS=30\n\nESHUTDOWN=10058\n\nESOCKTNOSUPPORT=10044\n\nESPIPE=29\n\nESRCH=3\n\nESTALE=10070\n\nETIME=137\n\nETIMEDOUT=10060\n\nETOOMANYREFS=10059\n\nETXTBSY=139\n\nEUSERS=10068\n\nEWOULDBLOCK=10035\n\nEXDEV=18\n\nWSABASEERR=10000\n\nWSAEACCES=10013\n\nWSAEADDRINUSE=10048\n\nWSAEADDRNOTAVAIL=10049\n\nWSAEAFNOSUPPORT=10047\n\nWSAEALREADY=10037\n\nWSAEBADF=10009\n\nWSAECONNABORTED=10053\n\nWSAECONNREFUSED=10061\n\nWSAECONNRESET=10054\n\nWSAEDESTADDRREQ=10039\n\nWSAEDISCON=10101\n\nWSAEDQUOT=10069\n\nWSAEFAULT=10014\n\nWSAEHOSTDOWN=10064\n\nWSAEHOSTUNREACH=10065\n\nWSAEINPROGRESS=10036\n\nWSAEINTR=10004\n\nWSAEINVAL=10022\n\nWSAEISCONN=10056\n\nWSAELOOP=10062\n\nWSAEMFILE=10024\n\nWSAEMSGSIZE=10040\n\nWSAENAMETOOLONG=10063\n\nWSAENETDOWN=10050\n\nWSAENETRESET=10052\n\nWSAENETUNREACH=10051\n\nWSAENOBUFS=10055\n\nWSAENOPROTOOPT=10042\n\nWSAENOTCONN=10057\n\nWSAENOTEMPTY=10066\n\nWSAENOTSOCK=10038\n\nWSAEOPNOTSUPP=10045\n\nWSAEPFNOSUPPORT=10046\n\nWSAEPROCLIM=10067\n\nWSAEPROTONOSUPPORT=10043\n\nWSAEPROTOTYPE=10041\n\nWSAEREMOTE=10071\n\nWSAESHUTDOWN=10058\n\nWSAESOCKTNOSUPPORT=10044\n\nWSAESTALE=10070\n\nWSAETIMEDOUT=10060\n\nWSAETOOMANYREFS=10059\n\nWSAEUSERS=10068\n\nWSAEWOULDBLOCK=10035\n\nWSANOTINITIALISED=10093\n\nWSASYSNOTREADY=10091\n\nWSAVERNOTSUPPORTED=10092\n\nerrorcode={v:k for(k,v)in globals().items()if k ==k.upper()}\n", []], "_thread": [".py", "''\n__all__=['error','start_new_thread','exit','get_ident','allocate_lock',\n'interrupt_main','LockType']\nTIMEOUT_MAX=2 **31\nerror=RuntimeError\n\ndef daemon_threads_allowed():\n return False\ndef _set_sentinel(*args,**kw):\n return LockType()\ndef start_new_thread(function,args,kwargs={}):\n ''\n if type(args)!=type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs)!=type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main=False\n try:\n  function(*args,**kwargs)\n except SystemExit:\n  pass\n except:\n  import traceback\n  traceback.print_exc()\n _main=True\n global _interrupt\n if _interrupt:\n  _interrupt=False\n  raise KeyboardInterrupt\ndef exit():\n ''\n raise SystemExit\ndef get_ident():\n ''\n return -1\ndef allocate_lock():\n ''\n return LockType()\ndef stack_size(size=None):\n ''\n if size is not None:\n  raise error(\"setting thread stack size not supported\")\n return 0\nclass LockType(object):\n ''\n def __init__(self):\n  self.locked_status=False\n def acquire(self,waitflag=None,timeout=-1):\n  ''\n  if waitflag is None or waitflag:\n   self.locked_status=True\n   return True\n  else:\n   if not self.locked_status:\n    self.locked_status=True\n    return True\n   else:\n    if timeout >0:\n     import time\n     time.sleep(timeout)\n    return False\n __enter__=acquire\n def __exit__(self,typ,val,tb):\n  self.release()\n def release(self):\n  ''\n  self.locked_status=False\n  return True\n def locked(self):\n  return self.locked_status\n_interrupt=False\n\n_main=True\n\ndef interrupt_main():\n ''\n if _main:\n  raise KeyboardInterrupt\n else:\n  global _interrupt\n  _interrupt=True\nclass _local:\n pass\nRLock=LockType\n", ["time", "traceback"]], "_dummy_thread": [".py", "''\n__all__=['error','start_new_thread','exit','get_ident','allocate_lock',\n'interrupt_main','LockType','RLock']\nTIMEOUT_MAX=2 **31\nerror=RuntimeError\n\ndef start_new_thread(function,args,kwargs={}):\n ''\n if type(args)!=type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs)!=type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main=False\n try:\n  function(*args,**kwargs)\n except SystemExit:\n  pass\n except:\n  import traceback\n  traceback.print_exc()\n _main=True\n global _interrupt\n if _interrupt:\n  _interrupt=False\n  raise KeyboardInterrupt\ndef exit():\n ''\n raise SystemExit\ndef get_ident():\n ''\n return 1\ndef allocate_lock():\n ''\n return LockType()\ndef stack_size(size=None):\n ''\n if size is not None:\n  raise error(\"setting thread stack size not supported\")\n return 0\ndef _set_sentinel():\n ''\n return LockType()\nclass LockType(object):\n ''\n def __init__(self):\n  self.locked_status=False\n def acquire(self,waitflag=None,timeout=-1):\n  ''\n  if waitflag is None or waitflag:\n   self.locked_status=True\n   return True\n  else:\n   if not self.locked_status:\n    self.locked_status=True\n    return True\n   else:\n    if timeout >0:\n     import time\n     time.sleep(timeout)\n    return False\n __enter__=acquire\n def __exit__(self,typ,val,tb):\n  self.release()\n def release(self):\n  ''\n  if not self.locked_status:\n   raise error\n  self.locked_status=False\n  return True\n def locked(self):\n  return self.locked_status\n def __repr__(self):\n  return \"<%s %s.%s object at %s>\"%(\n  \"locked\"if self.locked_status else \"unlocked\",\n  self.__class__.__module__,\n  self.__class__.__qualname__,\n  hex(id(self))\n  )\nclass RLock(LockType):\n ''\n def __init__(self):\n  super().__init__()\n  self._levels=0\n def acquire(self,waitflag=None,timeout=-1):\n  ''\n  locked=super().acquire(waitflag,timeout)\n  if locked:\n   self._levels +=1\n  return locked\n def release(self):\n  ''\n  if self._levels ==0:\n   raise error\n  if self._levels ==1:\n   super().release()\n  self._levels -=1\n_interrupt=False\n\n_main=True\n\ndef interrupt_main():\n ''\n if _main:\n  raise KeyboardInterrupt\n else:\n  global _interrupt\n  _interrupt=True\n", ["time", "traceback"]], "editor": [".py", ""]}